\chapter{A script Language for Interactive Proving}{}
\label{ch:script}


Since proofs are just terms one could,
in principle, use no proof language and directly input proof terms instead.
Indeed this was the modus operandi in the pioneering work of
De Bruijn on Automath (automating mathematics) in the seventies~\cite{nederpelt-94}.
The use of a dedicated proof language enables a higher level
description of the formal proof being constructed. Importantly, it
provides support for taming the bookkeeping part of the activity of
interactive proving.

  The proof commands we have mentioned in chapter~\ref{ch:proofs} can all be
explained in terms of the proof terms they produce behind the scenes.
For example, \C{case: n} provides a much more compact syntax
for \C{(match .. with .. end)} and it produces a
\C{match} expression with the right
shape by looking at the type of \C{n}.  If \C{n} is a natural number, then there
are two branches; the one for the \C{S} constructor carries an argument of type
\C{nat}, the other one is for \C{0} and binds no additional term.
The \C{case:} tactic is general enough to work with any inductive data type
and inductive predicate. Note that this tactic is known as
\emph{destruction}, since it transforms an object of an inductive type
back into the arguments that this object was constructed from (using
the constructors of the type).
% [DG] I've introduced the word "destruction", since you use it later
% on.

The \C{apply:} tactic generates an application.  For example, \C{apply: addnC}
generates the term \C{(addnC t1 t2)} by figuring out the correct values of
\C{t1} and \C{t2}, or opening new goals when this cannot be done, i.e.,
if the lemma takes in input proofs, like \C{contraL}.

There is a list of proof commands that are shorthands for \C{apply:}
and are only worth mentioning here briefly. \C{split} proves a conjunction
by applying the \C{conj} constructor; \C{left} and \C{right} prove a
disjunction by applying \C{or\_introl} and \C{or\_intror} respectively;
\C{exists t} proves an existentially quantified formula by providing
the witness \C{t} and, later, a proof that \C{t} validates the predicate.
Finally \C{reflexivity} proves an equality by applying \C{erefl}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Managing the proof context}
The only primitive constructor that remains without an associated proof command
is \C{(fun .. => ..)}.  Operationally, what the $\to_I$ and
$\forall_I$ logical rule do is to introduce into the proof context a
new entry.  So far we either expressed this step at the beginning of proofs
by placing such items just after the name of the lemma being proved, or
just after a \C{case:} or \C{elim:} proof command.  The current section
expands on this subject covering the full management of the proof context.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Goals as stacks}\label{ssec:stack}
\index[concept]{goal stack model}

The presentation we gave so far of proof commands like \C{case: n => [|m]}
is oversimplified.  While \C{case} is indeed the proof command in
charge of performing case analysis, the ``\C{: n}'' and ``\C{=> [|m]}''
parts are decorators to prepare the goal and post-process the result of
the proof command.  These decorators perform what we typically call
\emph{bookkeeping}: actions that are necessary in order to obtain readable and
robust proof scripts but that are too frequent to benefit from a more verbose
syntax.  Bookkeeping actions do convey a lot of information, like where
names are given to assumptions, but also let one deal with annoying details
using a compact, symbolic, language.  Note that all bookkeeping actions
correspond to regular, named, proof commands.  It is the use one makes of them
that may be twofold: a case analysis in the middle of a proof may start two
distinct lines of reasoning, and hence it is worth being noted explicitly with
the \C{case} word. Conversely, breaking a pair into two pieces is
usually not a significant, meaningful step in a proof: hence the
possibility to use a lightweight and compact syntax for this bookkeeping
action, instead of an explicit mention of the \C{case} tactic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pulling from the stack}
\index[ssr]{\C{tactic => ..}}

Let's start with the post-processing phase, called \emph{introduction pattern}.
The postfix ``\C{=> ...}'' syntax can be used in conjunction with any proof
command, and it performs a sequence of actions on the first
assumption or variable that appears in the goal (i.e., on
\C{A} if the goal has the form \C{A -> B -> C -> ...}, or on
\C{x} if the goal has the form \C{forall x, ...}).
With these looking glasses, the goal becomes a
\emph{stack}. Take for example this goal:

\begin{coqout}{name=Stack}{}
========================
forall xy, prime xy.1 -> odd xy.2 -> 2 < xy.2 + xy.1
\end{coqout}

Before accessing the assumption \C{(prime xy.1)}, one has to name the
bound variable \C{xy}, exactly as one can only access a stack from its top.
The execution of \C{=> xy pr\_x odd\_y} is just the composition of
\C{=> xy} with \C{=> pr\_x} and finally \C{=> odd\_y}.  Each action
pulls an item out of the stack and names it.  The \C{move} proof
command does nothing, so we use it as a placeholder
for the postfix \C{=>} bookkeeping action:

\begin{coq-left}{}{width=7cm}
move=> xy pr_x odd_y.
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack1}{width=5cm}
 xy : nat * nat
 pr_x : prime xy.1
 odd_y : odd xy.2
========================
 2 < xy.2 + xy.1
\end{coqout-right}

Now, en passant, we would like to decompose \C{xy} into its first
and second component.  Instead of the verbose \C{=> xy; case: xy => x y},
we can use the symbolic notation \C{[]} to perform such action.

\begin{coq-left}{}{width=7cm}
move=> [x y] pr_x odd_y.
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=5cm}
 x, y : nat
 pr_x : prime (x,y).1
 odd_y : odd (x,y).2
========================
 2 < (x,y).2 + (x,y).1
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> [ .. $\mid$ .. ]} (case)}

We can place the \C{/=} switch to force the system to reduce the formulas on
the stack, before introducing them in the context, and obtain:

\begin{coq-left}{}{width=7cm}
move=> [x y] /= pr_x odd_y.
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=5cm}
 x, y : nat
 pr_x : prime x
 odd_y : odd y
========================
 2 < y + x
\end{coqout-right}

We can also process an assumption through a lemma; when a lemma is
used in this way, it is called a \emph{view}. This feature is of
general interest, but it is especially useful in the context of boolean
reflection, as described in section~\ref{sec:views}. For example,
\C{prime\_gt1} states \C{(prime p -> 1 < p)} for any \C{p}, and we can
use it as a function to obtain a proof of \C{(1 < x)}  from a proof
of \C{(prime x)}.
\index[concept]{view}


\begin{coq-left}{}{width=7cm}
move=> [x y] /= /prime_gt1-x_gt1 odd_y.
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=5cm}
 x, y : nat
 x_gt1 : 1 < x
 odd_y : odd y
========================
 2 < y + x
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> /=} (simplification)}

The leading \C{/} makes \C{prime\_gt1} work as a function instead of
as a name to be assigned to the top of the stack.  The \C{-} has no effect but
to visually link the function with the name \C{x_gt1} assigned to its output.
Indeed \C{-} can be omitted.

One could also examine \C{y}: it can't be \C{0}, since it would contradict
the assumption saying that \C{y} is \C{odd}.

\begin{coq-left}{}{width=7cm}
move=> [x [//|y]] /= /prime_gt1-x_gt1.
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=5cm}
 x, y : nat
 x_gt1 : 1 < x
 ========================
 ~~ odd y -> 2 < y.+1 + x
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> /view} (view application)}
\index[ssr]{\C{tactic => ..}!\C{=> //} (close trivial goals)}

This time, the destruction of \C{y} generates two cases for the two
branches; hence the \C{[ .. | .. ]} syntax.  In the first one, when
\C{y} is \C{0},
the \C{//} action solves the goal, by the trivial means
of the \C{by []} terminator.  In the second branch we name \C{y} the
new variable (which is legitimate, since the old \C{y} has been
disposed of).

Now, the fact that \C{y} is even is not needed to conclude, so we can
discard it by giving it the \C{\_} dummy name.

\begin{coq}{}{}
by move=> [x [//|y]] /= /prime_gt1-x_gt1 _; apply: ltn_addl x_gt1.
\end{coq}

The way to discard an already named assumption is to mention
its name in curly braces, as \C{=> \{x_gt1\}}.
\index[ssr]{\C{tactic => ..}!\C{=> \{name\}} (disposal)}

We finally conclude with the \C{apply:} command. In the example just
shown, we have used it with two arguments: a function and its last
argument. In fact, the lemma \C{ltn\_addl} looks as follows:

\begin{coq-left}{}{width=4cm}
About ltn_addl.
$~$
$~$
\end{coq-left}
\begin{coqout-right}{}{width=8cm}
ltn_addl : forall m n p : nat,
  m < n -> m < p + n
Arguments m, n are implicit
\end{coqout-right}

\C{apply:} automatically fills in the blanks between the function
\C{ltn\_addl}
(the lemma name) and the argument \C{x_gt1} provided.
Since we are passing \C{x\_gt1}, the
variable \C{m} picks the value \C{1}.  The conclusion of \C{ltn\_addl}
hence unifies with \C{(2 < y.+1 + x)} because both \C{+} and \C{<} are
defined as programs that compute: Namely, addition exposes a \C{.+1},
thus reducing to \C{2 < (y+x).+1}; then \C{<} (or, better, the underlying
\C{<=}) eats a successor from both sides, leading to \C{1 < y + x},
which looks like the conclusion of the lemma we apply.

Here we have shown all possible actions one can perform in an intro
pattern, squeezing the entire proof into a single line.  This has
to be seen both as an opportunity and as a danger: one can easily
make a proof unreadable by performing too many actions in the bookkeeping
operator \C{=>}.  At the same time, a trivial sub-proof like this one
should take no more than a line, and in that case one typically
sacrifices readability in favor of compactness: what would you learn by
reading a trivial proof?  Of course,
finding the right balance only comes with experience.

\gotcha{The case intro pattern \C{[..|..]} obeys an exception: when it is the first
item of an intro pattern, it does not perform a case analysis, but only branch
on the subgoals.
%\footnote{not the status quo, but I prefer this exception to the current one}
Indeed in \C{case: n => [|m]} only one case analysis is performed.}

% [DG] The last two paragraphs (including the gotcha) seem direly in
% need of expanding. I can at most guess what the gotcha is talking
% about; it appears to be the double meaning of a
% [ ... | ... | ... ] that is placed after the => tactical depending
% on whether it is in the first position ("branching") or not
% ("destructing"), as in ยง5.4 in the SSReflect manual. I cannot say
% the manual completely clears things up for me, but at least it
% sounds like what the gotcha is warning about. I think we need at
% least one example of each of the possible meanings, along with an
% example of how to enforce the destructing meaning in the first
% position (using the "-" switch?).
%
% On a lesser issue, the word "intro pattern" is used but not
% explained; this holds even for the SSReflect manual! Is an intro
% pattern just anything that laeds to a new constant in the context?
% assia : TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Working on the stack}

The stack can also be used as a workplace.  Indeed, there is no need
to pull all items from the stack.  If we take the previous example:

\begin{coqout}{name=Stack}{}
========================
forall xy, prime xy.1 -> odd xy.2 -> 2 < xy.2 + xy.1
\end{coqout}
and we stop just after applying the view, we end up in a valid state:

\begin{coq-left}{}{width=6cm}
move=> [x y] /= /prime_gt1.
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=6cm}
 x, y : nat
 ========================
 1 < x -> odd y -> 2 < y + x
\end{coqout-right}

One can also chain multiple views on the same stack item:

\begin{coq-left}{}{width=6cm}
move=> [x y] /= /prime_gt1/ltnW.
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=6cm}
 x, y : nat
 ========================
 0 < x -> odd y -> 2 < y + x
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> /view/view} (many views)}

Two other operations are available on the top stack item: specialization
and substitution.  Let's take the following conjecture.

\begin{coqout}{}{}
========================
(forall n, n * 2 = n + n) -> 6 = 3 + 3
\end{coqout}

The top stack item is a quantified assumption.  To specialize it to, say,
\C{3} one can write as follows:

\begin{coq-left}{}{width=4cm}
move=> /(_ 3).
$~$
\end{coq-left}
\begin{coqout-right}{}{width=8cm}
========================
3 * 2 = 3 + 3 -> 6 = 3 + 3
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> /(_ arg)} (specialization)}
% [DG] Why is there an "=>" after the "move" in the above example?
% Nothing is getting moved into the context. Without the "=>" it works
% just as fine. I'm surprised it works with "=>", though!
% assia: TODO

The idea behind the syntax here is that when we apply a view \C{v} to
the top stack item (say, \C{top}), by writing \C{/v}, we are
forming the term \C{(v top)}, whereas
when we specialize the top stack item \C{top} to an object \C{x},
by writing \C{/(_ x)}, we are forming the term \C{(top x)}.  The \C{_}
is a placeholder for the top item, and is
omitted in \C{/(v _)}.
% [DG] Better "omitted in \C{/v}"?
% assia: TODO

When the top stack item is an equation, one can substitute it into
the rest of the goal, using the tactics \C{<-}
% [DG] Is "tactics" the right word here?
% assia: TODO

and \C{->} for right-to-left and left-to-right respectively.

\begin{coq-left}{}{width=4cm}
move=> /(_ 3) <-.
$~$
\end{coq-left}
\begin{coqout-right}{}{width=8cm}
========================
6 = 3 * 2
\end{coqout-right}
\index[ssr]{\C{tactic => ..}!\C{=> ->} (rewriting L2R)}
\index[ssr]{\C{tactic => ..}!\C{=> <-} (rewriting R2L)}

In other words, the arrows are just a compact syntax for rewriting,
as in the \C{rewrite} tactic, with the top assumption.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pushing to the stack}
\index[ssr]{\C{tactic : ..}}

We have seen how to pull items from the stack to the context.
Now let's see the so called \emph{discharging} operator \C{:}, performing
the converse operation.
Such operator decorates
proof commands as \C{move}, \C{case} and \C{elim}
 with actions to be performed before the command is actually run.

\gotcha{The colon symbol in \C{apply:} is not the discharging operator.
It is just a marker to distinguish the \C{apply:} tactic of
SSReflect from the \C{apply} tactic of \Coq{}.
Indeed the two tactics, while
playing similar roles, behave differently~\cite[\S 5.2 and \S 5.3]{ssrman}.}

Imagine we want to perform case analysis on \C{y} at this stage:

\begin{coqout}{name=Stack2}{}
 x, y : nat
 x_gt1 : 1 < x
 odd_y : odd y
 ========================
 2 < y + x
\end{coqout}

The command \C{case: y} is equivalent to
\C{move: y; case.} where \C{move} once again is a placeholder,
\C{: y} pushes the \C{y} variable onto the stack, and \C{case}
operates on the top item of the stack.
Pushing items on the stack is called \emph{discharging}.
% [DG] Reinstated, since you use the term.
% assia: TODO

Just before running \C{case}, the goal would look like this:

\begin{coqout}{name=Stack2}{}
 x : nat
 x_gt1 : 1 < x
 odd_y : odd y
 ========================
 forall y, 2 < y + x
\end{coqout}

However, this is not actually a well-defined state.
Indeed, the binding for \C{y} is needed by the \C{odd\_y}
context item, so \C{move: y} fails.  One has to push items onto the
stack in a valid order: first, all properties of a variable, then the
variable itself.  The correct invocation,
\C{move: y odd\_y}, pushes first \C{odd\_y} and only then \C{y} onto
the stack, leading to the valid goal

\begin{coqout}{name=Stack2}{label=lst:stack2}
 x : nat
 x_gt1 : 1 < x
 ========================
 forall y, odd y -> 2 < y + x
\end{coqout}
\index[ssr]{\C{tactic : ..}!\C{: term} (generalization)}

Via the execution of \C{case} one obtains:

\begin{coqout}{name=Stack2}{}
2 subgoals

  x : nat
  x_gt1 : 1 < x
  ========================
   odd 0 -> 2 < 0 + x

subgoal 2 is:
 forall n : nat, odd n.+1 -> 2 < n.+1 + x
\end{coqout}

Note that listing context entry names inside curly braces purges them
from the context. For instance the tactic \C{case: y \{odd\_y\}}
clears the \C{odd\_y} fact. But this would lead to a dead end in the
present proof, so let us come back to the proof of the
implication~\ref{lst:stack2}.

\index[ssr]{\C{tactic : ..}!\C{: \{name\}} (disposal)}

One can combine \C{:} and \C{=>} around a proof command, to first prepare the
goal for its execution and finally apply the necessary bookkeeping to the
result.  For example:

\begin{coq-left}{}{width=6cm}
case: y odd_y => [|y']
$~$
$~$
$~$
$~$
$~$
$~$
\end{coq-left}
\begin{coqout-right}{name=Stack2}{width=6cm}
  x : nat
  x_gt1 : 1 < x
  ========================
   odd 0 -> 2 < 0 + x

subgoal 2 is:
 odd y'.+1 -> 2 < y'.+1 + x
\end{coqout-right}

At the left of the \C{:} operator one can also put a name for an
equation that links the term at the top of the stack before and
after the execution of the tactic. For example,
 \C{case E: y odd\_y => [|y']} leads to
the following two subgoals:

\begin{coqout}{name=Stack2}{width=6cm}
 x, y : nat
 x_gt1 : 1 < x
 E : y = 0
============================
 odd 0 -> 2 < 0 + x
\end{coqout}
\begin{coqout}{name=Stack2}{width=6cm}
 x, y : nat
 x_gt1 : 1 < x
 y' : nat
 E : y = y'.+1
========================
 odd y'.+1 -> 2 < y'.+1 + x
\end{coqout}
\index[ssr]{\C{tactic : ..}!\C{name: term} (equation)}

Last, one can push any term onto the stack -- whether or not this
term appears in the context. For example,
``\C{move: (leqnn 7)}'' pushes on the stack
the additional assumption \C{(7 <= 7)} (and thus
``\C{move: (leqnn 7) => A}'' brings this assumption into the context
under the name \C{A}). This
will come handy in section~\ref{sec:strongind}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Example: strengthening induction}
\index[concept]{induction!strong}
\index[concept]{induction!curse of values}
\label{sec:strongind}

As an exercise we show how the \C{elim} tactic combined with the bookkeeping
operator \C{:} lets one perform, on the fly, a stronger variant of
induction called ``course of values'' or ``strong induction''.
% [DG] I've never seen it called "course of values". Apparently this
% name is mostly used in computability theory? But "strong induction"
% appears very often.
%assia : TODO

Claim: every amount of postage that is at least 12 cents
can be made from 4-cent and 5-cent stamps.  The proof in the inductive
step goes as follows.  There are obvious solutions for a postage between
12 and 15 cents, so we can assume it is at least 16 cents.  Since
the postage amount is at least 16, by using a 4-cents stamp we are back
at a postage amount that, by induction, can be obtained as claimed.\hfill$\square$

The tricky step is that we want to apply the induction hypothesis not
on $n-1$, as usual, but on $n-4$, since we know how to turn a
solution for a stamping amount problem $n$ to one for a problem of
size $n+4$ (by using a 4-cent stamp).
The induction hypothesis provided by \C{nat_ind}
is not strong enough.  However we can use the \C{:} operator
to load the goal before performing the induction.\footnote{See further
below for explanations.}
\index[ssr]{\C{set name := term}}

\begin{coq}{}{}
Lemma stamps n : 12 <= n -> exists s4 s5, s4 * 4 + s5 * 5 = n.
Proof.
elim: n {-2}n (leqnn n) =>[|n IHn]; first by case.
do 12! [ case; first by [] ]. (* < 12c *)
case; first by exists 3, 0.   (* 12c = 3 * 4c *)
case; first by exists 2, 1.   (* 13c = 2 * 4c + 1 * 5c *)
case; first by exists 1, 2.   (* 14c = 1 * 4c + 2 * 5c *)
case; first by exists 0, 3.   (* 15c = 3 * 5c *)
move=> m'; set m := _.+1; move=> mn m11.
case: (IHn (m-4) _ isT) => [|s4 [s5 def_m4]].
  by rewrite leq_subLR (leq_trans mn) // addSnnS leq_addl.
by exists s4.+1, s5; rewrite mulSn -addnA def_m4 subnKC.
Qed.
\end{coq}

Line 3 requires some explanations. First of all,
``\C{elim: n \{-2\}n (leqnn n).}'' is shorthand for
``\C{move: (leqnn n). move: \{-2\}n. move: n. elim.}'' (the terms after the
colon \C{:} are pushed to the stack, from right to left; and the
\C{elim} tactic is applied afterwards to the top of the stack, which
of course is the last term pushed to the stack). Let us see how these
four steps transform the goal. At the beginning, the context and the
goal are

\begin{coqout}{}{width=11cm}
  n : nat
  ============================
  11 < n -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = n
\end{coqout}

The first of our
four steps (``\C{move: (leqnn n)}'') pushes the additional
assumption \C{n <= n} onto the stack (since \C{(leqnn n)} provides
its proof); we are thus left with

\begin{coqout}{}{width=11cm}
1 subgoal

  n : nat
  ============================
  n <= n -> 11 < n -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = n
\end{coqout}

The second step (``\C{move: \{-2\}n}'') is more interesting. Recall
that \C{move:} usually ``generalizes'' a variable (i.e., takes a
variable appearing in the context, and binds it by the universal
quantifier, so that the goal becomes a for-all statement). The prefix
\C{\{-2\}} means ``all except for the 2nd occurrence in the goal''; so
the idea is
to generalize ``all except for the 2nd occurrence of $n$''. Of course,
this implies that $n$ still has to remain in the context (unlike for
``\C{move: n}''), so the
bound variable of the universal quantifier has to be a fresh
variable, picked automatically by \Coq{}. For example, \Coq{} might
pick \C{n0} for its name, and so the state after the second step will
be:

\begin{coqout}{}{width=11cm}
  n : nat
  ============================
  forall n0 : nat,
  n0 <= n -> 11 < n0 -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = n0
\end{coqout}

Notice how the \C{n} in ``\C{n0 <= n}'' has remained un-generalized,
since it was the 2nd occurrence of $n$ before the second step.

The third step (``\C{move: n}'') merely moves the \C{n} from the
context to the goal. Thus, after the three ``\C{move}'' steps, we are
left with proving the following claim:

\begin{coq}{}{}
forall n n0 : nat,
  n0 <= n -> 11 < n0 -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = n0
\end{coq}

The \C{elim} now applies induction on the top of the stack, which
is \C{n}. The corresponding induction hypothesis \C{IHn} is:

\begin{coq}{}{}
IHn : forall n0 : nat,
      n0 <= n ->
      11 < n0 -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = n0
\end{coq}

(Of course, the \C{n} here is not the original \C{n}, but the new
\C{n} introduced in the \C{=>[|n IHn]} pattern.)
% Such hypothesis is accessible for each \C{n0} that is at least \C{12}
% and smaller than \C{n}.

% Loading the goal works as follows: first \C{(leqnn n)} is pushed on
% the stack, then all occurrences of \C{n} but for the second one are
% discharged obtaining

% \begin{coq}{}{}
% forall m : nat,
  % m <= n -> 11 < m -> exists s4 s5 : nat, s4 * 4 + s5 * 5 = m
% \end{coq}
% Finally the last occurrence of \C{n} is discharged too so that induction is performed
% on such quantified variable.

Lines 4, 9 and 10 deserve a few comments.
\begin{itemize}
\item Line 4 repeats a tactic 12 times using the \C{do 12!} tactical.
This deals with the 12 cases where \C{n0} is not greater than 11.
\item Line 9 uses the \C{set} proof command, which is used to define a new
constant in the context. For example, ``\C{set a := 24 * 11.}'' would
create a new ``\C{a := 24 * 11 : nat}'' item in the context. The
command also tries to substitute the newly-defined constant for its
appearances in the goal; for example, ``\C{set a := 11.}'' would not
only create a new ``\C{a := 11 : nat}'' in the context, but also
replace the ``\C{11 < m'.+4.+4.+4.+4}'' in the goal\footnote{Don't be
surprised by the fact that an addition of 16 is circumscribed by four
additions of 4. By default, \mcbMC{} has the notations \C{.+1},
\C{.+2}, \C{.+3} and \C{.+4} pre-defined, but not \C{.+5} and higher.}
by an ``\C{a < m'.+4.+4.+4.+4}''. In our example above
(``\C{set m := _.+1}''), we are using the
\C{set} command with a wildcard; this captures the first term of the
form \C{_.+1} appearing in the goal and denotes it by \C{m}, replacing
it by \C{m} on the goal. In our case, this first term is
\C{m'.+4.+4.+4.+4} (which is just syntactic sugar for
\C{m'.+1.+1.....} with 16 appearances of \C{.+1})\footnote{This is
slightly counterintuitive, as you
might instead believe it to be \C{m'.+3.+4.+4.+4}. But keep in mind
that \C{m'.+3.+4.+4.+4 < n.+1} is just syntactic sugar for
\C{m'.+4.+4.+4.+4 <= n.+1}.},
% [DG] I hope I got these subtleties right. That said, I think it
% would be better to first introduce the "set" tactic in a less
% confusing example.
%assia : TODO
and so the name \C{m} is given to this term. We could have achieved
the same goal using ``\C{set m := m'.+4.+4.+4.+4}''.
\par
Further details about the \C{set} tactic can be found in
\cite[\S 4.2]{ssrman}; let us only mention the (by now) habitual
variant \C{set a := \{k\}(pattern)}, which defines a new constant
\C{a} to equal the first subterm of the goal that matches the pattern
\C{pattern}, but then replaces \emph{only the \(k\)-th} appearance
of this subterm in the goal by \C{a}. As usual, if the
pattern-matching algorithm keeps finding the wrong subterms, it is
always possible to completely specify the subterm, leaving no
wildcards.
\item Line 10 instantiates the induction hypothesis with the value
\C{(m-4)}, with a placeholder for a missing proof of \C{(m-4 < n)},
and with a proof that \C{(11 < m-4)}. The proof given for
\C{(11 < m-4)} is just a simple application of \C{isT}; this is
accepted because the term \C{(11 < m-4)} \emph{computes} to
\C{true} (thanks to the computational definitions of \C{<} and of
subtraction, and thanks to \C{m := m'.+4.+4.+4.+4}). The missing proof
of \C{(m-4 < n)} is not automatically inferred; it becomes the first
subgoal. The induction hypothesis yields
\C{exists s4 s5 : nat, s4 * 4 + s5 * 5 = m-4}. The introduction
pattern in line 10 gives names to the values of \C{s4} and \C{s5}
whose existence is thus guaranteed, and to the statement that
\C{s4 * 4 + s5 * 5 = m-4}. In other words, it gives names \C{s4} and
\C{s5} to the quantities of 4-cent and 5-cent stamps needed to cover
the amount of postage \C{(m-4)}, as well as to the fact that they do
cover this exact amount of postage.
% [DG] I find it counterintuitive that the intro pattern is
% "[|s4 [s5 def_m4]]" and not "[|s4 s5 def_m4]". Is there some neat
% and short explanation of this? (Not too important, but would
% complete the picture.)
%assia : TODO
\end{itemize}
\index[ssr]{\C{do n"!} (iteration)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structuring proofs, by examples}

So far we've only tackled simple lemmas; most of them did admit a one line
proof.  When proofs get longer \emph{structure} is the best ally in making
them readable and maintainable.  Structuring proofs means identifying
intermediate results, factoring similar lines of reasoning (e.g., symmetries),
signaling crucial steps to the reader, and so on.  In short, a
proof written in \Coq{} should not look too different from a proof
written on paper.

The first subsection introduces the \C{have} tactic, that is the key
to structure proofs into intermediate steps.  The second subsection
deals with the ``problem'' of symmetries.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Primes, a never ending story}\label{sec:infprimes}
\index[concept]{forward reasoning}

Saying that primes are infinite can be phrased as: for any natural number
$m$, there exists a prime greater than $m$.  The proof of this claim goes like
that: every natural number greater than 1 has at least one prime divisor.  If
we take $m! + 1$, then such prime divisor $p$ can be shown to be greater than $m$ as
follows.  By contraposition we assume $p \leq m$ and we show that $p$
does not divide $m!+1$.
Being smaller than $m$, $p$ divides $m!$, hence to divide $m!+1$, $p$ should divide
$1$; that is not possible since $p$ is prime, hence greater than 1.
\hfill$\square$

We first show that any positive number smaller than $n$ divides $n!$.

\begin{coq}{}{}
Lemma dvdn_fact m n : 0 < m <= n -> m %| n`!.
Proof.
case: m => //= m; elim: n => //= n IHn; rewrite ltnS leq_eqVlt.
by case/orP=> [/eqP-> | /IHn]; [apply: dvdn_mulr | apply: dvdn_mull].
Qed.
\end{coq}

After the first line the proof state is the following one:

\begin{coqout}{}{}
m, n : nat
IHn : m < n -> m.+1 %| n`!
========================
(m == n) || (m < n) -> m.+1 %| (n.+1)`!
\end{coqout}
The case analysis rules out \C{(m = 0)}, and simplifies the hypothesis
to \C{(m <= n)}.  Recall that \C{(x <= y <= z)} is a notation for \C{((x <= y) &&
(y <= z))}; hence when the first inequality evaluates to true (e.g. when \C{x}
is 0) the conjunction simplifies to the second conjunct.  The \C{leq_eqVlt}
rewrite rule rephrases \C{<=} as a disjunction (the capital \C{V} letter
is reminiscent of $\lor$).

When we reason by cases on the top assumption, line 4, we face two goals, both
easy to solve if we look at the development of the factorial of \C{n.+1},
i.e., \D{(n.+1 * n`!)}.  The former amounts to showing that
\D{(n.+1 \%| n.+1 * n`!)}, while the latter to showing that \D{(m.+1 \%| n.+1 *
n`!)} under the (inductive) hypothesis that \D{(m.+1 \%| n`!)}.

What is paradigmatic in this little proof is the use of the \emph{goal stack
as a work space}.  In other words the proof script would be much more involved
if we started by introducing in the proof context all assumptions.
\\

We can now move to the proof of the main result.  We state it using a
``synonym'' of the exists quantifier that is specialized to carry two
properties.  This way the statement is simpler to destruct: with just one
case analysis we obtain the witness and the two properties.
We also resort to the following lemmas.

\begin{coq}{}{title=Tools}
Lemma fact_gt0 n : 0 < n`!.
Lemma pdivP n : 1 < n -> exists2 p, prime p & p %| n,
Lemma dvdn_addr m d n : d %| m -> (d %| m + n) = (d %| n).
Lemma gtnNdvd n d : 0 < n -> n < d -> (d %| n) = false.
\end{coq}
The first step is to prove that $m! + 1$ is greater than $1$, a triviality.
Still it gives us the occasion to explain the \C{have} tactic, which lets us
augment the proof context with a new fact, typically an intermediate step of
our proof.
\index[ssr]{\C{have name : type}}
\index[ssr]{\C{have name : type by tactic}}

\begin{coq}{}{}
Lemma prime_above m : exists2 p, m < p & prime p.
Proof.
have m1_gt1: 1 < m`! + 1.
  by rewrite addn1 ltnS fact_gt0.
\end{coq}

Its syntax is similar to the one of the \C{Lemma} command: it takes a name, a
statement and starts a (sub) proof.  Since the proof is so short, we will
put it on the same line, and remove the full stop.

The next step is to use the \C{pdivP} lemma to gather a prime divisor of
\D{m`!.+1}.  We end up with the following, rather unsatisfactory, script.

\begin{coq}{}{}
Lemma prime_above m : exists2 p, m < p & prime p.
Proof.
have m1_gt1: 1 < m`! + 1 by rewrite addn1 ltnS fact_gt0.
case: (pdivP m1_gt1) => [p pr_p p_dv_m1].
\end{coq}

It is unsatisfactory because in our paper proof what plays an
interesting role is the \C{p} that we obtain in the second line,
and not the \C{m1_gt1} fact we proved as an intermediate fact.

We can resort to the flexibility of \C{have} to obtain a more
pertinent script: the first argument to \C{have}, here a name, can
actually be any introduction pattern, i.e. what follows
the \C{=>} operator, for example a view application.
In the light of that, the script can be
rearranged as follows.

\begin{coq}{}{}
Lemma prime_above m : exists2 p, m < p & prime p.
Proof.
have /pdivP[p pr_p p_dv_m1]: 1 < m`! + 1 by rewrite addn1 ltnS fact_gt0.
exists p => //; rewrite ltnNge; apply: contraL p_dv_m1 => p_le_m.
by rewrite dvdn_addr ?dvdn_fact ?prime_gt0 // gtnNdvd ?prime_gt1.
Qed.
\end{coq}

Here the first line obtains a prime \C{p} as desired, the second
one begins to show it fits by contrapositive reasoning, and the
third one, already commented in section~\ref{sec:quantifiedst}, concludes.

As a general principle, in the proof script style we propose, a full
line should represent a meaningful reasoning step (for a human being).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Order and max, a matter of symmetry}\label{sec:leqmax}
\index[concept]{forward reasoning}
\index[concept]{symmetric argument}

It is quite widespread in paper proofs to appeal to the reader's intelligence
pointing out that a missing part of the proof can be obtained by symmetry.
The worst thing one can do when formalizing such an argument on a computer
is to use the worst invention of computer science: copy-paste.  The language of
\Coq{} is sufficiently expressive to model symmetries, and the
SSReflect proof language provides facilities to write symmetric arguments.

We prove the following characterization of the max of two natural numbers:
\[
\forall n_1, n_2, m, \quad m \le \max(n_1,n_2)
\Leftrightarrow m \le n_1 \textrm{ or } m \le n_2
\]

The proof goes as follows: Without loss of generality we can assume that
$n_2$ is greater or equal to $n_1$, hence $n_2$ is the maximum between
$n_1$ and $n_2$.  Under this assumption it is sufficient to check
that $m \le n_2$ holds iff either $m \le n_2$ or $m \le n_1$.
The only non-trivial case is when we suppose $m \le n_1$ and
we need to prove $m \le n_2$, which holds by transitivity.\hfill$\square$

As usual we model double implication as an equality between two
boolean expressions:

\begin{coq}{}{}
Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).
\end{coq}

The proof uses the following lemmas.  Pay attention to the premise of
\C{orb_idr}, which is an implication.

\begin{coq}{}{title=Tools}
Lemma orb_idr (a b : bool) : (b -> a) -> a || b = a.
Lemma maxn_idPl {m n} : reflect (maxn m n = m) (n <= m).
Lemma leq_total m n : (m <= n) || (n <= m).
\end{coq}

Our first attempt takes no advantage of the symmetry argument:
we reason by cases on the order relation,
we name the resulting fact on the same line
(it eases tracking where things come from) and we solve the two
goals independently.

\begin{coq}{}{}
Proof.
case/orP: (leq_total n2 n1) => [le_n21|le_n12].
  rewrite (maxn_idPl le_n21) orb_idr // => le_mn2.
  by apply: leq_trans le_mn2 le_n21.
rewrite maxnC orbC.
rewrite (maxn_idPl le_n12) orb_idr // => le_mn1.
by apply: leq_trans le_mn1 le_n12.
Qed.
\end{coq}

After line 2, the proof status is the following one:

\begin{coqout}{}{title=Output line 2}
2 subgoals
m, n1, n2 : nat
le_n21 : n2 <= n1
========================
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)

subgoal 2 is:
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)
\end{coqout}

The first goal is simplified by
rewriting with \C{maxn_idPl} (as we did in section~\ref{sec:viewtac}).
Then \C{orb_idr} trivializes the main goal and generates a side condition with
an extra hypothesis we name \C{le_mn2}.

\begin{coqout}{}{title=Output before line 3,width=6.7cm}
2 subgoals
m, n1, n2 : nat
le_n21 : n2 <= n1
========================
(m <= n1) = (m <= n1) || (m <= n2)

subgoal 2 is: ...
\end{coqout}
\begin{coqout}{}{title=Output after 3,width=5.3cm}
2 subgoals
m, n1, n2 : nat
le_n21 : n2 <= n1
le_mn2 : m <= n2
========================
m <= n1

subgoal 2 is: ...
\end{coqout}

Line 4 combines by transitivity the two hypotheses to conclude.  Since it closes the
proof branch we use the prefix \C{by} to asserts the goal is solved and
visually signal the end of the paragraph.  Line 5 commutes \C{max} and \C{||}.
We can then conclude by copy-paste.


To avoid copy-pasting, shrink the proof script and finally make the
symmetry step visible we can resort to the \C{have} tactic.
In this case the statement is a variation of what we need to prove.
Remark that as for \C{Lemma}, we can place parameters, \C{x} and \C{y}
here, before the \C{:} symbol.

\begin{coq}{}{}
Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).
Proof.
have th_sym x y: y <= x -> (m <= maxn x y) = (m <= x) || (m <= y).
  move=> le_yx; rewrite (maxn_idPl le_yx) orb_idr // => le_my.
  by apply: leq_trans le_my le_yx.
by case/orP: (leq_total n2 n1) => /th_sym; last rewrite maxnC orbC.
Qed.
\end{coq}

The proof for the \C{th_sym} sub proof is the text we copy-paste in the
previous script, while here it is factored out.
Once we have such extra fact in our context we reason by cases on
the order relation and we conclude.  Remark that the last line instantiates
\C{th_sym} \emph{in each branch} using the corresponding
hypothesis on \C{n1} and \C{n2} generated by the case analysis.
As expected the two instances are symmetric.

\begin{coqout}{}{}
2 subgoals
m, n1, n2 : nat
th_sym : forall x y : nat,
         y <= x -> (m <= maxn x y) = (m <= x) || (m <= y)
========================
(m <= maxn n1 n2) = (m <= n1) || (m <= n2) ->
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)

subgoal 2 is:
(m <= maxn n2 n1) = (m <= n2) || (m <= n1) ->
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)
\end{coqout}
This is exactly what is needed in the first branch of the case analysis.
The last subgoal just requires commuting \C{max} and \C{||}.

We can further improve the script.  For example we could rephrase
the proof putting in front the justification of the symmetry, and
then prove one case when we pick $x$ to be smaller than $y$.

\begin{coq}{}{}
Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).
Proof.
suff th_sym x y: y <= x -> (m <= maxn x y) = (m <= x) || (m <= y).
  by case/orP: (leq_total n2 n1) => /th_sym; last rewrite maxnC orbC.
move=> le_yx; rewrite (maxn_idPl le_yx) orb_idr // => le_my.
by apply: leq_trans le_my le_yx.
Qed.
\end{coq}
\index[ssr]{\C{suff} also \C{suffices}}
The \C{suff} tactic (or \C{suffices})
is like \C{have} but swaps the two goals.

Note that here the sub proof is now the shortest paragraph.
This is another recurrent characteristic of the proof script style
we adopt in the \mcbMC{} library.

There is still a good amount of repetition in the current script.
In particular the main conjecture has been almost copy-pasted in
order to invoke \C{have} or \C{suff}.  When this repetition
is a severe problem, i.e. the statement to copy is large, one
can resort to the \C{wlog} tactic (or \C{without loss}).

\begin{coq}{}{}
Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).
Proof.
wlog le_n21: n1 n2 / n2 <= n1  => [th_sym|].
  by case/orP: (leq_total n2 n1) => /th_sym; last rewrite maxnC orbC.
rewrite (maxn_idPl le_n21) orb_idr // => le_mn2.
by apply: leq_trans le_mn2 le_n21.
Qed.
\end{coq}
\index[ssr]{\C{wlog} also \C{without loss}}

Remark how \C{wlog} only needs the statement of the extra assumption,
and which portion of the context needs to be abstracted, here \C{n1} and
\C{n2}.  The sub goal to be proved is the following one.

\begin{coqout}{}{}
2 subgoals
m, n1, n2 : nat
th_sym : forall n1 n2 : nat, n2 <= n1 ->
           (m <= maxn n1 n2) = (m <= n1) || (m <= n2)
========================
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)


subgoal 2 is:
(m <= maxn n1 n2) = (m <= n1) || (m <= n2)
\end{coqout}

To keep the script similar to the previous one, we named explicitly
\C{th_sym}, to better link the final script to the previous attempts.
This is rarely the case in proof scripts of the library, since one typically
uses the \C{/(_ ...)} intro pattern to specialize the top of the stack.

Shrinking proof scripts is a never ending game.  The impatient reader can
jump to the next section to see
how intro patterns can be used to squeeze the last two lines into a
single one.  In the end, this proof script consists of three steps:
the remark that we can
assume \C{(n2 <= n1)} without losing generality; its justification in
terms of totality of the order relation and commutativity of \C{max}
and \C{||}; and the final proof, by transitivity, in the case when
the \C{max} is \C{n1} due to the extra assumption.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Partially applied views}

A less important, but very widespread, feature of the SSReflect
proof language can be used to shrink the proof even further.
In this proof script, we have named the fact \C{le_mn2} only for the
purpose of referring to this fact in the transitivity step.


\begin{coq}{}{}
Lemma leq_max m n1 n2 : (m <= maxn n1 n2) = (m <= n1) || (m <= n2).
Proof.
wlog le_n21: n1 n2 / n2 <= n1 => [th_sym|].
  by case/orP: (leq_total n2 n1) => /th_sym; last rewrite maxnC orbC.
by rewrite (maxn_idPl le_n21) orb_idr // => /leq_trans->.
Qed.
\end{coq}

Remember that the statement of
\C{leq_trans} is \C{(forall c a b, a <= c -> c <= b -> a <= b)} and
we have used it to transform the top assumption \C{(m <= n2)}.  Note that
the \C{leq_trans} expects a second proof argument, and that its type
would fix \C{b}, that is otherwise unspecified.  If one puts a
full stop just before the terminating \C{->}, to see the output of
the view application, one sees the following stack:

\begin{coq}{}{}
(forall n, n1 <= n -> m <= n) -> m <= n1.
\end{coq}

Rewriting the top assumption fixes \C{n} to \C{n1}, trivializes
the goal \C{(m <= n1)} to \C{true} and opens a trivial side
condition \C{(n2 <= n1)}.

The very compact idiom \C{/leq_trans->} is quite frequent in the
\mcbMC{} library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proof maintenance: a matter of style}

MC developed over 6 years by 10 people since 2016 (Coq 8.1) and maintained for, at the time of writing 12 years.

\subsection{Readability v.s. Compactness}

the first thing is to be able to read, some issues are UI related, some experience related, some approach related.
readability is given by fwd steps, what proves them could be automatic or cryptic code, you can skip it, at least at the beginning. If the lemma is 1 line, then it is its statement that matters.

still you may need to repair it, hence to read it.
hints for reading/writing the cryptic part: symbols/short names VS named
commands/meaningful steps.

rule of thumb: 1 line one step for the reader (it is up to you to make 1 step and not 20, it is up to ssr to let you write 1 line and not 20).

\subsection{Checkpoints}

fwd steps define blocks that typically confine error.
when you repair you start replaying from there.
idiom of \C{have {H}H : ty} to refine H.

\subsection{Fail early and locally}

this is the base semantics of tactic, there is no silent failure.
still on can weaken the behavior by using try or ? in rewrite (beware).
structuring the proof and using terminators such as by that assert the goal is solved avoid unsolved goals to silently reach the end of the proof without being noticed (where they come from?).

\subsection{Large proofs}

unfortunately splitting a large proof into small lemmas is a myth.
it takes great effort and sometimes it is not just possible since
the context is so large that one would inflate everything and obtain
unreadable, unreusable, unnameable lemmas.
using have and co give you similar syntax to the one of Lemma to
locally define these factoids.

clean up the context. some tactics do it automatically (case and apply).
the have {H}H idiom helps.

\subsection{Avoiding sources of randomness}
the intros business.
the super auto business.
decision procedures are good.
tactic language evolves conservatively, sitting on a reasonably well specified semantics.

