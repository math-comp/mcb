% Some \Coq{} snippets to be used later on
\begin{coqdef}{name=ssr}
Require Import Ssreflect.ssreflect.
From Ssreflect Require Import ssrfun ssrbool ssrnat eqtype seq.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=qed}
Qed.
\end{coqdef}
\begin{coqdef}{name=done}
by [].
\end{coqdef}
\begin{coqdef}{name=verbose}
Unset Silent.
\end{coqdef}
\begin{coqdef}{name=quiet}
Set Silent.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=show2}
Redirect "g2" Show.
\end{coqdef}

\Chapter{First Steps in Formal Proofs}{}
\label{ch:proofs}
% In this chapter we explain how to state a lemma,
% how to prove it, and how to search existing, loaded library.
% We focus here on simple proof commands, conventions and a first taste
% of boolean reflection. Views and the related tactics are postponed to the
% next chapter, and so are conjunctions and existential statements.

In this chapter, we explain how to use the \Coq{} system to state and
to prove theorems, focusing on simple statements and basic proof
commands. In the course of this book, we will see that choosing the
right way to state a proposition formally can be a rather delicate
matter. For equivalent wordings of a same propositions, some can be
much simpler to prove, and some can be more convenient to invoke
inside the proof of another corollary theorem. This chapter emphasizes
the use of computable definitions and equational reasoning
whenever possible, an approach that will be developed fully in
chapter~\ref{ch:boolrefl}.

\mcbLEARN{Stating basic theorems involving boolean statements,
  equalities, and arrows. Universal quantification is presented via
  parameters.}
\mcbREQUIRE{About, Check, implicit arguments, notations for the
  constants defined at chapter 1, principles of notations
  (associativity,...), definition of 'boolean predicate', sections}
\mcbPROVIDE{\C{Lemma},\C{Admitted}, eq, is-true, Lemma, \C{Prop}, \C{->}}
\mcbLEVEL{1}
%\mcbsection{First formal statements}
\mcbsection{Formal statements}


In this section, we illustrate how to state elementary candidate
theorems, starting with \emph{identities}.

\subsection{Ground equalities}\label{ssec:groundeq}
\index[concept]{proposition}
\index[concept]{equality}
\index[concept]{ground equality}

%\marginnote{We should have somewhere early a paragraph about the prelude.}
\Coq{} provides a binary predicate named \C{eq} and equipped with the
infix notation \C{=}. This predicate is used to write sentences
expressing that two objects are \emph{equal}, like in $2 + 2 = 4$.
Let us start with examples of \Coq{} \emph{ground} equality
statements: \emph{ground} means that these statements do not feature
parameter variables. For instance $2 + 2 = 4$ is a ground
statement, but $(a + b)^2 = a^2 + 2ab + b^2$ has two parameters $a$
and $b$: it is not ground.

The \C{Check} command can not only be used to verify the type
of some expression, but also check whether a formal statement
is well formed or not:

\begin{coq}{name=check-eq}{width=6cm}
Check 3 = 3.
Check false && true = true.
\end{coq}
\coqrun{name=r1}{ssr,check-eq}
\begin{coqout}{run=r1}{width=6cm}
3 = 3 : Prop
false || true = true : Prop
\end{coqout}

Let's anatomize the two above examples. Indeed, just like \Coq{}'s
type system prevents us from applying functions to
arguments of a wrong nature, it also enforces a certain nature of
well-formedness at the time we enunciate sentences that are candidate
theorems. Indeed, formal statements in \Coq{} are themselves
\emph{terms} and as such they have a \emph{type} and their subterms
obey type constraints. An
equality statement in particular is obtained by applying the constant
\C{eq} to two arguments, \emph{of the same type}. This application
results in a well-formed term of type \C{Prop}, for \emph{proposition}.

Throughout this book, we will
use the word \emph{proposition} for a term of type \C{Prop}, typically
something one wants to prove.
% Sometimes we say \emph{boolean proposition} to stress that the proposition
% is made by equating two boolean expressions, as in Line 2 above.

The \C{About} vernacular
command provides information on a constant, like its
type and the status of its argument. It applies just as well to
propositions and to the components thereof. For instance we can learn more
about the constant \C{eq}:

\begin{coq}{name=about}{width=6cm,title=The polymorphic equality predicate}
Locate "=".

About eq.
$~$
\end{coq}
\coqrun{name=abouteq}{about}
\begin{coqout}{run=abouteq}{title=Response,width=6cm}
"x = y" := (eq x y)

eq : forall A : Type, A -> A -> Prop
Argument A is implicit ...
\end{coqout}

The constant \C{eq} is a \emph{predicate}, i.e., a function letting
build a proposition. The equality
predicate is polymorphic: exactly as we have seen in the previous
chapter the \C{forall} quantifier is used to make the (implicit)
parameter \C{A} range over types. Both examples \C{3 = 3} and \C{false
&& true = false} thus use the \emph{same} equality constant, but with
a different value, respectively \C{nat} and \C{bool}, for the type
parameter. Since the first argument of \C{eq} is implicit, it is not
part of the infix notation and its value is not
provided by the user. This value can indeed be guessed from the type of the
hand-sides of the identity: \C{(3 = 3)} unfolds to \C{(eq _ 3 3)} and
the missing value is \C{nat}, the type of \C{3}. Similarly,
\C{(false && true = true)} unfolds to \C{(eq _ (false && true) true)}
and the missing value is \C{bool}, the common type of \C{true} and
\C{(false && true)}.

As the \Coq{} system checks the well-typedness of statements,
the two hand sides of a well-formed equality should have the same
type:

\begin{coq}{name=check-eq2}{width=4cm}
Check 3 = [:: 3].
$~$
\end{coq}
\coqrun{name=r2;fail}{ssr,check-eq2}
\begin{coqout}{run=r2}{width=8cm}
Error: The term "[:: 3]" has type "seq nat"
 while it is expected to have type "nat".
\end{coqout}
Yet it does not check the provability of the statement!

\begin{coq}{name=false-statement}{width=6cm}
Check 3 = 4.
\end{coq}
\coqrun{name=check34}{false-statement}
\begin{coqout}{run=check34}{width=6cm}
3 = 4 : Prop
\end{coqout}

In order to establish that a certain equality holds, the user should
first announce that she is going to prove a sentence, using a special
command like \C{Lemma}. This command has several variants \C{Theorem},
\C{Remark}, \C{Corollary},\dots which are all synonyms for what
matters here.
A \C{Lemma} keyword is followed by the name chosen for the lemma and
then by the statement itself. Command \C{Lemma} and its siblings are in fact
a variant of the \C{Definition} syntax we used in
chapter~\ref{ch:prog}: everything we mentioned about it also applies
here. The \C{Proof} command marks the beginning of the proof text,
which ends either with \C{Qed} and \C{Admitted}. After command
\C{Proof} is executed, the system displays the current state of the
formal proof in a dedicated window.
\index[vernac]{\C{Lemma}}
\index[vernac]{\C{Theorem}}

\begin{coqdef}{name=first-lemma}
Lemma my_first_lemma : 3 = 3.
Proof. Redirect "goal" Show.
\end{coqdef}
\begin{coq}{def=first-lemma}{width=6.5cm,title=Stating a lemma and starting its proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* your proof text *)
$~$
\end{coq}
\coqrun{name=r3}{ssr,first-lemma,abort}
\begin{coqout}{run=r3;out=goal}{title=Response after line 2: proof state,width=5.5cm}
1 subgoal

  ======================
   3 = 3
\end{coqout}

Indeed, \Coq{} is now in so-called \emph{proof mode}: we can execute
new commands to construct a proof and inspect the current state of a
proof in progress, but some other commands, like opening sections, are
no more available. At any stage of the proof construction, \Coq{}
displays the current state of the (sub)proof currently pending:  a
list of named hypotheses forms the current context and is printed
on top of the horizontal bar (empty here), and
the statement of the current goal (the conjecture to be proved) is
below the bar.

We will explain how to proceed with such a proof in
section~\ref{ssec:proofcomp}.
For now, let us then just admit this result, using the \C{Admitted}
command.
\index[vernac]{\C{Admitted}}

\begin{coq}{name=first-lemma-admitted}{}
Lemma my_first_lemma : 3 = 3.
Proof.
Admitted.
\end{coq}

Although we have not (yet) provided a proof for this lemma, a new
definition has been added to our environment:

\begin{coq}{name=about-first-lemma}{width=6cm}
About my_first_lemma.
\end{coq}
\coqrun{name=about}{ssr,first-lemma-admitted,about-first-lemma}
\begin{coqout}{run=about}{width=6cm}
my_first_lemma : 3 = 3
\end{coqout}


In the rest of the chapter, we will often omit the \C{Admitted} proof
terminator, and simply reproduce the statement of some lemmas in
order to discuss their formulation.

\subsection{Identities}\label{ssec:id}
\index[concept]{identity}

Ground equalities are just a very special case of mathematical
statements called \emph{identities}. An \emph{identity} is an equality
relation $A = B$, that holds regardless of the values that are
substituted for the variables in $A$ and $B$.
Let us state for instance the identity expressing the associativity of
the addition operation on natural numbers:

\begin{coq}{name=addnA}{}
Lemma addnA (m n k : nat) : m + (n + k) = m + n + k.
\end{coq}

Note that in the statement of \C{addnA}, the right hand side does not
feature any parentheses but should be read \C{((m + n) + k)}: this
associativity has been prescribed at the definition time of the infix
\C{+} notation, see section~\ref{sec:notabrev}. Command
\C{Lemma}, just like \C{Definition}, allows for
dropping the type annotations of parameters if these types can be
inferred from the statement itself:

\begin{coq}{name=addnA2}{}
Lemma addnA n m k : m + (n + k) = m + n + k.
\end{coq}

Boolean identities play a central role in the \mcbMC{} library. They
states equalities between boolean expressions with parameters. For
instance, the~\C{orbT} statement expresses that \C{true} is right absorbing
for the boolean disjunction operation \C{orb}. Recall from
section~\ref{ssec:boolval} that \C{orb} is equipped with the \C{||}
infix notation:

\begin{coq}{name=orbT}{}
Lemma orbT b : b || true = true.
\end{coq}

More precisely, lemma \C{orbT}
expresses that the truth table of the boolean formula \C{(b || true)}
coincides with the (constant) one of \C{true}: otherwise said that the
two propositional formulas are equivalent, or that \C{(b || true)} is a
propositional tautology. We provide below some other examples of such
propositional equivalences stated as boolean identities.

\begin{coq}{name=orbA}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
\end{coq}
Proving these identities is left as an exercise (see
exercise~\ref{ex:boolid}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{From boolean predicates to formal statements}
\label{sec:bstatements}

We call \emph{boolean predicate} a function to \C{bool}. A boolean
predicate can indeed be seen as an effective truth table, which can be
used to form a proposition in a systematic way by equating its result
to \C{true}. More generally boolean identities are equality statements
in type \C{bool}, which may involve arbitrary boolean predicates and boolean
connectives. They can obviously also feature variables of an arbitrary
type, and not only of type \C{bool}.

For instance the boolean comparison function
\C{(leq : nat -> nat -> bool)} is a boolean binary predicate on
natural numbers. Lemma \C{leq0n} is a proposition asserting that a
certain comparison always holds, by stating that the truth value of
the boolean \C{(0 <= n)} is \C{true}, whatever term  of type \C{nat}
is substituted for the parameter \C{n}.

\begin{coq}{name=leq0n}{title=Stating that a boolean predicate holds}
Lemma leq0n (n : nat) : 0 <= n = true.
\end{coq}

The \mcbMC{} library makes an extensive use of boolean predicates, and
of the associated propositions. For the sake of readability, the
default behavior of the  \mcbMC{} library is to omit the ``\C{.. = true}''
part in these boolean identities. \Coq{} is actually able to insert
automatically and silently this missing piece whenever it fits and
it is non-ambiguous, thanks to its \emph{coercion} mechanism. We
postpone further explanation of this mechanism to
section~\ref{sec:coercions} but from now on, we stop displaying the
\C{..= true} parts of the statement that are silently inserted this
way. For instance lemma \C{leq0n} is displayed as:

\begin{coq}{name=coercion}{}
Lemma leq0n (n : nat) : 0 <= n.
\end{coq}

As a general fact, boolean identities express that two boolean
statements are equivalent. We already encountered special cases of
such equivalence with propositional tautologies in
section~\ref{ssec:id}. Here are a few more examples involving
boolean predicates on natural numbers, that we have defined in
chapter~\ref{ch:prog}: the boolean equality \C{==} and its negation
\C{!=}, the order relation \C{<} and its large version \C{<=}, and the
divisibility predicate \L+%|+, with \L+(a %| b)+
meaning \C{a} \emph{divides} \C{b}.
Note that we omit the type of the parameters; they are all of type
\C{nat}, as enforced by the type of the operators involved in the
statements:

\begin{coq}{name=equivalences}{}
Lemma eqn_leq m n : (m == n) = (m <= n) && (n <= m).
Lemma neq_ltn m n : (m != n) = (m < n) || (n < m).
Lemma leqn0 n : (n <= 0) = (n == 0).
Lemma dvdn1 d : (d %| 1) = (d == 1)
Lemma odd_mul m n : odd (m * n) = odd m && odd n.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conditional statements}

In the previous sections, we have seen statements of unconditional
identities, either equalities between ground terms or identities that
hold for \emph{any} value of their parameters. A property that holds
only when some condition is verified by its parameters is stated using an
  \emph{implication} and the \Coq{} syntax for this connective
  is ``\C{->}''.  For instance:

\begin{coq}{name=implication}{title=Implication}
Lemma leq_pmull m n : n > 0 -> m <= n * m.
Lemma odd_gt0 n : odd n -> n > 0.
\end{coq}

This arrow \C{->} is the
same as the one we have used in chapter~\ref{ch:prog} in order to
represent function types. This is no accident, but we postpone further
comments on the meaning of this arrow to section~\ref{sec:chi}. For
now let us only stress that \C{->} associates on the right and that
a succession of arrows expresses a conjunction of conditions:

\begin{coq}{name=dvdn-mul}{}
Lemma dvdn_mul d1 d2 m1 m2 : d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
\end{coq}
Replacing conjunctions of hypotheses by a succession of implication is
akin to replacing a tuple of arguments by functions with a functional
type, as described in section~\ref{sec:fun-sev-args}.

% Yet beware, all the parameters are then fixed
% inside the section (as well as hypotheses but that's less often
% problematic). However we cannot really make sense from this remark as
% long as we do not explain formal proofs in more details...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEARN{Commands to build and check formal proofs: trivial ones,
  case analysis, rewriting}
\mcbREQUIRE{computation, equality}
\mcbPROVIDE{eq, is-true, \C{rewrite, case, by []}}
\mcbLEVEL{1}
\mcbsection{Formal proofs}
\index[concept]{formal proof}

We shall now explain how to turn a well-formed statement into a
machine-checked theorem. Let us come back to our first example, that
we left unproved:
\begin{coq}{name=my-first-proof1}{}
Lemma my_first_lemma : 3 = 3.
Proof.
Admitted.
\end{coq}
In the \Coq{} system, the user builds a formal proof by providing,
interactively, instructions to the \Coq{}
system that describe the gradual construction of the proof she has in
mind. This list of instructions is called a \emph{proof script}, and
the instructions it is made of are called proof commands, or more traditionally
\emph{tactics}.  The language of tactic we use is called
Ssreflect.

\begin{coq}{name=my-first-proof3}{title=Scheme of a complete proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* your finished proof script comes here *)
Qed.
\end{coq}

Once the proof is complete, we can replace the \C{Admitted} command by
the \C{Qed} one. This command calls the proof checker part of  the \Coq{}
system, which validates a posteriori that the formal proof that has
been built so far is actually a complete and correct proof of the
statement, here \C{3 = 3}.

In this section, we will review different nature of proof steps and
the corresponding tactics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Proofs by computation}\label{ssec:proofcomp}
\index[concept]{computation}

Here is now the proof script that validates the statement $3 = 3$.

\begin{coqdef}{name=my-first-proof4}
Lemma my_first_lemma : 3 = 3.
Proof.
\end{coqdef}
\begin{coq}{def=my-first-proof4,done}{width=7cm,title=Reflexivity of equality}
Lemma my_first_lemma : 3 = 3.
Proof. by [].
\end{coq}
\coqrun{name=firstp4}{ssr,my-first-proof4,verbose,done,abort}
\begin{coqout}{run=firstp4}{width=5cm,title=Proof finished}
No more subgoals.
$~$
\end{coqout}
\index[ssr]{\C{by []}}

Indeed, this statement holds trivially, because the two hand sides of
the equality are syntactically the same. The tactic ``\C{by []}'' is
the command that
implements this nature of \emph{trivial} proof step. The proof command
\C{by} typically prefixes another tactic (or a list thereof): it is
a \emph{tactical}. The \C{by} prefix checks that the following tactic
trivializes the goal. But in our case, no extra work is needed to
solve the goal, so we pass an empty list of tactic to the tactical
\C{by}, represented by the empty bracket \C{[]}.


The system then informs the user that the proof looks complete. We can hence
confidently conclude our first proof by the \C{Qed} command:

\begin{coq}{def=my-first-proof4,done,qed}{width=6cm}
Lemma my_first_lemma : 3 = 3.
Proof. by []. Qed.
About my_first_lemma.
\end{coq}
\coqrun{name=firstp5}{ssr,my-first-proof4,done,verbose,qed}
\begin{coqout}{run=firstp5}{width=6cm}
No more subgoals.
my_first_lemma is defined.
my_first_lemma : 3 = 3
\end{coqout}

Just like when it was \C{Admitted}, this script results in a new definition
being
added in our context, that can be reused in future proofs under
the name \C{my_first_lemma}.
Except that this time we have \emph{a machine checked proof} of
the statement of \C{my_first_lemma}.  By contrast
\C{Admitted} happily accepts false statements\dots
\index[concept]{machine checked proof}

What makes the \C{by []}  tactic interesting is that it
can be used not only when both
hand sides of an equality coincide syntactically, but also when they are
equal \emph{modulo the evaluation of programs} used in the formal
sentence to be proved.
For instance, let us prove that $2 + 1 = 3$.

\begin{coqdef}{name=secondp}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by [].
\end{coqdef}
\begin{coq}{def=secondp,qed}{}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by []. Qed.
\end{coq}
\coqrun{name=secondp}{ssr,secondp,verbose,qed}

Indeed, this statement holds because the two hand sides of the equality
are the same, once the definition of the \C{addn} function, hidden
behind the infix \C{+} notation, is unfolded, and that the calculation
is performed. In a similar way, we can prove the statement
\C{(0 <= 1)}, or \C{(odd 5)}, because both expressions \emph{compute} to
\C{true}.

As we have seen in chapter~\ref{ch:prog}, computation is not limited
to ground terms; it is really about using the rules of the pattern
matching describing the code of the function. For instance the proof
of the \C{addSn} identity:

\begin{coq}{name=addSn}{title=Reflexivity by symbolic computation}
Lemma addSn m n : m.+1 + n = (m + n).+1. Proof. by []. Qed.
\end{coq}
\index[coq]{\C{addSn}}
is trivial as well because it is a direct consequence of the
definition of the \C{addn} function: this function is defined by
pattern matching, with one of the branches stating exactly this
identity. Statements like
\C{(0 + n = n)} or \C{(0 < n.+1)} can be proved in a similar way, but
also \C{(2 + n = n.+2)}, which requires several steps of computation.

Last, the \C{by} tactical turns its argument into a \emph{terminating
tactic} --- and thus  \C{by []} is such a terminating tactic. A tactic
is terminating if as soon as it does not solve the goal completely, it
fails and stops \Coq{} from processing the proof script.
A terminating tactic is colored in red so that
the eye can immediately spot that a
proof, or more commonly a subproof, ends there.
\index[concept]{terminating tactic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Case analysis}\label{ssec:case}
\index[concept]{case analysis}
%assia : I do not remember why the \C macro does not work here, seems
%to be a problem with ~~...
Let us now consider the tautology~\L+~~ (~~ b) = b+. The
``proof by computation'' technique of section~\ref{ssec:proofcomp}
fails in this case:

\begin{coqdef}{name=negbK}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof.
\end{coqdef}
\begin{coq}{name=negbK,done}{width=7cm,title=Double negation elimination}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof. by [].
\end{coq}
\coqrun{name=negbKerr;fail}{ssr,negbK,done}
\begin{coqout}{run=negbKerr}{width=5cm, title=Failing proof script}
Error: No applicable
tactic.
\end{coqout}
\index[coq]{\C{negbK}}

Indeed, proving this identity requires more than a simple unfolding of
the definition of \C{negb}:

\begin{coq}{}{}
Definition negb (b : bool) : bool := if b then false else true.
\end{coq}
One also need to perform a \emph{case analysis} on the boolean value
of the parameter \C{b} and notice that the two hand-sides coincide in
both cases. The tactic \C{case} implements this action:

\begin{coqdef}{name=negbkt2}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
\end{coqdef}
\coqrun{name=negbkt2}{ssr,negbkt2,show1,done,show2,verbose,done,qed}
\begin{coq}{def=negbkt2}{width=6cm,title=Reasoning by cases}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
$~$
$~$
$~$
\end{coq}
\begin{coqout}{run=negbkt2;out=g1}{width=6cm, title=Case analysis}
2 subgoals

  ============================
   ~~ ~~ true = true
subgoal 2 is:
 ~~ ~~ false = false
\end{coqout}
\index[ssr]{\C{case: name}}

More precisely, the tactic ``\C{case: b}'' indicates that we want to
perform a case analysis on term \C{b}, whose
name follows the separator \C{:}. The \Coq{} system displays the state
of the proof after this command: the proof now has two subcases,
treated in two parallel branches, one in which the parameter \C{b}
takes the value \C{true} and one in which the parameter \C{b} takes
the value \C{false}. More generally, the \C{case: t} tactic performs a
case analysis on (the shape of) a term \C{t} which should be of an
inductive type. As any inhabitant of an inductive type is necessary
built from one of its constructor, this tactic creates as many
branches in the proof as the type has constructors, in the order in
which they appear in the definition of the type. In our example, the
branch for \C{true} comes first, because this constructor comes first
in the definition of type \C{bool}.

We shall thus provide two distinct pieces of
script, one per each subproof to be constructed,
starting with the branch associated with the \C{true} value. In order
to signal that we are starting a piece of script for a sub-proof, it
is a good practice to indent the corresponding script.

Once the case analysis has substituted a concrete value for the
parameter \C{b}, the proof becomes trivial, in both cases: we are in a
similar situation as in the proofs of section~\ref{ssec:proofcomp} and
the tactic \C{by []} applies successfully:

\begin{coq}{def=negbkt2,done}{width=6cm,title=First trivial case}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
\end{coq}
\begin{coqout}{run=negbkt2;out=g2}{width=6cm, title=Second goal}
1 subgoal

 ============================
   ~~ ~~ false = false
\end{coqout}

Once the first goal is solved we still have only one subgoal left and
we solve it using the same tactic.

\begin{coq}{def=negbkt2,done,done,qed}{width=6cm,title=Second trivial case}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
by [].
Qed.
\end{coq}
\begin{coqout}{run=negbkt2}{width=6cm, title=Finished proof}
No more subgoals.
negbK is defined
$~$
$~$
$~$
$~$
\end{coqout}

Yet as we mentioned earlier we can use the \C{by} tactical as a
prefix for any tactic, and have the system check that after the
\C{case} tactic, the proof actually becomes trivial, in both branches
of the case analysis. The proof script becomes this way a one-liner:

\begin{coq}{def=negbkt3,done,done,qed}{title=Double negation elimination: final script}
Lemma negbK b : ~~ (~~ b) = b.
Proof. by case: b. Qed.
\end{coq}

\subsubsection{Case analysis with naming}
\index[concept]{case analysis!naming}

The boolean equivalence \C{leqn0} is another example of statement that
cannot be proved by computation only:

\begin{coq}{def=leqn0,done}{width=7cm}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
\end{coq}
\begin{coqout}{def=leqn0,done}{width=5cm}
n : nat
=====================
  (n <= 0) = (n == 0)
\end{coqout}
\index[coq]{\C{leqn0}}

Both comparison operations \C{<=} and \C{==} are defined by case
analysis on their \emph{first} argument, independently of the shape of
the second. The proof of \C{leq0n} thus goes by case analysis on
 term \C{(n : nat)}, as it appears as a first argument to
both these comparison operators.  Remember that the inductive type \C{nat} is
defined as:

\begin{coq}{def=natdef}{}
Inductive nat := O | S (n : nat)
\end{coq}
with two constructors, \C{O} which has no argument and \C{S} which has
one (recursive) argument. A case analysis on term \C{(n : nat)} thus
has two branches: one in which \C{n} is \C{0} and one in which \C{n} is
\C{(S k)}, denoted \C{k.+1}, for some \C{(k : nat)}. We hence need a
variant of the \C{case} tactic, in order to \emph{name} the parameter
\C{k} that pops up in the second branch as the argument of the \C{S}
constructor of type \C{nat}:

\begin{coq}{def=leqn01,done}{width=7cm,title=case with naming}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
case: n => [|k].
$~$
$~$
\end{coq}
\begin{coqout}{run=leqn01}{width=5cm}
2 subgoals, subgoal 1

======================
  (0 <= 0) = (0 == 0)

subgoal 2 is:
 (k < 0) = (k.+1 == 0)
\end{coqout}
The tactic ``\C{case: n => [|k]}''  can be decomposed into two components,
separated by the arrow \C{=>}.  The left block ``\C{case: n}'' indicates
that we  perform a case analysis action, on term \C{(n : nat)}, while the right
block ``\C{[|k]}'' is an \emph{introduction pattern}. The brackets
surround slots separated by vertical pipes, and each slot allows to
name the parameters to be introduced in each subgoal created by the
case analysis, in order.

As type \C{nat} has two constructors, the introduction pattern \C{[|k]}
of our case analysis command uses two slots: the last one introduces
the name \C{k} in the second subgoal and the first one is
empty. Indeed, in the first subgoal, first branch of the case
analysis, \C{n} is substituted with \C{0}. In the second one, we can
observe that \C{n} has been substituted with \C{k.+1}.
As hinted in the first chapter, the term \C{(k.+1 <= 0)}
is displayed as \C{(k < 0)}.

The first goal
can be easily solved by computation, as both sides of the equality
evaluate to \C{true}.

\begin{coq}{def=leqn02,done}{width=7cm}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
  by [].
\end{coq}
\begin{coqout}{run=leqn02}{width=5cm}
k : nat
=========================
  (k < 0) = (k.+1 == 0)
\end{coqout}
\index[ssr]{\C{case: name => [$\mid$m]}}
The second and now only remaining goal corresponds to the case when
\C{n} is the successor of \C{k}. Note that \C{(k < 0)} is a
superseding notation for \C{(k.+1 <= 0)}, as mentioned in section
\ref{sec:notabrev}. This goal can also be  solved by computation, as
both sides of the equality evaluates to \C{false}.  The final
proof script is hence:

\begin{coq}{def=leqn04,done}{}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.  by case: n => [| k].  Qed.
\end{coq}
~\\

We will use a last example of boolean equivalence to introduce more
advanced proof techniques, leading to less verbose proof
scripts. Remember from chapter~\ref{ch:prog} that the product of two
natural numbers is defined as a function
\C{(muln : nat -> nat -> nat)}. From this definition, we prove that
the product of two (natural) numbers is zero if and only if one of the
numbers is zero:

\begin{coq}{def=almostMulnEq0}{title=Specifying muln: a double case analysis attempt}
Fixpoint muln (m n : nat) : nat :=
  if m is p.+1 then n + muln p n else 0.

Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
\end{coq}
\index[coq]{\C{muln_eq0}}
\index[coq]{\C{muln}}
In the case when \C{m} is zero, and whatever value \C{n} takes, both
hand sides of the equality evaluate to \C{true}: the left hand side is
equal modulo computation to \C{(0 == 0)}, which itself computes to
\C{true} and the right hand side is equal modulo computation to
\C{((0 == 0) || (n == 0))}, hence to \C{(true || (n == 0))} and finally to
\C{true} because the boolean disjunction \C{(_ || _)} is defined by
case analysis on its first argument.
%\marginnote{We did not show the definition of orb.}

\begin{coq}{def=almostMulnEq1}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
\end{coq}
\begin{coqout}{def=almostMulnEq1}{width=5cm,title=One goal left}
m, n : nat
=========================
(m.+1 * n == 0) =
  (m.+1 == 0) || (n == 0)
\end{coqout}
In this script, we used the name \C{m} for the argument of the
constructor in the second branch of the case analysis. There is no
ambiguity here and this proof step reads: either \C{m} is zero, or it
is of the form \C{m.+1}.

By default, the successor case is treated in the second subgoal,
according to the order of constructors in the definition of type
\C{nat}. If we want to treat it first, we can use the ``\C{; last
  first}'' tactic suffix:
\index[ssr]{\C{last first}}\index[concept]{reordering goals}

\begin{coq}{def=almostMulnEq2}{}
Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
\end{coq}
\begin{coqout}{def=almostMulnEq2}{title=Two goals left (in reverse order)}
2 subgoals, subgoal 1

m, n : nat
============================
(m.+1 * k.+1 == 0) = (m.+1 == 0) || (k.+1 == 0)

subgoal 2 is:
 (m.+1 * 0 == 0) = (m.+1 == 0) || (0 == 0)
\end{coqout}
Indeed it is a good practice to get rid of the easiest subgoals as
early as possible. And here the successor case is such an easy
subgoal: when \C{n} is of the form \C{k.+1}, it is easy to see that the
right hand side of the equality evaluates to \C{false}, as both
arguments of the boolean disjunction do. Now the left hand side
evaluates to \C{false} too: by the definition of \C{muln}, the term
\C{(m.+1 * k.+1)} evaluates to \C{(k.+1 + (m * k.+1))} and by
definition of the addition \C{addn}, this in turn reduces to
\C{(k + (m * k.+1)).+1}. The left hand side term hence is of the form
\C{t.+1 == 0}, where \C{t} stands for \C{(k + (m * k.+1))}, and this
reduces to false.\label{proof:mulneq0}
In consequence, the successor branch of the case analysis is trivial
by computation.


\begin{coq}{def=almostMulnEq3}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
  by [].
\end{coq}
\begin{coqout}{def=almostMulnEq3}{width=5cm}
1 subgoal

m : nat
=========================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
%\marginnote{We should make the remark somewhere explicitly that reflexivity for 0 or successor or any closed values is by computation but not reflexivity for a variable.}

This proof script can actually be made more compact and, more
importantly, more linear by using extra features of the introduction
patterns. It is indeed possible, although optional, to
inspect the subgoals created by a case analysis and to solve the
trivial ones on the fly, as the \C{by []} tactic would do, except that
in this case no failure happens in the case some, or even all,
subgoals remain. For instance in our case,
we can add the optional \C{//} \emph{simplify} switch to the
introduction pattern of the first case analysis:

\begin{coq}{def=almostMulnEq3}{title=A simplify intro pattern,width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
\end{coq}
\begin{coqout}{def=almostMulnEq11}{title=Proof state,width=5cm}
m, n : nat
=========================
(m.+1 * n == 0) =
  (m.+1 == 0) || (n == 0)
\end{coqout}

Only the first generated subgoal is trivial: it has been closed and
we are left with the second one. Similarly, we can get rid of the
second goal produced by the case analysis on \C{n}:

\begin{coq}{def=almostMulnEq31}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{def=almostMulnEq3}{width=5cm}
m : nat
=========================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}

% We will see in section~\ref{} that
This \C{//} switch can be used in
more general contexts than just this special case of introduction patterns:
it can actually punctuate more complex combinations of tactics,
avoiding spurious branching in proofs in a similar
manner~\cite[section 5.4]{ssrman}.

The last remaining goal cannot be solved by computation.
The right hand side evaluates to
\C{true}, as the left argument of the disjunction is \C{false} (modulo
computation) and the right one is \C{true}. However we need
more than symbolic computation to show that the left hand side is
\C{true} as well: the fact that \C{0} is a right absorbing element for
multiplication indeed requires reasoning by \emph{induction} on the
code of the multiplication (see section~\ref{ssec:ind}).

To conclude the proof we need one more proof command, the
\C{rewrite} tactic, that lets us appeal to an already existing lemma.

% section~\ref{ssec:rw} explains how to complete this proof.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rewriting}\label{ssec:rw}

This section explains how to perform local replacements of certain
subterms of a goal with other terms during the course of a formal
proof. In other words, we explain how to perform a
\emph{rewrite} proof step, thanks to the eponym \C{rewrite} tactic.
Such a replacement is licit when the original subterm is equal
to the final one, up to computation or because of a proved
identity. The \C{rewrite} tactic comes with several options for
an accurate specification of the operation to be performed.

Let us start with a simple example and come back to the proof that we
left unfinished at the end of the previous section:

\begin{coq}{def=almostMulnEq3}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{def=almostMulnEq3}{width=5cm}
m : nat
=======================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
At this stage, if we replace subterm \C{(m.+1 * 0)} by \C{0}, the
subgoal becomes:

\begin{coqout}{}{}
(0 == 0) = (m.+1 == 0) || (0 == 0)
\end{coqout}
which is equal modulo computation to \C{(true = true)}, hence trivial.
But because of
the definition of \C{muln} by pattern matching on its \emph{first}
argument, \C{(m.+1 * 0)} does not evaluate symbolically to \C{0}: this
equality holds but requires a proof by induction, as explained in
section~\ref{ssec:ind}.
The \mcbMC{} library nonetheless provides a systematic review of the
properties of the operations it defines. The lemma we need is
available in the library as:

\begin{coq}{def=muln0}{}
Lemma muln0 n : n * 0 = 0.
\end{coq}
%\marginnote{But this is not the way lemma \C{muln0} is stated in the library...}

As a side remark, being able to find the ``right'' lemma is of
paramount importance for writing modular libraries of formal
proofs. See section~\ref{sec:search} which is dedicated to this topic.

Back to our example, we use the \C{rewrite} tactic with lemma
\C{muln0}, in order to perform the desired replacement.

\begin{coq}{def=almostMulnEq4}{title=First rewrite,width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
rewrite muln0.
\end{coq}
\begin{coqout}{def=almostMulnEq4}{title=Proof state,width=5cm}
m : nat
=======================
(0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}}

The \C{rewrite} tactic uses the \C{muln0} lemma in the following way:
it replaces an instance of the left hand side of this identity with the
corresponding instance of the right hand side. The left hand side of
\C{muln0} can be read as a \emph{pattern} \C{(_ * 0)}, where \C{_}
denotes a wild-card: the identity is
valid for any value of its parameter \C{n}. The tactic
automatically  finds  where in the goal the replacement should take
place, by searching for a subterm matching the pattern \C{(_ * 0)}.
In the present case, there is only one such subterm,
\C{(m.+1 * 0)}, for which the parameter (or the wild-card) takes the
value \C{m.+1}. This subterm is hence replaced by \C{0}, the right
hand side of \C{muln0}, which does not depend on the value of the
pattern. We can now conclude the proof script, using the
prenex \C{by} tactical:
\index[concept]{pattern}
\index[concept]{rewriting}

\begin{coq}{def=almostMulnEq5}{}
Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
by rewrite muln0.
Qed.
\end{coq}

Arguments to the \C{rewrite} tactic are typically called
\emph{rewrite rules}\index[concept]{rewrite rule} and can
be prefixed by flags tuning the behavior of the tactic.

% Patterns are more generally useful both for subterm selection (in
% proof mode) and for searching existing results in the current context.
% This is the purpose of the \C{Search} command, which can for instance
% be used to (FIND AN EXAMPLE WHICH IS NOT muln0...)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsubsection{Rewriting many identities in one go}
\label{sec:multirew}

The boolean identity \C{muln_eq0} that we just established expresses a
logical equivalence that can in turn be used in proofs via the
\C{rewrite} tactic. For instance, let us consider the case of lemma
\C{leq_mul2l}, which provides a necessary and sufficient condition
for the comparison \C{(m * n1 <= m * n2)} to hold:

\begin{coq}{def=LeqMul2l}{title=Another example: ordered products}
Lemma leq_mul2l m n1 n2 : (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
\end{coq}

The proof goes as follows: the left
hand side can equivalently be written as \C{(m * n1 - m * n2 == 0)}, which
factors into \C{(m * (n1 - n2) == 0)}. But this is equivalent to one
of the arguments of the product being zero. And \C{(n1 - n2 == 0)}
means \C{(n1 <= n2)}.

The first step is performed using the following equation:

\begin{coq}{def=LeqDef}{}
Lemma leqE m n : (m <= n) = (m - n == 0).
Proof. by []. Qed.
\end{coq}
The proof of this identity is trivial, as the right hand side is the
definition of the \C{leq} relation, denoted by the \C{<=} infix
notation. Rewriting with this equation turns the left hand side of our
goal into a subtraction:

\begin{coq}{def=LeqMul2lproof1}{title=Unfolding leq,width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite leqE.
\end{coq}
\begin{coqout}{def=LeqMul2lproof1}{title=Proof state,width=5.5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 <= n2)
\end{coqout}

The command \C{rewrite leqE} only affects the first
occurrence of \C{<=} and we would like to substitute both. In order to
rewrite \emph{all} the possible instances of the rule in the goal, we
may use a repetition flag:

\begin{coq}{def=LeqMul2lproof1}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE.
\end{coq}
\begin{coqout}{def=LeqMul2lproof1}{width=5.5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}! "! (iteration)}

Now the definition of \C{<=} has been exposed
\emph{everywhere} in the goal, i.e., at both its occurrences in the
initial goal. We can now factor \C{m} on the left, according to the
appropriate distributivity property:

\begin{coq}{def=mulnBr}{}
Lemma mulnBr n m p : n * (m - p) = n * m - n * p.
\end{coq}

This time we need to perform a right-to-left rewriting of the
\C{mulnBr} lemma (instead of the
default left-to-right). The rewriting step first finds in the goal an
instance of pattern \C{(_ * _ - _ * _)}, where the terms matched by
the first and the third wild-cards coincide. The syntax for
right-to-left rewriting consists in prefixing the
name of the rewrite rule
with a minus \C{-}:


\begin{coq}{def=LeqMul2lproof2}{title=Rewrite right-to-left,width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE. rewrite -mulnBr.
\end{coq}
\begin{coqout}{def=LeqMul2lproof2}{title=Proof state,width=5.5cm}
m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-} (right-to-left)}
Consecutive rewrite steps can be chained as follows:

\begin{coq}{def=LeqMul2lproof2}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE -mulnBr.
\end{coq}
\begin{coqout}{def=LeqMul2lproof2}{width=5.5cm}
m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-} (right-to-left)}
The last step of the proof uses lemma \C{muln_eq0} to align the left
and the right hand sides of the identity.

\begin{coq}{def=LeqMul2lproof3}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE -mulnBr muln_eq0.
\end{coq}
\begin{coqout}{def=LeqMul2lproof3}{width=5.5cm}
m, n1, n2 : nat
==========================
(m == 0) || (n1 - n2 == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}

The proof can now be completed by prefixing the tactic with the
\C{by} command, which concludes the proof.

We only provided here some hints on the basic features of the \C{rewrite}
tactic. Section~\ref{sec:rewrite2} gives more details on the matching
algorithm and on the flags supported by \C{rewrite} and the complete
description of the features of this tactic is in the manual~\cite{ssrman}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{More complex statements and proofs}
\mcbLEVEL{1}
\mcbsection{Quantifiers}

\subsection{Universal quantification, first examples}

Let us put side by side an example of function we defined in
chapter~\ref{ch:prog}:

\begin{coq}{def=LeqDef}{}
Definition leq n m := m - n == 0.
\end{coq}
with an example of parametric statement we have used in the present
chapter:

\begin{coq}{def=leqn0}{}
Lemma leqn0 n : (n <= 0) = (n == 0).
\end{coq}

We recall, as seen in chapter~\ref{ch:prog}, that this concise syntax
for defining \C{leq} stands for:

\begin{coq}{def=LeqDefFun}{}
Definition leq := fun (n m : nat) => m - n == 0.
\end{coq}
and that the type of the constant \C{leq} is:

\begin{coq}{name=about-leq}{width=6cm}
About leq.
\end{coq}
\coqrun{name=about}{ssr,about-leq,about-leq}
\begin{coqout}{run=about}{width=6cm}
leq : nat -> nat -> bool
\end{coqout}

The curious reader might already have tested the answer of the
\C{About} command on some parametric lemmas:

\begin{coq}{def=negbktAbout}{width=5cm,title=Inspecting lemma leqn0}
About leqn0.
\end{coq}
\begin{coqout}{run=negbktAbout,ssr}{width=7cm, title=Universal quantification}
leqn0 : forall n : nat, (n <= 0) = (n == 0)
\end{coqout}

She has thus observed that \Coq{}'s output features a prenex
\C{forall} quantifier. This universal quantifier binds a natural number, and
expresses --as expected-- that the equation holds for \emph{any}
natural number. In fact, the type of the lemmas and theorems with
parameters all feature prenex universal quantifiers:

\begin{coq}{}{width=4cm}
About muln_eq0.
$~$
\end{coq}
\begin{coqout}{}{width=8cm}
muln_eq0 : forall m n : nat,
  (m * n == 0) = (m == 0) || (n == 0)
\end{coqout}
Quantifiers may also occur elsewhere in a statement, and not only in
prenex position.  In the following example, we use the function
\C{nth}, extracting the element of a sequence at a position, which was
the object of exercise~\ref{ex:nth}. This statement expresses that two
sequences with the same size and whose $n$-th elements coincide for any
$n$ are the same. The second hypothesis, about the elements, is
itself a quantified formula:

\begin{coq}{}{}
Lemma seq_eq_ext (s1 s2 : seq nat) :
  size s1 = size s2 ->
  (forall i : nat, nth 0 s1 i = nth 0 s2 i) ->
  s1 = s2.
\end{coq}
Quantifiers are also allowed to range over functions:

\begin{coq}{}{}
Lemma size_map (T1 T2 : Type) :
  forall (f : T1 -> T2) (s : seq T1), size (map f s) = size s.
\end{coq}
Observe that in the above statement of \C{size_map}, we have used a
compact notation for successive universal quantifications:
``\C{forall (f : T1 -> T2) (s : seq T1), ...}'' is syntactic sugar for
``\C{forall f : T1 -> T2, forall s : seq T1, ...}''. However in this case
of prenex quantification, we would rather write:

\begin{coq}{}{}
Lemma size_map (T1 T2 : Type) (f : T1 -> T2) (s : seq T1) :
  size (map f s) = size s.
\end{coq}
\index[coq]{\C{size_map}}
as all quantifiers are in prenex positions.

Quantifiers may also occur in the body of definitions, which is
useful to define predicates expressing standard properties on
objects. For instance the commutativity property of a binary operator
is defined as:

\begin{coq}{}{}
Definition commutative (T : Type) (op : T -> T -> T) :=
  forall x y, op x y = op y x.
\end{coq}
\index[coq]{\C{commutative}}
and the lemma stating the commutativity of the \C{addn} operation is
in fact:

\begin{coq}{}{}
Lemma addnC : commutative addn.
\end{coq}
The \mcbMC{} library defines several such predicates, which are used
as molds in order to state standard properties in a consistent and
compact way. We provide below a few examples:

\begin{coq}{}{}
Section StandardPredicates.
Variable T : Type.
Implicit Types (op add : T -> T -> T) (R : rel T).
Definition associative op := forall x y z, op x (op y z) = op (op x y) z.
Definition left_distributive op add :=
  forall x y z, op (add x y) z = add (op x z) (op y z).
Definition left_id e op := forall x, op e x = x.
End StandardPredicates.
\end{coq}
\index[coq]{\C{associative}}
\index[coq]{\C{left_id}}
\index[coq]{\C{left_distributive}}
\index[coq]{\C{rel}}
where \C{(rel T)} is an abbreviation for the type \C{(T -> T -> bool)}.

Beside the standardization of the statements through these
predicates, the \mcbMC{} library uses a systematic naming policy for the lemmas
that are instances of these predicates. A common suffix \C{C} is
used for commutativity properties like \C{addnC} or \C{mulnC}.
Such naming convention is also useful to search the library, as detailed
in section~\ref{sec:search}.

Another class of predicates typically features quantifiers in its
definition, which describes usual properties of functions:

\begin{coq}{}{}
Section MoreStandardPredicates.
Variables rT aT : Type.
Implicit Types (f : aT -> rT).
Definition injective f := forall x1 x2, f x1 = f x2 -> x1 = x2.
Definition cancel f g := forall x, g (f x) = x.
Definition pcancel f g := forall x, g (f x) = Some x.
End MoreStandardPredicates.
\end{coq}
\index[coq]{\C{injective}}
\index[coq]{\C{cancel}}
\index[coq]{\C{pcancel}}
The type of these predicates deserves a few comments:

\begin{coq}{}{width=3.8cm}
About commutative.
\end{coq}
\begin{coqout}{}{width=8.2cm}
commutative : forall T : Type, (T -> T -> T) -> Prop.
\end{coqout}
The constant \C{commutative} has a polymorphic parameter \C{T},
takes a binary operation as argument and builds a
\emph{proposition}. It is hence a polymorphic unary predicate on
a certain class of functions, the binary functions with both their
arguments and their result having the same type. Just like the
polymorphic binary predicate \C{eq}, the predicate \C{commutative} can
be used to form propositions:

\begin{coq}{}{width=6cm}
Check 3 = 3.
Check (commutative addn).
\end{coq}
\begin{coqout}{}{width=6cm}
3 = 3 : Prop
commutative addn : Prop
\end{coqout}
% Indeed, the class of propositions is closed under universal
% quantification \C{ forall} (and also under implication \C{->}).


\subsection{Organizing proofs with sections}

The \C{Section} mechanism presented in Section~\ref{sec:section} can
be used to factor not only the parameters but also the hypotheses of a
corpus of definitions and properties. For instance, the proof of the
Chinese remainder theorem is stated within such a section. It uses a
self-explanatory notation for congruences:

\begin{coq}{}{}
Section Chinese.

Variables m1 m2 : nat.
Hypothesis co_m12 : coprime m1 m2.

...

Lemma chinese_remainder x y :
  (x == y %[mod m1 * m2]) = (x == y %[mod m1]) && (x == y %[mod m2]).
Proof.
...
End.

End Chinese.
\end{coq}
corresponds to a mathematical sentence of the form: \emph{In this section,
  $m_1$ and $m_2$ are two coprime natural numbers\dots}. Within the
scope of a section the parameters like, \C{k1} and \C{k2}, are
fixed. Outside the scope of the section, here after the
\C{End Chinese} command, these variables and the hypotheses are
\emph{generalized}, so that the statement of the \C{chinese_remainder} is:

\begin{coq}{}{}
Lemma chinese_remainder m1 m2 (co_m12 : coprime m1 m2) x y :
  (x == y %[mod m1 * m2]) = (x == y %[mod m1]) && (x == y %[mod m2]).
\end{coq}

Outside the scope of the section, the type of constants and the
statement of lemmas only depend on the section variables and
hypotheses that are actually used in their definition or proof.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using lemmas in proofs}
\label{sec:quantifiedst}

In order to use a known lemma, one should provide the values of its
parameters which provide the instance relevant to the current
proof. Fortunately, the proof assistant can assist its user in
describing these values and the \C{apply:} tactic, like the
\C{rewrite} one in section~\ref{sec:rewrite}, finds the appropriate
instance by comparison to the current goal:

\begin{coq}{}{}
Lemma leqnn n : n <= n. Proof. Admitted.

Lemma example a b : a + b <= a + b.
Proof. apply: leqnn. Qed.
\end{coq}
\index[ssr]{\C{apply:}}
The look up performed by \C{apply} tactic works up to computation:

\begin{coq}{}{}
Lemma example a b : a.+1 + b <= (a + b).+1.
Proof. apply: leqnn. Qed.
\end{coq}
In order to save the effort of mentioning too trivial
steps in the proof script, we can extend the power of the \C{by}
terminator to make it aware of some lemmas available in
the library. The \C{Hint Resolve} command is used to tag these lemmas,
as in:
\index[vernac]{\C{Hint Resolve}}
\index[concept]{improving \C{by []}}

\begin{coq}{}{}
(* This line belongs to the file where the lemma is stated and proved.*)
Hint Resolve leqnn.
Lemma example a b : a + b <= a + b.
Proof.  by [].  Qed.
\end{coq}
Observe that the goal is now closed without a mention of \C{leqnn},
although it has been used by the system to conclude the proof.

In order to illustrate more proof techniques related to the use of
lemmas inside proofs, let us scrutinize a formal proof that a prime
number which divides $m! + 1$ for a certain integer $m$ has to be
greater than $m$. This lemma is a key step in a proof that there are
infinitely many primes which will be studied in
section~\ref{sec:infprimes}. The proof of the lemma goes by
contraposition: if $p$ is a prime number smaller that $m$, then it
divides $m!$ and thus it cannot divide $m! + 1$ as it does not divide
$1$. We first state this lemma as follows:

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
\end{coq}
where \L+p %| m!+ stands for \C{p} \emph{divides the factorial of} \C{m}.
The first step of our formal proof will be to give a name to the
hypothesis \C{(prime p)}, which means that we add it to the
current context of the goal. The dedicated tactic for this naming step is
\C{move=>} followed by the name given to the hypothesis, because the
hypotheses \emph{moves} from under the bar to above:

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
====================
p %| m `! + 1 -> m < p
\end{coqout}
The second step of the proof is to transform the current goal into its
contrapositive.

\begin{coq}{}{}
Lemma contraLR (c b : bool) :  (~~ c -> ~~ b) -> (b -> c).
\end{coq}
\index[coq]{\C{contraLR}}

which describes the shape of the contrapositive of statements and thus
describes a family of
instances of the contraposition law. The \C{apply: contraLR} tactic
finds the appropriate values of the premise and conclusion and
instantiate the scheme, leaving us to prove that \C{p} is not a
divisor of \D{(m `! + 1)} under the assumption that \C{p} is not
greater than \C{m}:

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
====================
 ~~ (m < p) -> ~~ (p %| m `! + 1)
\end{coqout}

More precisely, the values chosen by the tactic for the two parameters
\C{c, b} of lemma \C{contraLR} are \C{(m < p)} and
\D{(p \%| m `! + 1)}. They have been found by comparing the statement to be
proved with the conclusion \C{(b -> c)} of the statement of the lemma.
The new statement of the goal is the corresponding instance of the
premise \C{(~~ c -> ~~ b)} of lemma \C{contraLR}.

The next step in our formal proof is to improve the shape of the
hypothesis \C{\~\~ (m < p)} and to give it a name.


\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
rewrite -leqNgt.
move=> leq_p_m.
\end{coq}
\begin{coqout}{}{width=6cm}
m, p : nat
prime_p : prime p
leq_p_m :  p <= m
====================
 ~~ (p %| m `! + 1)
\end{coqout}
And the next step uses the following lemma:

\begin{coq}{}{}
Lemma dvdn_addr m d n : d %| m -> (d %| m + n) = (d %| n).
\end{coq}
This is a conditional equivalence, expressed as a conditional identity.
We can replace our current goal with \C{\~\~ (p \%| 1)} by rewriting (the
appropriate instance of) this identity.  This operation will open an
extra goal requiring a proof of (the corresponding instance of) the side
condition.

\begin{coq}{}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraL.
move=> leq_p_m.
rewrite dvdn_addr.
\end{coq}
\begin{coqout}{}{width=6cm}
2 subgoals

  m, p : nat
  pr_p : prime p
  p_le_m : p <= m
  ============================
   ~~ (p %| 1)

subgoal 2 is:
 p %| m`!
\end{coqout}
Observe the second goal at the bottom of the buffer which displays the
statement of the side condition to be proved later. The context of
this subgoal is omitted but we do not really need to see it:
we know that statement \C{p \%| m!} holds because \C{p <= m} and
because we can combine  the following lemmas:

\begin{coq}{}{}
Lemma dvdn_fact m n : 0 < m -> m <= n -> m %| n`!.
Lemma prime_gt1 p : prime p -> 1 < p.
\end{coq}

The first goal is also easy to solve, using the following basic facts:

\begin{coq}{}{}
Lemma gtnNdvd n d : 0 < n -> n < d -> (d %| n) = false.
Lemma prime_gt0 p : prime p -> 0 < p.
\end{coq}
Finally, the resulting script would be:

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p.
apply: contraLR.
rewrite -leqNgt.
move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd.
    by [].  (* ~~ false *)
    by [].  (* 0 < 1 *)
  by apply: prime_gt1.  (* 1 < p *)
apply: dvdn_fact.
  by apply: prime_gt0. (* 0 < p *)
by []. (* p <= m *)
Qed.
\end{coq}
For brevity we report in comments the goals solved by tactics.

We improve such script in two steps.  First, we take advantage of
\C{rewrite} simplification flags.  It is quite common
for an equation to be conditional, hence for \C{rewrite} to generate side
conditions.  We have already suggested that a good practice consists
in solving the easy side conditions
as soon as possible.  Here the first two side conditions are indeed
trivial, and, as for the introduction patterns of the \C{case} tactic,
we can use a simplification switch \C{//} to solve them.
We also combine on the same line the first three step, using
the semicolon.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd //.
  by apply: prime_gt1.  (* 1 < p *)
\end{coq}
\index[ssr]{\C{rewrite}!\C{//} (close trivial goals)}
A careful comparison of the conclusions of \C{gtnNdvd}
and \C{prime_gt1} reveals that they are both rewriting rules.  While
the former features an explicit ``\C{.. = false}'', in the
latter one the ``\C{.. = true}'' part is hidden, but is there.
This means
both lemmas can be used as identities.

\mantra{All boolean statements can be rewritten as if they
were regular identities.  The result is that the matched
term is replaced with \C{true}.}

Rewriting with
\C{prime_gt1} leaves open the trivial goal \C{true} (i.e., \C{(true = true)}),
and the side condition \C{(prime p)}.  Both are trivial, hence
solved prefixing the line with \C{by}.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
\end{coq}
The same considerations hold for the last goal.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
by rewrite dvdn_fact // prime_gt0.
Qed.
\end{coq}

To sum up, both \C{apply:} and \C{rewrite} are able to find the right
instance of a quantified lemma and to generate sub goals
for its eventual premises.  Hypotheses can be named using \C{move=>}.
The proof script can be further reduced in size, as we describe in
section~\ref{sec:rewrite2}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Proofs by induction}\label{ssec:ind}
\index[concept]{induction}

Let us take the well known induction principle for Peano's natural numbers
and let us formalize it in the language of \Coq{}.  It reads:
let $\mathcal{P}$ be a property of natural numbers, if
$\mathcal{P}$ holds on $0$ and, if for all natural number $n$
$\mathcal{P}$ hold on $n + 1$ as soon as it holds on $n$, then $\mathcal{P}$
holds for any $n$.  Induction is typically regarded as a schema, where
the variable $\mathcal{P}$ stands for any property we could think about.

In the language of \Coq{}, it is possible to use a quantification to
bind the parameter  $\mathcal{P}$ in the scheme, akin to the universal
quantification of polymorphic parameters in data types like
\C{seq}. Induction principles, instead of being ``schemas'', are
regular lemmas with a prenex quantification on predicates:

\begin{coq}{}{width=3.2cm}
About nat_ind.
\end{coq}
\begin{coqout}{}{width=8.9cm}
nat_ind : forall P : nat -> Prop,
  P 0 -> (forall n : nat, P n -> P n.+1) -> forall n : nat, P n
\end{coqout}
Here \C{P} is quantified exactly as \C{n} is, but its type is a bit more
complex and deserves an explanation.  As we have seen in the first
chapter, the \C{->} denotes the type of functions; hence \C{P} is a
function from \C{nat} to \C{Prop}.  Recall that \C{Prop} is the type
of \emph{propositions}, i.e., something we may want to prove.  At the
light of that, \C{P} is a function producing a proposition out of a natural
number.  For example the property of being an odd prime can be written as
follows:

\begin{coq}{}{}
(fun n : nat => (odd n && prime n) = true)
\end{coq}
Indeed, if we take such function as the value for \C{P}, the first premise
of \C{nat_ind} becomes

\begin{coqout}{}{width=6.5cm,title=P 0}
(fun n : nat => (odd n && prime n) = true) 0
\end{coqout}
\begin{coqout}{}{width=5.5cm,title=Equivalent by computation}
odd 0 && prime 0 = true
\end{coqout}
\index[concept]{general term}
\index[concept]{higher-order}
Remark the similarity between the function argument to \C{foldr}
that is used describe the general term of an iterated sum in
section~\ref{sec:bigopnat} and the predicate \C{P} here used
to describe a general property.

\Coq{} defines an induction principle for every inductive type the
user defines, with standard names formed by adding a suffix \C{_ind}
to the name of the type. The statement of a generated induction principle
is shaped
by the structure of the definition of the inductive type. Here is for
instance the induction principle for sequences, which has some
similarities with the one for natural numbers:

\begin{coq}{}{width=3.3cm}
About list_ind.
\end{coq}
\begin{coqout}{}{width=8.8cm}
list_ind : forall A : Type, forall P : list A -> Prop,
  P [::] -> (forall x s, P s -> P (x :: s)) -> forall s, P s.
\end{coqout}

To sum up reasoning by induction on a term \C{t} means
finding the induction lemma associated to the type of \C{t}
\emph{and} synthesizing
the right predicate \C{P}.  The \C{elim:} tactic has these two
functionalities --while \C{apply:} does not. The induction principle
to be used is guessed from the type of the argument of the tactic. Let
us illustrate on an example how the value of the parameter \C{P} is
guessed by the \C{elim:} tactic and let us prove by induction on \C{m}
that \C{0} is neutral on the right of \C{addn}.
\index[ssr]{\C{elim: name => [$\mid$m IHm]}}

\begin{coq}{}{width=6cm}
Lemma addn0 m : m + 0 = m.
Proof.
elim: m => [ // |m IHm].
\end{coq}
\begin{coqout}{}{width=6cm}
m : nat
IHm : m + 0 = m
=======================
m.+1 + 0 = m.+1
\end{coqout}
The \C{elim:} tactic is used here with an introduction pattern similar
to the one we used for \C{case:}. It has two slots, because of the
two constructors of type \C{nat}, and in the second branch we give a
name not only to the argument \C{n} of the successor, but also to the
induction hypothesis. We also used the \C{//} switch to rule out the
base case because if
\C{m} is \C{0}, both sides evaluate to zero. The value of the parameter
\C{P} synthesized by \C{elim:} for us is
\C{(fun n : nat => n + 0 = n)}. It has been obtained by
\emph{abstracting} the term \C{m} in the goal (see
section~\ref{ssec:deffun}). The proof concludes by using lemma \C{addSn}
to  pull the \C{.+1} out of the sum, so that the induction hypothesis
\C{IHm} can be rewritten.

Unfortunately proofs by induction do not always run so smooth.
To our aid the \C{elim:} tactic provides two additional services.
The first one is to let one \emph{generalize}
the goal.  It is typically needed when the goal mentions a recursive function
that uses an accumulator: its value is going to change during recursive calls;
hence the induction hypothesis must be general.

Another service provided by \C{elim:} is specifying an alternative
induction principle, for example one may reason by induction on
a list starting from its end.

\begin{coq}{}{}
Lemma last_ind A (P : list A -> Prop) :
  P [::] -> (forall s x, P s -> P (rcons x s)) -> forall s, P s.
\end{coq}
where \C{rcons} is a name for the operation of concatenating
a sequence with an element, as in \C{(s ++ [::x])}.

For example \C{last_ind} can be used to relate the
\C{foldr} and \C{foldl} iterators as follows:

\begin{coq}{}{}
Fixpoint foldl T R (f : R -> T -> R) z s :=
  if s is x :: s' then foldl f (f z x) s' else z.

Lemma foldl_rev T R f (z : R) (s : seq T) :
  foldl f z (rev s) = foldr (fun x z => f z x) z s .
\end{coq}

The proof uses the following lemmas:

\begin{coq}{}{title=Tools}
Lemma cats1 T s (z : T) : s ++ [:: z] = rcons s z.
Lemma foldr_cat T f (s1 s2 : seq T) :
  foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1.
Lemma rev_rcons T s (x : T) : rev (rcons s x) = x :: rev s.
\end{coq}

The complete proof script follows:

\begin{coq}{}{}
Lemma foldl_rev T A f (z : A) (s : seq T) :
  foldl f z (rev s) = foldr (fun x z => f z x) z s .
Proof.
elim/last_ind: s z => [|s x IHs] z //.
by rewrite -cats1 foldr_cat -IHs cats1 rev_rcons.
Qed.
\end{coq}
\index[concept]{induction!generalizing}

Here ``\C{elim/last_ind: s z}'' performs the induction using the
\C{last_ind} lemma on \C{s} after having generalized the initial value of
the accumulator \C{z}.  The resulting value for \C{P} hence
features a quantification on \C{z}.

\begin{coq}{}{}
(fun s => forall z, foldl f z (rev s) = foldr (fun x z => f z x) z s)
\end{coq}

Thanks to the generalization, \C{IHs} states:

\begin{coq}{}{}
IHs : forall z : T, foldl f z (rev s) = foldr (fun x z => f z x) z s
\end{coq}
The quantification on \C{z} is crucial since the goal in the induction step,
just before we use \C{IHs}, is the following one:

\begin{coqout}{}{}
foldl f z (rev (s ++ [:: x])) =
  foldr (fun y w => f w y) (foldr (fun y w => f w y) z [:: x]) s
\end{coqout}

The instance of the induction hypothesis that we need is
one where \C{z} takes \C{(foldr (fun y w => f w y) z [:: x])},
i.e., the value of the accumulator, to \C{foldr} for a list
whose last element is \C{x}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsection{Rewrite, a swiss army knife}\label{sec:rewrite}

Approximately one third of the proof scripts in the \mcbMC{} library is made of
invocations of the \C{rewrite} tactic. This proof command provides many
features we cannot extensively cover here.  We just sketch a very common idiom
involving conditional rewrite rules and we mention the \C{RHS} pattern for
the casual reader.  The interested reader can find more about the pattern
language in section~\ref{sec:rewrite2} or in the dedicated chapter of
the Ssreflect language user manual~\cite{ssrman}.

So far we have solved side conditions using the simplification item \C{//}.
When this does not suffice, one can invoke another rewrite rule using
the optional iterator \C{?}.  A rule prefixed by \C{?} is applied to
all goals zero-or-more time.  For example, one could consider the
second sub goal that follows \C{rewrite dvdn_addr} a side condition
and solve it on the same line.

Let us illustrate this on an example of script that we have already used:

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1. (* ~~ (p %| 1) *)
by rewrite dvdn_fact // prime_gt0. (* p %| m`! *)
Qed.
\end{coq}

Optionally rewriting with \C{dvdn_fact} on all goals affects only
the side condition, since the main goal mentions no divides predicate.
The same holds for \C{prime_gt0}.

\begin{coq}{}{}
Lemma example m p : prime p -> p %| m `! + 1 -> ~~ (p <= m).
Proof.
move=> prime_p; apply: contraL; move=> leq_p_m.
rewrite dvdn_addr ?dvdn_fact ?prime_gt0 //.
by rewrite gtnNdvd // prime_gt1.
Qed.
\end{coq}
\index[ssr]{\C{rewrite}! \C{?} (optional iteration)}

Another functionality offered by \C{rewrite} is the possibility
to focus the search for the term to be replaced by providing a
context.  For example the most frequent context is \C{RHS} (for Right
Hand Side) and is used to force rewrite to operate only on the right
hand side of an equational goal.

\begin{coq}{}{}
Lemma silly_example n : n + 0 = (n + 0) + 0.
Proof. by rewrite [in RHS]addn0. Qed.
\end{coq}

\index[ssr]{\C{rewrite}! \C{[in RHS]} (focusing)}

The last rewrite flag worth mentioning is the \C{/=} simplification
flag.  It performs computations in the goal to obtain a ``simpler'' form.
\index[ssr]{\C{rewrite}!\C{/=} (simplification)}

\begin{coq}{def=UserRwPat}{width=7cm}
Lemma simplify_me : size [::] = 0.
Proof.
rewrite /=.
\end{coq}
\begin{coqout}{def=UserRwPat}{width=5cm}
==========================
0 = 0
\end{coqout}
The \C{/=} flag simply invokes the \Coq{} standard \C{simpl}
tactic.  Whilst being handy, \C{simpl} tends to oversimplify
expressions, hence we advise using it with care.
In section~\ref{sec:edivn} we propose a less risky alternative.
The sequence ``\C{// /=}'' can be collapsed into \C{//=}.
\index[ssr]{\C{rewrite}!\C{//=} (simplify close)}

Yet in fact the unfolding equation \C{leqE} that we used in
the proof of \C{leq_mul2l} in section~\ref{sec:multirew}
does not exist in the library and there is no name associate to this
equation. We actually do not need to state a lemma in order to relate
the name of a definition, like \C{leq}, to its body
\C{fun n m => n - m == 0}. This \emph{unfolding} operation can be
performed by calling the \C{rewrite} tactic, prefixing the name of the
constant with \C{/}, as in \C{rewrite /leq}. Unfolding a definition is
indeed not a deductive operation but an instance of computation, as
made more precise in chapter~\ref{ch:ttch}.
\index[ssr]{\C{rewrite}! \C{/} (unfolding)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{2}
\mcbsubsection{Rewrite contextual patterns}\label{sec:rewrite2}

The example \C{leq_mul2l} illustrates how the \C{rewrite} tactic, provided a
rewrite rule like \C{mulnBr} or \C{muln_eq0}, is able
to identify a
subterm in the goal to be substituted. The usability of the
tactic crucially relies on an appropriate combination of automation
and control. The user should be able to predict which subterm will be
substituted and to drive the tactic if needed, with enough control
options, but not too much verbosity. A key ingredient of the
\C{rewrite} tactic is hence the \emph{matching} algorithm that
elects this subterm from the arguments provided to the tactic. Let us
provide some insights on the power and on the limitations of this
algorithm, as well as on the control primitives that can drive it.
\index[concept]{matching algorithm}

First, remember that our first attempt, using the simple
\C{rewrite leqE} command, only
affected the left hand side of the initial goal because of the
behavior of this matching algorithm.
Indeed, the matching algorithm traverses the entire goal
left-to-right, looking for the first subterm matching pattern
\C{(_ <= _)},  and hence picks subterm \C{(m * n1 <= m * n2)}.
Now suppose we want to pick
the other instance of subterm matching this pattern in the goal. We
can use the command \C{rewrite [n1 <= _]leqE}: the
pattern given by the user overrides the one inferred from the rewrite
rule and is used to select the subterm to be rewritten. In this case,
term \C{(m * n1 <= m * n2)} is ruled out because the first argument of
\C{<=}, namely \C{(m * n1)}, does not match the first argument \C{n1}
required in the user-given pattern. Therefore, \C{rewrite} picks term
\C{(n1 <= n2)}, in the right hand-side.

\begin{coq}{def=UserRwPat}{title=User provided pattern,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [n1 <= _]leqE.
\end{coq}
\begin{coqout}{def=UserRwPat}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}

Another way of driving the matching algorithm is by providing a
\emph{context}, restricting the part of the goal to be explored. For
instance, in this case, the instance we want to pick is on
the right hand side of the identity to be proved. We can implement
this specification using the pattern \C{[in RHS]}:

\begin{coq}{def=UserRHSPat}{title=RHS pattern,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in RHS]leqE.
\end{coq}
\begin{coqout}{def=UserRHSPat}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}

More generally, one can provide context patterns like \C{[in X in T]}
where \C{X} is a variable name, bound in \C{T}. For instance pattern
\C{[in RHS]} is just syntactic sugar for the context pattern
\C{[in X in _ = X]}.  We invite the interested reader to check the
reference manual~\cite[section 8]{ssrman} for more variants of patterns and for a
more precise description of the different phases in the matching
algorithm used by this tactic.

Lemma \C{leqE} in fact does not exist in the library.%  Indeed the
% identity it states holds by symbolic computation, and we have seen in
% section~\ref{ssec:proofcomp} that such class of proof steps can be
% typically omitted.
However if we
try to omit the first \C{rewrite !leqE} command, then the next one,
namely \C{rewrite -mulnBr}, fails:

\begin{coq}{def=LeqMul2lproof2}{width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -mulnBr.
\end{coq}
\begin{coqout}{def=LeqMul2lproof2}{width=5cm}
The RHS of mulnBr
  (_ * _ - _ * _)
does not match any subterm
of the goal.
\end{coqout}
\index[concept]{keyed matching}

This indicates in particular that, although term \C{(m * n1 <= m * n1)}
is equal up to computation to term \C{(m * n1 - m * n1 == 0)}, the matching
algorithm is not able to see it. This is due to the compromise that
has been chosen, between predictability and cleverness. Indeed the
algorithm looks for a verbatim occurrence of the head symbol of the
pattern: in this case it hence looks for an occurrence of \C{(_ - _)},
which is not found. As a consequence, we need an explicit step in the
proof script in order to expose the subtraction before being able to
rewrite right to left with \C{mulnBr}. However if we tackle the proof
in reverse, starting from the right hand side, the first \C{-muln_eq0}
step will succeed:

\begin{coq}{def=PatForConv}{width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[_ || _]muln_eq0.
\end{coq}
\begin{coqout}{def=PatForConv}{width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
  (m * (n1 - n2) == 0)
\end{coqout}

Indeed, the \C{[_ || _]} pattern identifies term \C{(m == 0) || (n1 <= n2)}, as
their head symbols coincide. Now that we have elected a subterm, the
\C{rewrite} tactic is able to identify it with term
\C{(m == 0) || (n1 - n2 == 0)}, itself an instance of the right hand side
of \C{muln_eq0}. Note that the \C{[_ || _]} pattern is redundant here:
while matching only sees syntactic occurrences of the
head symbols of patterns, it is able to compare the other parts of the
pattern up to symbolic computation.

Patterns can not only be used in combination with a rewriting rule,
but also with a simplification step \C{/=} or an unfolding step
like \C{/leq}.

\begin{coq}{def=Unfold}{title=Focused unfold,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in LHS]/leq.
\end{coq}
\begin{coqout}{def=Unfold}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 <= n2)
\end{coqout}

One can also re-fold a definition, but in such a case one has to specify,
at least partially, its folded form.

\begin{coq}{def=Unfold}{title=Refold,width=7cm}
Lemma leq_mul2l m n1 n2 :
  (m * n1 - m * n2 == 0) =
    (m == 0) || (n1 <= n2).
Proof.
rewrite -/(leq _ _).
\end{coq}
\begin{coqout}{def=Unfold}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
  (m == 0) || (n1 <= n2)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-/} (folding)}

More generally, the \C{rewrite} tactic can be used to replace a
certain subterm of the goal by another one, which is equal to the
former modulo computation:

\begin{coq}{def=Unfold}{title=Replacing computationally equal terms,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[n1]/(0 + n1).
\end{coq}
\begin{coqout}{def=Change}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * (0 + n1) <= m * n2) =
(m == 0) || (0 + n1 <= n2)
\end{coqout}
\index[ssr]{\C{rewrite}! \C{-[term]/(term)} (changing)}

Last, an equation local to the proof context, like an
induction hypothesis, can be disposed after using it by
prefixing is name with \C{\{\}}.  For example
``\C{rewrite -\{\}IHn}'' rewrites with \C{IHn} right to
left and drops such context item.
\index[ssr]{\C{rewrite}! \C{\{name\}} (clear)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsection{Searching the library}\label{sec:search}
\index[concept]{search}

Finding the name of the ``right'' lemma in a library that contains
thousands of them may be quite a challenge. In spite of their digital
nature, formal libraries are not so easy to browse and the state
of the art of search tools for formal libraries is far from being as
advanced as what exists for instance for the world wide web.

In order to help the users finding their needle in the haystack,
the \mcbMC{} library follows uniform naming policies and the Ssreflect
proof language provides a \C{Search} command which displays lists of
items filtered using patterns, like \C{(_ * _ + _)}
or \C{(addn _ _)}, and substrings of the names, like \C{"rev" "cons"}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsubsection{Search by pattern}

The \C{Search} command takes a list of filters and prints the lemmas
that do match all the criteria.

The \emph{first} pattern provided is special, since it is required to match
the conclusion of a lemma, while all other patterns can match anywhere.

For example ``\C{Search (odd _)}'' only prints one lemma:

\begin{coq}{}{}
dvdn_odd  forall m n : nat, m %| n -> odd n -> odd m
\end{coq}
Indeed the conclusion matches the pattern.  Note that one is not forced to
use wild cards, \C{odd} alone is a perfectly valid pattern.  Many more
lemmas are found by leaving the conclusion unspecified as in ``\C{Search _ odd}''.

If we require the lemma to be an equation, as in ``\C{Search eq odd}'', we find
the following two lemmas (among many other things):

\begin{coqout}{}{}
dvdn2  forall n : nat, (2 %| n) = ~~ odd n
coprime2n  forall n : nat, coprime 2 n = odd n
\end{coqout}
If we want to rule out all lemmas about coprimality we can refine the
search by writing ``\C{Search eq odd -coprime}''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsubsection{Search by name}

Being acquainted to the naming policy followed by the \mcbMC{} library
provides one of the more effective ways of finding lemmas in the
loaded libraries. The name  \C{my_first_lemma} we chose in
section~\ref{ssec:groundeq} is actually a very bad name, as it gives no
insight about what the lemma says. Most of the time, we actually
refrain  from naming lemmas with numbers, as is typically done in
standard mathematical texts. Finding an appropriate name for a
lemma can be a delicate task. It should convey as much information as
possible, while striving to remain short and handy. In particular,
bureaucratic lemmas that are frequently used but represent no deep
mathematical step should have a short name: this way they are both
easy to type and easy to disregard when skimming through a proof
script.

Partial names can be used as filters by the \C{Search} command. For example
\C{Search "C"} prints, among other things, \C{addnC} and \C{mulnC},
the commutativity properties of addition and multiplication.  Multiple
strings can be specified, for example \C{Search "1" "muln"}.  This time
we find \C{muln1} but also \C{muln_eq1}, the equation saying that
the product of two natural numbers is $1$ if and only if they are both $1$.

Here are the general principles ruling the names of the in the \mcbMC{} library:
\begin{itemize}
\item{\bf Generalities}
  \begin{itemize}
  \item Most of the time the name of a lemma can be read off its
    statement: a lemma named \L+fee_fie_foe+ will say something about
    \L+(fee .. (fie ..(foe ..) ..) ..)+, e.g. lemma \L+size_cat+ in
    {\tt seq.v}.
  \item We often use a one-letter suffix to resolve overloaded
    notation, e.g., addn, addb, addr denote nat, boolean, ring
    addition, respectively. This policy does not necessarily apply to
    constants that should always be hidden behind a generic notation,
    and handled by a more generic theory.
  \item Finally, a handful of theorems have a historical name,
    e.g, \L+Cayley_Hamilton+ or \L+factor_theorem+.
  \end{itemize}
\item{\bf Structures and Records}
  \begin{itemize}
  \item Each structure type starts with a
    lower case letter, and its constructor has the same name but with a
    capital first letter.
  \item Each instance of a structure type has a name formed with the
    name of the carrier type, followed by an underscore and the one of
    the structure type like in \L+seq_sub_subType+, the structure of
    \L+subType+ defined on \L+seq_sub+ (see {\tt fintype.v}). Notable
    exceptions to this rule are canonical constructions taking
    benefits of modular name spaces, like in {\tt ssralg.v}.
  \end{itemize}
\item {\bf Suffixes}
  \begin{itemize}
  \item Lemma whose conclusion is a predicate, or an equality
    for a predicate: that predicate is a suffix of the lemma name,
    like in \L+addn_eq0+ or \L+rev_uniq+.
  \item Lemmas whose conclusion is a standard property such as
    \L+\char+, \L+<|+, etc.\footnote{These examples are taken from
      libraries in the Mathematical Component distribution.}:
    the property should be
    indicated by a suffix (like \L+ _char+, \L+_normal+, etc), so
    the lemma name
    should start by a description of the argument of the property, such as
    its key property, or its head constant.
    Thus we have \L+quotient_normal+, not \L+normal_quotient+, etc. This
    convention does not apply to monotony rules, for which we either
    use the name of the property with the suffix for the operator
    (e.g., \L+groupM+), or the name of the operator with the S
    suffix for subset monotony (e.g., \L+mulgS+).
  \item We try to use and maintain the following set of lemma suffixes:
    \begin{itemize}
    \item {\tt 0} : zero, or the empty set
    \item {\tt 1} : unit, or the singleton set (use \L+_set1+ for
      the latter to disambiguate)
    \item {\tt 2} : two, doubling, doubletons
    \item {\tt 3} etc, similarly
    \item {\tt A} : associativity
    \item {\tt C} : commutativity, or set complement (use \L+Cr+
      for trailing complement)
    \item {\tt D} : set difference, addition
    \item {\tt E} : definition elimination (often conversion
      lemmas)
    \item {\tt F} : boolean false, finite type variant (as in
      \L+canF_eq+), or group functor
    \item {\tt G} : group argument
    \item {\tt I} : set intersection, injectivity for binary operators
    \item {\tt J} : group conjugation
    \item {\tt K} : cancellation lemmas
    \item {\tt L} : left hand side (as in \L+canLR+)
    \item {\tt M} : group multiplication
    \item {\tt N} : boolean negation, additive opposite
    \item {\tt P} : characteristic properties (often reflection
      lemmas)
    \item {\tt R} : group commutator, or right hand side (as in
      \L+canRL+)
    \item {\tt S} : subset argument, or integer successor
    \item {\tt T} : boolean truth and Type-wide sets
    \item {\tt U} : set union
    \item {\tt V} : group or ring multiplicative inverse
    \item {\tt W} : weakening
    \item {\tt X} : exponentiation, or set cartesian product
    \item {\tt Y} : group join
    \item {\tt Z} : module/vector space scaling
    \end{itemize}
  \end{itemize}
\end{itemize}


% Standard properties are
% always stated with predicates to impose
% consistency in their statements.  Indeed the real statement of
% \C{addnC} is \C{(commutative addn)}, where \C{addn} is the
% name of the addition operation and \C{commutative} is the
% following predicate.
%
% \begin{coq}{name=macro}{title=Predicate for stating commutativity (suffix ``C'')}
% Definition commutative op := forall x y, op x y = op y x.
% \end{coq}
%
% Predicates, being standard definitions, are completely transparent for the
% system.\footnote{not yet for \C{Search}, but here I'm describing an ideal
% situation}  Consistency is not only aesthetically, but ease the use of
% lemmas: as we will see later, the order of the quantification may make
% a lemma easier to use under certain circumstances.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Exercises}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:boolid,difficulty=0,title={Truth tables}]

Prove the following boolean tautologies:

\begin{coq}{}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
\end{coq}

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:rewrite,difficulty=0,title={Rewriting}]

Prove the following lemma by rewriting:

\begin{coq}{}{}
Lemma subn_sqr m n : m ^ 2 - n ^ 2 = (m - n) * (m + n).
\end{coq}
The \C{(_ ^ _)} notation is attached to the \C{expn} function.

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:induction,difficulty=1,title={Induction}]

Prove the following lemma by induction:

\begin{coq}{}{}
Lemma odd_exp m n : odd (m ^ n) = (n == 0) || odd m.
\end{coq}
Recall that a local equation can be disposed (after use)
by prefixing its name with \C{\{\}}.

\end{Exercise}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:induction2,difficulty=2,title={Multiple induction}]

Prove the following lemma by induction.

\begin{coq}{}{}
Lemma size_all_words n T (alphabet : seq T) :
  size (all_words n alphabet) = size alphabet ^ n.
\end{coq}

It requires two inductions: first on the length of words,
then on the alphabet.  In this last case, a non trivial
sub expression has to be generalized just before starting
the induction.

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:boolid]

\begin{coq}{}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Proof. by case: b1; case: b2; case: b3. Qed.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Proof. by case: a; case: b. Qed.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
Proof. by case: a; case: b. Qed.
\end{coq}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:rewrite]

\begin{coq}{}{}
Lemma subn_sqr m n : m ^ 2 - n ^ 2 = (m - n) * (m + n).
Proof. by rewrite mulnBl !mulnDr addnC [m * _]mulnC subnDl !mulnn. Qed.
\end{coq}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:induction]

\begin{coq}{}{}
Lemma odd_exp m n : odd (m ^ n) = (n == 0) || odd m.
Proof.
elim: n => // n IHn.
rewrite expnS odd_mul {}IHn orbC.
by case: odd.
Qed.
\end{coq}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:induction2]

\begin{coq}{}{}
Lemma size_all_words n T (alphabet : seq T) :
  size (all_words n alphabet) = size alphabet ^ n.
Proof.
elim: n => [|n IHn]; first by rewrite expn0.
rewrite expnS -{}IHn [in LHS]/all_words iterS -/(all_words _ _).
elim: alphabet (all_words _ _) => //= w ws IHws aw.
by rewrite size_cat IHws size_map mulSn.
Qed.
\end{coq}
\end{Answer}







% To get a better feeling on how lemmas are named let's see some other
% lemmas already proved for us.

% \begin{coq}{}{width=5cm,title=Lemmas of the library}
% Check add0n.
% Check addnC.
% \end{coq}
% \begin{coqout}{}{title=Response,width=7cm}
% add0n : forall n : nat, 0 + n = n
% addnC : forall n m : nat, n + m = m + n
% \end{coqout}

% First of all, note the quantification. So far \C{forall} was used to quantify
% over types and describe polymorphic functions.  Now it ranges over terms of
% type \C{nat} and describes generic lemmas, holding for any natural numbers
% \C{n} and \C{m}.

% Going back to the naming conventions, note that both names begin with ``add'',
% that is the principal operation involved.  In particular is the head symbol
% (the most external one) in the left hand side of the equation.  The addition
% operation is the one on natural numbers, hence then ``n'' component in
% the suffix.

% For the first equation, the other symbol involved in the name is ``0'',
% that indeed plays an important role in the lemma.  The relative position
% of ``0'' and ``n'' is chosen to recall to the user if the neutral element
% is added to the left or to the right.  For example the lemma named
% \C{addn0} would state \C{forall n : nat, n + 0 = n}.


% \subsection{Writing proof scripts}

% indentation, naming, using closing tactics.

% \subsection{Searching existing content}

% END OF THE REVISED ORGANIZATION.
%%%--------------- oldies

% \subsection{Stating and proving an equality}
%
% The \C{by} terminator is systematically used to prefix any proof sentence
% that terminates a goal.  A proof sentence ends with a dot, and can
% combine more than one proof command via the semi colon punctuation,
% again more examples will follow.
% The use of \C{by} is not limited to asserting no goals are left,
% but is also used to close goals by trivial means.  The notion of triviality
% is an important point we will discuss many times, for now lets just
% say it is extensible by the user and that it includes reflexivity.
% Hence the previous proof can be written as \C{by [].} where \C{[]}
% denotes the empty list of proof commands.
%
% \begin{coq}{title=Same proof}
% Lemma my_first_lemma : 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% The \C{Qed} keyword terminates the proofs, checks it, and adds to
% the library the new lemma.  We can hence access
%
% Given that our first lemma is now part of the library as the result
% of the \C{Qed} command we can access it.
% \marginnote{should we use About ?}
%
% \begin{coq}{width=6cm,title=Printing a lemma statement}
% Check my_first_lemma.
% \end{coq}
% \begin{coqout}{title=Response,width=6cm}
% my_first_lemma : 3 = 3
% \end{coqout}
%
% Now that we are satisfied with the statement, we look into proving it.
% At the current stage we need to use the two already existing
% lemmas \C{add0n} and \C{addnC} and the fact that the equality predicate
% is substitutive: given an equation we can replace any instance of
% its left hand side with the corresponding instance of the right hand side.
%
% The command is called rewrite, and its argument its called rule.
%
% \begin{coq}{title=Pedestrian proof}
% rewrite add0n.
% rewrite addnC.
% by [].
% Qed.
% \end{coq}
%
% \begin{coqout}{title=Response line 1,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    a + b = b + a
% \end{coqout}
% \begin{coqout}{title=Response line 2,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    b + a = b + a
% \end{coqout}
%
% Explain the job of instantiation rewrite does: picks \C{(a + b)} for
% \C{n} in \C{add0n} and picks \C{a} for \C{n} and \C{b} for \C{m} in
% \C{addnC}.  Explain it is guided by the head symbol \C{+} and traverses
% the goal left to right.  Define "pattern".
%
% \begin{coq}{width=4cm,title=The new lemma}
% Check add0nmC.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% add0nmC : forall a b : nat, 0 + (a + b) = b + a.
% \end{coqout}
%
% The rewrite proof command is very recurrent, hence a shorter form
% using multiple rules.
%
% \begin{coq}{title=More compact proof}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite add0n addnC. Qed.
% \end{coq}
%
% Note that the equations are used in order, e.g. the script
%
% \begin{coq}{title=Wrong proof}
% Lemma add0nmC_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite addnC add0n. Qed.
% \end{coq}
%
% Fails because \C{addnC} flips \C{0} with \C{(a + b)}, then
% \C{add0n} finds no matching sub term.  In any case the proof
% is wrong, commutativity has to be employed to flip \C{a} and \C{b},
% or \C{b} and \C{a}, but not \C{0}.  If one wants to keep the rules
% in that order he needs to drive \Coq{} by better specifying the
% pattern he infers from \C{addnC}.
%
% \begin{coq}{title=Rewrite pattern}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC add0n. Qed.
% \end{coq}
%
% Explain pattern: overrides the pattern inferred.
% Explain underscore: saves space if b is large.
%
% Discuss: stating an equation (LHS is bigger).
%
% \subsection{Equality up to computation}
%
% As we said at the beginning, equality is up to computation.
% Since \C{(0 + 3)} computes to \C{3}, proving the equality among
% the two expressions is trivial.
%
% \begin{coq}{title=Computation in proofs}
% Eval compute in (0 + 3).  (* prints 3 *)
% Eval compute in (true || false).  (* prints true *)
% Lemma example3 : 0 + 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% Indeed \C{reflexivity}, and \C{by []} as well, take computation
% into account.
% Note it also works for symbolic expressions.
%
% \begin{coq}{title=Computation in proofs}
% Lemma add0n n : 0 + n = n.
% Proof. by []. Qed.
% \end{coq}
%
% Explain addn0 is different, why, and that it will be shown later,
% when induction will be introduced.
%
% If we go back playing with the previous proof, we see that the
% last rule can be omitted.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC. Qed.
% \end{coq}
%
% The reason is that \C{(0 + (b + a))} is equal
% to \C{(b + a)} up to computation.
% Note that add0n  is not only for free (in its proof) but
% also in its use.
%
% Maybe talk about \C{/=} here.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite /= addnC. Qed.
% \end{coq}
%
% Note the pattern can go, since \C{/=} leaves the goal with
% no ambiguity.
% Note that, if we mind computation, the lemma is just an alias
% for \C{addnC} and hence is useless.  It may feel depressing, but
% it is actually a very important hygiene measure: only useful lemmas
% are kept, trade off between all combinations or few base blocks that
% combine well (harder in principle, requires a language that glues well).
%
%
%
% % \subsection{old}
% %
% % \begin{itemize}
% % \item \Coq{} comes with an equality predicate, that we see as axiomatic for the
% % moment (in this section). It is called \C{eq} and has an infix
% % notation \C{=}. Example: \C{Check 3 = 3}, \C{Check 3 = 4}.
% % \item Observe that, \C{Check} just checks the well-formedness of the
% %   statement, not its truth. Well-formedness here means that \C{=}
% %   requires both hand-sides to be of the same type.
% %   Example \C{Check 3 = [::4]}. Observe that statement also have a
% %   type, called \C{Prop}.
% % \item We can give a name to a statement, that we would like to prove
% %   formally. Example \C{Lemma foo : 3 = 3}. Observe what happens at the
% %   level of the interface (we start a proof).
% % \item And now, how to prove equality statements. Observational, \C{=}
% %   behaves as expected: this is trivially true because \C{=} is
% %   reflexive.
% % \item End of the proof, \C{Qed}.
% % \item Now we have a theorem called \C{foo} at hand in the
% %   environment: \C{Check foo}. We can use it but it is useless...
% % \item In fact the libraries you load provide theorems that you can use
% %   in your proofs. Example:  \C{Check add0n}, \C{Check addnC}. Note the
% %   universal quantification.
% % \item How to state lemmas like this:
% % \C{Example toto a b : 0 + (a + b) = a + b}.
% % \item Equality is not just reflexive, it is also substitutive. This is
% %   implemented via the \C{rewrite} tactic, that we can use to prove
% %   this lemma, using \C{add0n}. Note that the tactic found the right
% %   instance of \C{add0n} to be used, with \C{(a + b)}.
% % \item \C{Qed}, \C{Check}, observe the universal quantification.
% % \item Rewrite steps can be chained, in order. Example:
% % \C{Example toto a b : 0 + (a + b) = b + a}. can be proved by rewriting
% % \C{add0n} then, \C{addnC}. Note that \C{addnC} then \C{add0n} does
% % something different.
% % \item In fact reflexivity is more than syntactic equality. Prove
% % \C{3 + 1 = 4}, \C{true || false = true}. But also with variables,
% % e.g. \C{add0n}, connect with the programs written in the previous
% % chapters.
% %
% % \item More advanced forms of proofs by the \C{rewrite} tactic allow to
% %   select a pattern and to simplify the goal for free by
% %   computation. Hence \C{addn0} just does not need to be stated
% %   explicitly in the proof script. Warning: simpl is a Pandora
% %   box. This should come very early
% %   and go with/before boolean reflection style proofs by rewriting.
% %
% % \item Special case of equality statements that play a pervasive role
% %   throughout the libraries: \C{_ = true}. For instance
% %   \C{odd (2 * x + 7) = true}. This is both a 'logical' statement,
% %   saying that any expression \C{(2x+7)} is an odd number, and
% %   an equation that can be rewritten during the course of a proof. Find
% %   an example, like \C{odd (2 * x + 7) || odd (2 * x)}. rewrite and
% %   compute.
% %
% % \item Now we should point the coercion, because people will search and
% %   check.
% % \end{itemize}
%
%
%
% \mcbLEARN{case}
% \mcbREQUIRE{}
% \mcbPROVIDE{case, -, indentation, brute force proofs, semicolon, => after case}
% \mcbLEVEL{1}
% \mcbsection{Case analysis}
%
% In programming inductive data is matched against to consider all
% possible cases.  In the same way, when we reason on a program
% whose input is symbolic, we can proceed by considering all possible
% cases.
%
% \begin{coq}{title=First De Morgan's law: pedestrian proof}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof.
% case: a.
% - by []
% case: b.
% - by [].
% by [].
% Qed.
% \end{coq}
% \begin{coqout}{title=Response line 3,width=8cm}
% 2 subgoals
%
%   b : bool
%   ============================
%    ~~ (true && b) = ~~ true || ~~ b
%
% subgoal 2 is:
%  ~~ (false && b) = ~~ false || ~~ b
% \end{coqout}
%
% Explain the decorator and the indentation policy.
% Note a removed from context, substituted by true and false.
% Note first goal computes to b=b.
% Note second goal does not, computation blocked, we case b.
%
% \begin{coqout}{title=Response line 5,width=8cm}
% 2 subgoals
%
%   ============================
%    ~~ (false && true) = ~~ false || ~~ true
%
% subgoal 2 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Now all computes.  We are not satisfied, we could write
% as the only tactic \C{case: a; case: b.}.
%
% \begin{coqout}{title=Response,width=8cm}
% 4 subgoals
%
%   ============================
%    ~~ (true && true) = ~~ true || ~~ true
%
% subgoal 2 is:
%  ~~ (true && false) = ~~ true || ~~ false
% subgoal 3 is:
%  ~~ (false && true) = ~~ false || ~~ true
% subgoal 4 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Explain semicolon.
% Note that all computes. Note that this is always possible
% for finitary data, it amounts to comprehensive testing.
%
% \begin{coq}{title=First De Morgan's law}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof. by case: a; case: b. Qed.
% \end{coq}
%
% other examples, exercises, can be
%
% \begin{coq}{title=possible exampels}
% Lemma andbA : associative andb.        Proof. by do 3!case. Qed.
% Lemma orbCA : left_commutative orb.    Proof. by do 3!case. Qed.
% Lemma andbN b : b && ~~ b = false.     Proof. by case: b. Qed.
% \end{coq}
%
% to explain A and N suffixes, plus do iteration, plus stack top.
%
% When data is not finitary, then case is not sufficient.
%
% \begin{coq}{}
% Lemma eqnxx (x : nat) : eqn x x = true.
% Proof. case: x => [|x'].
% \end{coq}
%
% Name subterms.
%
% \begin{coqout}{title=Response,width=8cm}
%   x' : nat
%   ============================
%    eqn x'.+1 x'.+1 = true
% \end{coqout}
%
% But before induction we look at implication
%
% \mcbLEARN{apply}
% \mcbREQUIRE{}
% \mcbPROVIDE{apply, ->, =>, //}
% \mcbLEVEL{1}
% \mcbsection{Implication and backchaining}
%
% \begin{coq}{width=4cm}
% Check @dvdn_mul.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% dvdn_mul : forall d1 d2 m1 m2 : nat,
%   d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
% \end{coqout}
%
% Explain implication symbol, the ambiguity with function space will
% be explained later on.
%
% \begin{coq}{}
% Lemma stupid x : 3 * x %| 6 * x^2.
% Proof.
% apply: dvdn_mul.
% - by [].
% apply: dvdn_mulr.
% exact: dvdnn.
% Qed.
% Lemma stupid2 x : 3 * x %| 6 * x^2.
% Proof.
% rewrite dvdn_mul // dvdn_mulr // dvdnn.
% Qed.
% \end{coq}
%
% How do we prove this kind of lemmas
%
% \begin{coq}{}
% Lemma stupid3 x y : x %| y -> 3 * x %| 6 * y.
% Proof.
% move=> div_xy.
% by apply: dvdn_mul.
% Qed.
% \end{coq}
%
% by looks in the hyps.
%
% \begin{coq}{}
% Lemma stupid3 x y (div_xy : x %| y) : 3 * x %| 6 * y.
% Proof. exact: dvdn_mul. Qed.
% \end{coq}
%
% equivalent syntax, uncommon.
%
% Make another example working on the stack
%
% \begin{coq}{}
% Lemma andb_idl (a b : bool) : (b -> a) -> a && b = b.
% Proof. by case: a; case: b => // ->. Qed.
% \end{coq}
%
% note // in =>, note -> in =>, note runs on 4 goals.
%
% one last example with true=false in the context.
%
% \section{Proofs by induction}
%
% \begin{coq}{}
% Lemma eqnxx x : eqn x x.
% Proof.
% elim: x=> [|x' IH].
% rewrite /=.
% apply: IH.
% by [].
% Qed.
% Lemma eqnxx x : eqn x x.
% Proof. by elim: x. Qed.
% \end{coq}
%
% requires induction.
%
% \section{Curry-Howard}
%
% Explain CH for arrows, foralls, equality and induction. Show Proof for
% some examples of proofs.
%
% First implication, start with comparing the source and target of the
% arrows that are common to this chapter and the preceeding.
%
% \begin{coq}{}
% Inductive list (A : Type) : Type :=
%     nil : list A | cons : A -> list A -> list A
%
% list: Type -> Type
%
% Definition is_equal_to_2 (x : nat) : x = 2.
%
% is_equal_to_2 : nat -> Prop
% \end{coq}
%
%
%
%
%
%
% \section{To be sorted}
%
% \subsection{Universal quantification}
%
% \begin{coq}{}
% Variable A : Prop.
% Definition toto : A -> A := fun x => x.
% Lemma  toto : A -> A.
%  Proof.
%   move => x.
%   Show Proof.
%   apply: x.
%  Qed.
% \end{coq}
%
% Note : \C{toto :  A -> A : Prop}
% discuss interactive proof construction, other example with a real
% apply that open subgoals.
%
% In CH style we see a proof, where lambdas/apply work too (same tactics)
%
% Specialization of an quantified lemma via application (maybe also
% \C{move/(_ x) in H}).
% Soft intro of the work of unification (FO) during application (infer
% arguments of conclusion's predicate symbol \C{prime _}).
%
% We should also display her  HO "predicators": commutative.  Discuss
% order of quantification in transitive and similar, naming conventions
%
% \subsection{Curry-Howard for equality proofs}
%
%
% Show \C{rewrite -H}, plus the idea that one may want to select
% occurrences (with simple patterns).
%
%
% May be should we say rather early that rewriting under binders is not
% allowed by the system.
%
% \subsection{proof term for rewrite (CH)}
%
% There are also proof terms for equality proofs (show \C{refl})
% The work rewrite does is non trivial (infer P)
%
% \begin{coq}{}
% Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
% \end{coq}
%
% Write a proof term by hand.
% (note that it works because of beta being part of conversion).
% See that rewrite does the verbose part for you (infer P).
%
% An example of ambiguous P from above, driving rewrite means driving the
% synthesis of P.
%
% \subsection{other eq related tactics}
%
% Congr, injection \C{[= ]}, discriminate (//), \C{->}.
%
%
% \subsection{proof term for induction}
%
% Again show that it boils down to infer P
%
%
% \subsection{proofs by induction in their generality}
%
% Show that even for commutativity of addition one needs to
% "load the goal" (or to help synthesize a more general P).
%
%
% \section{Exercises (explained)}
%
% xor-odd, then cancel encode decode, or something on primes.
%
% Take the occasion to present last/first, bullets, by, syntaxes for
% \C{=> [|IH x xs]} after a case.
%
%
% \section{Notes}
%
% % From calculability to proofs, hence the CC, and the fact that
% % reasoning principles without a computational content become axioms.
% %
% % This is a non technical chapter and message should be:
% % \begin{itemize}
% % \item instantiation of a universal statement is application (also the pair)
% % \item Excluded middle is not available by default (choice?)
% % \item Conversion as a pervasive indistinguishable, what inside
% %   (beta, definition unfolding,...)
% % \item Dependent types: eq, sigma (which example?)
% % \end{itemize}
% %
% % One options is: avoid relating type theory and other logics. We say:
% % we have a formal game where the basic elements are programs/functions
% % that come with types to avoid confusion. full stop. (no relation with
% % proof theory, set theory). maybe mention that roots are in calculability (hence
% % the choice to pick functions as primitive and not sets). This is lucky because
% % (computable) functions are today executable by a computer.  Still not all
% % concepts are "computable" hence some principles are problematic: EM,.... we
% % mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% % constructive math; just a mention).
% %
%
% running topic: statements and their proofs. This chapter provides a gentle
% introduction to the implicative fragment of the logic and to the
% interactive construction of formal proofs. The reference to
% Curry-Howard should come as late as possible. It should indeed be
% possible to present a substantial amount of example and intuitions
% before explaining this. Specially if we carefully use the automated
% introduction of variables bound before the semi-column. At the tactic
% level, we should be able to avoid the need for Curry Howard related
% constructions like \C{apply: (H x)} in the first part of the chapter.
%
% \begin{itemize}
% \item \C{Prop} as the type of statements
% \item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
% \item examples with implicative predicate logic, modus ponens
% \item definition = lemma (proofs of implications are lambdas-app)
% \item tactics to generate the terms in a less pedestrian way (move, apply)
% \item if one calls Show Proof in the middle he sees one is building
% 	the proof term incrementally, as one draws a proof tree (in CH style)
% \end{itemize}
%
% Now we make the point of Qed, the kernel checks the term produced via
% tactics (or hand-written).
%
% Examples of predicates: equality
% \begin{itemize}
% \item not to talk about indexes of inductive families we introduce eq as
% 	an axiom and refl as another axiom to prove eq and we insist on
% 	conversion
% \item examples, among which a beta expansion (to help later on with elimination)
% \item now, what are the proofs of an equality? maybe we start with rewrite
% \item examples are symmetry, transitivity
% \item then we give the elimination principle as an axiom, and explain the
% 	work rewrite does in synthesizing the predicate
% \item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
% \item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
% \end{itemize}
%
% Showing universal properties on inductive data
% \begin{itemize}
% \item first enouce some lemmas on concrete examples, like not true = false,
% 	then try to say "froall b : bool, ...".
% \item first on enumerated types (bool) via case
% \item them on nat via case and elim
% \item then show the proof term as an application of nat-rect, again the problem
% 	is to write down P and elim does that.
% \item here an additional problem: loading the goal before using it to generate P
% \end{itemize}
%
% We should manage to prove stuff on the concepts defined in chapter 1,
% notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
% on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
% a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).
%
% Comparison with other approaches:
% \begin{itemize}
% \item Compare an axiomatic, equational presentation of arithmetic to
%   its formalization as an inductive type with functions that
%   compute.
% \end{itemize}
%
%
% Another example is set-nth of rcons as done by Florent Hivert, that has not
% developed the theory of set-nth with cat, and hence messes up the proof
% that gets shorter if one does the homework.
%
% Another example could be a proof that requires the induction principle
% on nat that (strong/course of values induction).
%
% A maybe good example that forces you to do patterns or occ numbers and explain
% that 2  contains syntactically 0 is the proof that code/decode cancel (in
% choice).
%
% We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.
%
% We need also /= and hence Arguments simple never (and we try to omit nosimpl).
% Maybe we should document that nosimpl has been superseeded by
% the option of Arguments in the manual.
% Let say that controlling reduction is an important topic when you
% do ssr style.
%
% In this chapter we present several features of the proof language, but it it is
% not about the proof language itself (reference manual). What one adds to the
% reference manual here is an example of usage in the right context of the
% commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
% discuss all the matching discipline... nor the most advanced syntaxes)
