% Some \Coq{} snippets to be used later on
\begin{coqdef}{name=ssr}
From mathcomp Require Import all_ssreflect.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
% [DG] This looks outdated -- at least it doesn't compile.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=qed}
Qed.
\end{coqdef}
\begin{coqdef}{name=proof}
Proof.
\end{coqdef}
\begin{coqdef}{name=done}
by [].
\end{coqdef}
\begin{coqdef}{name=verbose}
Unset Silent.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=show2}
Redirect "g2" Show.
\end{coqdef}
\begin{coqdef}{name=show}
Show.
\end{coqdef}


\Chapter{First Steps in Formal Proofs}{}
\label{ch:proofs}
% In this chapter we explain how to state a lemma,
% how to prove it, and how to search existing, loaded library.
% We focus here on simple proof commands, conventions and a first taste
% of boolean reflection. Views and the related tactics are postponed to the
% next chapter, and so are conjunctions and existential statements.

In this chapter, we explain how to use the \Coq{} system to state and
to prove theorems, focusing on simple statements and basic proof
commands. In the course of this book, we will see that choosing the
right way to state a proposition formally can be a rather delicate
matter. For equivalent wordings of one and the same
proposition, some can be
much simpler to prove, and some can be more convenient to invoke
inside the proof of another theorem. This chapter emphasizes
the use of computable definitions and equational reasoning
whenever possible, an approach that will be developed fully in
chapter~\ref{ch:boolrefl}.

\mcbLEARN{Stating basic theorems involving boolean statements,
  equalities, and arrows. Universal quantification is presented via
  parameters.}
\mcbREQUIRE{About, Check, implicit arguments, notations for the
  constants defined at chapter 1, principles of notations
  (associativity,...), definition of 'boolean predicate', sections}
\mcbPROVIDE{\C{Lemma},\C{Admitted}, eq, is-true, Lemma, \C{Prop}, \C{->}}
\mcbLEVEL{1}
%\mcbsection{First formal statements}
\mcbsection{Formal statements}


In this section, we illustrate how to state elementary candidate
theorems, starting with \emph{identities}.

\subsection{Ground equalities}\label{ssec:groundeq}
\index[concept]{proposition}
\index[concept]{equality}
\index[concept]{ground equality}

%\marginnote{We should have somewhere early a paragraph about the prelude.}
\Coq{} provides a binary predicate named \C{eq} and equipped with the
infix notation \C{=}. This predicate is used to write sentences
expressing that two objects are \emph{equal}, like in $2 + 2 = 4$.
Let us start with examples of \Coq{} \emph{ground} equality
statements: \emph{ground} means that these statements do not feature
parameter variables. For instance $2 + 2 = 4$ is a ground
statement, but $(a + b)^2 = a^2 + 2ab + b^2$ has two parameters $a$
and $b$: it is not ground.

The \C{Check} command can be used not only to verify the type
of some expression, but also to check whether a formal statement
is well formed or not:

\begin{coq}{name=check-eq}{width=6cm}
Check 3 = 3.
Check false && true = false.
\end{coq}
\coqrun{name=r1}{ssr,check-eq}
\begin{coqout}{run=r1}{width=6cm}
3 = 3 : Prop
false && true = false : Prop
\end{coqout}

Let's anatomize the two above examples. Indeed, just like \Coq{}'s
type system prevents us from applying functions to
arguments of a wrong nature, it also enforces a certain nature of
well-formedness at the time we enunciate sentences that are candidate
theorems. Indeed, formal statements in \Coq{} are themselves
\emph{terms} and as such they have a \emph{type} and their subterms
obey type constraints. An
equality statement in particular is obtained by applying the constant
\C{eq} to two arguments \emph{of the same type}. This application
results in a well-formed term of type \C{Prop}, for \emph{proposition}.

Throughout this book, we will
use the word \emph{proposition} for a term of type \C{Prop}, typically
something one wants to prove.
% Sometimes we say \emph{boolean proposition} to stress that the proposition
% is made by equating two boolean expressions, as in Line 2 above.

The \C{About} vernacular
command provides information on a constant, like its
type and the status of its argument. It applies just as well to
% [DG] What does "status" mean here?
propositions and to the components thereof. For instance we can learn more
about the constant \C{eq}:

\begin{coq}{name=about}{width=6cm,title=The polymorphic equality predicate}
Locate "=".

About eq.
$~$
\end{coq}
\coqrun{name=abouteq}{about}
\begin{coqout}{run=abouteq}{title=Response,width=6cm}
"x = y" := eq x y

eq : forall A : Type, A -> A -> Prop
Argument A is implicit ...
\end{coqout}

The constant \C{eq} is a \emph{predicate}, i.e., a function that
outputs a proposition. The equality
predicate is polymorphic: exactly like we have seen in the previous
chapter, the \C{forall} quantifier (represented by the
$\forall$ symbol in \Coq{}'s output, at least as long as the symbol
is available)
% [DG] In https://x80.org/collacoq/ it's just the string "forall", so
% I am saying "as long as the symbol is available", but truth is I
% don't know the technicalities. But something should be said about
% the symbol, since it is confusing to refer to it by the name
% "forall" whereas it appears as a symbol in the coqout environment.
is used to make the (implicit)
parameter \C{A} range over types. Both examples \C{3 = 3} and \C{false
&& true = false} thus use the \emph{same} equality constant, but with
different values (respectively, \C{nat} and \C{bool}) for the type
parameter \C{A}. Since the first argument of \C{eq} is implicit, it is not
part of the infix notation and its value is not
provided by the user. This value can indeed be inferred from the type of the
two sides of the identity: \C{(3 = 3)} unfolds to \C{(eq _ 3 3)}, and
the missing value must be \C{nat}, the type of \C{3}. Similarly,
\C{(false && true = false)} unfolds to \C{(eq _ (false && true) false)}
and the missing value is \C{bool}, the common type of \C{false} and
\C{(false && true)}.

As the \Coq{} system checks the well-typedness of statements,
the two sides of a well-formed equality should have the same
% [DG] I've never heard the word "hand side" used in English, although
% I agree it would be a useful word.
type:

\begin{coq}{name=check-eq2}{width=4cm}
Check 3 = [:: 3].
$~$
\end{coq}
\coqrun{name=r2;fail}{ssr,check-eq2}
\begin{coqout}{run=r2}{width=8cm}
Error: The term "[:: 3]" has type "seq nat"
 while it is expected to have type "nat".
\end{coqout}
Yet it does not check the provability of the statement!

\begin{coq}{name=false-statement}{width=6cm}
Check 3 = 4.
\end{coq}
\coqrun{name=check34}{false-statement}
\begin{coqout}{run=check34}{width=6cm}
3 = 4 : Prop
\end{coqout}

In order to establish that a certain equality holds, the user should
first announce that she is going to prove a sentence, using a special
command like \C{Lemma}. This command has several variants \C{Theorem},
\C{Remark}, \C{Corollary},\dots which are all synonyms for what
matters here.
A \C{Lemma} keyword is followed by the name chosen for the lemma and
then by the statement itself. Command \C{Lemma} and its siblings are in fact
a variant of the \C{Definition} syntax we used in
chapter~\ref{ch:prog}: everything we mentioned about it also applies
here. The \C{Proof} command marks the beginning of the proof text,
which ends either with \C{Qed} or \C{Admitted}. After the command
\C{Proof} is executed, the system displays the current state of the
formal proof in a dedicated window.
\index[vernac]{\C{Lemma}}
\index[vernac]{\C{Theorem}}

\begin{coq}{name=first-lemma}{width=6.5cm,title=Stating a lemma and starting its proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* your proof text *)
$~$
\end{coq}
\begin{coqout}{run=r3}{title=Response after line 2: proof state,width=5.5cm}
1 subgoal

  ======================
   3 = 3
\end{coqout}
\coqrun{name=r3}{ssr,first-lemma,show,abort}

Indeed, \Coq{} is now in its so-called \emph{proof mode}: we can execute
new commands to construct a proof and inspect the current state of a
proof in progress, but some other commands, like opening sections, are
no longer available. At any stage of the proof construction, \Coq{}
displays the current state of the (sub)proof currently pending:  a
list of named hypotheses forms the current context and is printed
on top of the horizontal bar (empty here), whereas
the statement of the current goal (the conjecture to be proved) is
below the bar.

We will explain how to proceed with such a proof in
section~\ref{ssec:proofcomp}.
For now, let us just admit this result, using the \C{Admitted}
command.
\index[vernac]{\C{Admitted}}

\begin{coq}{name=first-lemma-admitted}{}
Lemma my_first_lemma : 3 = 3.
Proof.
Admitted.
\end{coq}

Although we have not (yet) provided a proof for this lemma, a new
definition has been added to our environment:

\begin{coq}{name=about-first-lemma}{width=6cm}
About my_first_lemma.
\end{coq}
\begin{coqout}{run=aboutmfl;dots}{width=6cm}
my_first_lemma : 3 = 3
\end{coqout}
\coqrun{name=aboutmfl}{ssr,first-lemma-admitted,about-first-lemma}


In the rest of the chapter, we will often omit the \C{Admitted} proof
terminator, and simply reproduce the statement of some lemmas in
order to discuss their formulation.

\subsection{Identities}\label{ssec:id}
\index[concept]{identity}

Ground equalities are a very special case of mathematical
statements called \emph{identities}. An \emph{identity} is an equality
relation $A = B$ that holds regardless of the values that are
substituted for the variables in $A$ and $B$.
Let us state for instance the identity expressing the associativity of
the addition operation on natural numbers:

\begin{coq}{name=addnA}{}
Lemma addnA (m n k : nat) : m + (n + k) = m + n + k.
\end{coq}
\coqrun{name=testaddndA}{ssr,addnA,abort}

Note that in the statement of \C{addnA}, the right hand side does not
feature any parentheses but should be read \C{((m + n) + k)}: This
is due to the left-associativity of the infix \C{+} notation, which
was prescribed back when this notation was defined (see
section~\ref{sec:notabrev}). Command
\C{Lemma}, just like \C{Definition}, allows for
dropping the type annotations of parameters if these types can be
inferred from the statement itself:

\begin{coq}{name=addnA2}{}
Lemma addnA n m k : m + (n + k) = m + n + k.
\end{coq}
\coqrun{name=testaddndA2}{ssr,addnA2,abort}

Boolean identities play a central role in the \mcbMC{} library. They
state equalities between boolean expressions (possibly with parameters).
For
instance, the~\C{orbT} statement expresses that \C{true} is right absorbing
for the boolean disjunction operation \C{orb}. Recall from
section~\ref{ssec:boolval} that \C{orb} is equipped with the \C{||}
infix notation:

\begin{coq}{name=orbT}{}
Lemma orbT b : b || true = true.
\end{coq}
\coqrun{name=testorbT}{ssr,orbT,abort}

More precisely, lemma \C{orbT}
expresses that the truth table of the boolean formula \C{(b || true)}
coincides with the (constant) one of \C{true}: otherwise said, that the
two propositional formulas are equivalent, or that \C{(b || true)} is a
propositional tautology. Below, we provide some other examples of such
propositional equivalences stated as boolean identities.

\begin{coq}{name=orbA}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
\end{coq}
\coqrun{name=testorbA}{ssr,orbA,abort,abort,abort}
Proving these identities (once we have learnt to provide proofs)
% [DG] Many readers would interpret "is left as an exercise" as an
% invitation to solve the exercise right now; but this isn't possible
% yet.
is left as an exercise (see
exercise~\ref{ex:boolid}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{From boolean predicates to formal statements}
\label{sec:bstatements}

A \emph{boolean predicate} means a function to \C{bool}. A boolean
predicate can indeed be seen as an effective truth table, which can be
used to form a proposition in a systematic way by equating its result
to \C{true}. More generally, boolean identities are equality statements
in type \C{bool}, which may involve arbitrary boolean predicates and boolean
connectives. They can feature variables of an arbitrary
type, not only of type \C{bool}.

For instance, the boolean comparison function
\C{(leq : nat -> nat -> bool)} is a boolean binary predicate on
natural numbers. Lemma \C{leq0n} is a proposition asserting that a
certain comparison always holds, by stating that the truth value of
the boolean \C{(0 <= n)} is \C{true}, whatever term  of type \C{nat}
is substituted for the parameter \C{n}.

\begin{coq}{name=leq0n}{title=Stating that a boolean predicate holds}
Lemma leq0n (n : nat) : 0 <= n = true.
\end{coq}
\coqrun{name=testleq0n}{ssr,leq0n,abort}

The \mcbMC{} library makes an extensive use of boolean predicates, and
of the associated propositions. For the sake of readability, the
default behavior of the  \mcbMC{} library is to omit the ``\C{.. = true}''
part in these boolean identities. \Coq{} is actually able to insert
automatically and silently this missing piece whenever it fits and
is non-ambiguous, thanks to its \emph{coercion} mechanism. We
postpone further explanation of this mechanism to
section~\ref{sec:coercions}, but from now on, we stop displaying the
\C{.. = true} parts of the statement that are silently inserted this
way. For instance, lemma \C{leq0n} is displayed as:

\begin{coq}{name=coercion}{}
Lemma leq0n (n : nat) : 0 <= n.
\end{coq}
\coqrun{name=testcoercion}{ssr,coercion,abort}
% [DG] Here at the latest, I believe the difference between "=" and
% "==" should be explained; anything else would confuse the reader
% if she is not already familiar with the difference between
% booleans and propositions (which ssreflect seems to blur, but which
% is still important to understand).

As a general fact, boolean identities express that two boolean
statements are equivalent. We already encountered special cases of
such equivalence with propositional tautologies in
section~\ref{ssec:id}. Here are a few more examples involving
boolean predicates on natural numbers that we have defined in
chapter~\ref{ch:prog}: the boolean equality \C{==} and its negation
\C{!=}, the order relation \C{<} and its large version \C{<=}, and the
divisibility predicate \L+%|+, with \L+(a %| b)+
meaning \C{a} \emph{divides} \C{b}.
Note that we omit the type of the parameters; they are all of type
\C{nat}, as enforced by the type of the operators involved in the
statements:

\begin{coq}{name=equivalences}{}
Lemma eqn_leq m n : (m == n) = (m <= n) && (n <= m).
Lemma neq_ltn m n : (m != n) = (m < n) || (n < m).
Lemma leqn0 n : (n <= 0) = (n == 0).
Lemma dvdn1 d : (d %| 1) = (d == 1).
Lemma odd_mul m n : odd (m * n) = odd m && odd n.
\end{coq}
\coqrun{name=testeq}{ssr,equivalences,abort,abort,abort,abort,abort}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conditional statements}

In the previous sections, we have seen statements of unconditional
identities: either equalities between ground terms, or identities that
hold for \emph{any} value of their parameters. A property that holds
only when its parameters satisfy some condition is stated using an
% [DG] Standard French abuse of "verify" for "satisfy" corrected.
% Also, passive voice isn't necessary here.
\emph{implication}, and the \Coq{} syntax for this connective
is ``\C{->}''.  For instance:

\begin{coq}{name=implication}{title=Implication}
Lemma leq_pmull m n : n > 0 -> m <= n * m.
Lemma odd_gt0 n : odd n -> n > 0.
\end{coq}
\coqrun{name=testimpl}{ssr,implication,abort,abort}

This arrow \C{->} is the
same as the one we have used in chapter~\ref{ch:prog} in order to
represent function types. This is no accident, but we postpone further
comments on the meaning of this arrow to section~\ref{sec:chi}. For
now let us only stress that \C{->} is right-associative, and
therefore
a succession of arrows expresses a conjunction of conditions:

\begin{coq}{name=dvdn-mul}{}
Lemma dvdn_mul d1 d2 m1 m2 : d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2.
\end{coq}
\coqrun{name=testdvdn}{ssr,dvdn-mul,abort}
Replacing conjunctions of hypotheses by a succession of implications is
akin to replacing a function taking a tuple of arguments by a function
with a functional type (``currying''),
as described in section~\ref{sec:fun-sev-args}.

% Yet beware, all the parameters are then fixed
% inside the section (as well as hypotheses but that's less often
% problematic). However we cannot really make sense from this remark as
% long as we do not explain formal proofs in more details...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEARN{Commands to build and check formal proofs: trivial ones,
  case analysis, rewriting}
\mcbREQUIRE{computation, equality}
\mcbPROVIDE{eq, is-true, \C{rewrite, case, by []}}
\mcbLEVEL{1}
\mcbsection{Formal proofs}
\index[concept]{formal proof}

We shall now explain how to turn a well-formed statement into a
machine-checked theorem. Let us come back to our first example, that
we left unproved:
\begin{coq}{name=my-first-proof1}{}
Lemma my_first_lemma : 3 = 3.
Proof.
Admitted.
\end{coq}
\coqrun{name=testm1l}{ssr,my-first-proof1}
In the \Coq{} system, the user builds a formal proof by providing,
interactively, instructions to the \Coq{}
system that describe the gradual construction of the proof she has in
mind. This list of instructions is called a \emph{proof script}, and
the instructions it is made of are called proof commands, or more traditionally
\emph{tactics}.  The language of tactic we use is called
Ssreflect.

\begin{coq}{name=my-first-proof3}{title=Scheme of a complete proof}
Lemma my_first_lemma : 3 = 3.
Proof.
(* your finished proof script comes here *)
Qed.
\end{coq}
\coqrun{name=testm2l;fail}{ssr,my-first-proof3}

Once the proof is complete, we can replace the \C{Admitted} command by
the \C{Qed} one. This command calls the proof checker part of  the \Coq{}
system, which validates a posteriori that the formal proof that has
been built so far is actually a complete and correct proof of the
statement, here \C{3 = 3}.

In this section, we will review different kinds of proof steps and
the corresponding tactics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Proofs by computation}\label{ssec:proofcomp}
\index[concept]{computation}

Here is now a proof script that validates the statement $3 = 3$.

\begin{coqdef}{name=my-first-proof4}
Lemma my_first_lemma : 3 = 3.
Proof.
\end{coqdef}
\begin{coq}{def=my-first-proof4,done}{width=7cm,title=Reflexivity of equality}
Lemma my_first_lemma : 3 = 3.
Proof. by [].
\end{coq}
\coqrun{name=firstp4}{ssr,my-first-proof4,verbose,done,abort}
\begin{coqout}{run=firstp4}{width=5cm,title=Proof finished}
No more subgoals.
$~$
\end{coqout}
\index[ssr]{\C{by []}}

Indeed, this statement holds trivially, because the two sides of
the equality are syntactically the same. The tactic ``\C{by []}'' is
the command that
implements this nature of \emph{trivial} proof step. The proof command
\C{by} typically prefixes another tactic (or a list thereof): it is
a \emph{tactical}. The \C{by} prefix checks that the following tactic
trivializes the goal. But in our case, no extra work is needed to
solve the goal, so we pass an empty list of tactics to the tactical
\C{by}, represented by the empty bracket \C{[]}.


The system then informs the user that the proof looks complete. We can hence
confidently conclude our first proof by the \C{Qed} command:

\begin{coqdef}{name=about1}About my_first_lemma.\end{coqdef}
\begin{coq}{def=my-first-proof4,done,qed,about1}{width=6cm}
Lemma my_first_lemma : 3 = 3.
Proof. by []. Qed.
About my_first_lemma.
\end{coq}
\coqrun{name=firstp5}{ssr,my-first-proof4,verbose,done,qed,about1}
\begin{coqout}{run=firstp5;dots}{width=6cm}
No more subgoals.
my_first_lemma is defined
my_first_lemma : 3 = 3
\end{coqout}

Just like when it was \C{Admitted}, this script results in a new definition
being
added in our context, which can then be reused in future proofs under
the name \C{my_first_lemma}.
Except that this time we have \emph{a machine checked proof} of
the statement of \C{my_first_lemma}.  By contrast
\C{Admitted} happily accepts false statements\dots
\index[concept]{machine checked proof}

What makes the \C{by []}  tactic interesting is that it
can be used not only when both
sides of an equality coincide syntactically, but also when they are
equal \emph{modulo the evaluation of programs} used in the formal
sentence to be proved.
For instance, let us prove that $2 + 1 = 3$.

\begin{coqdef}{name=secondp}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by [].
\end{coqdef}
\begin{coq}{def=secondp,qed}{}
Lemma my_second_lemma : 2 + 1 = 3.
Proof. by []. Qed.
\end{coq}
\coqrun{name=secondp}{ssr,secondp,verbose,qed}

Indeed, this statement holds because the two sides of the equality
are the same, once the definition of the \C{addn} function, hidden
behind the infix \C{+} notation, is unfolded, and once the calculation
is performed. In a similar way, we can prove the statement
\C{(0 <= 1)}, or \C{(odd 5)}, because both expressions \emph{compute} to
\C{true}.

As we have seen in chapter~\ref{ch:prog}, computation is not limited
to ground terms; it is really about using the rules of the pattern
matching describing the code of the function. For instance the proof
of the \C{addSn} identity:

\begin{coq}{name=addSn}{title=Reflexivity by symbolic computation}
Lemma addSn m n : m.+1 + n = (m + n).+1. Proof. by []. Qed.
\end{coq}
\coqrun{name=testaddSn}{ssr,addSn}
\index[coq]{\C{addSn}}
is trivial as well because it is a direct consequence of the
definition of the \C{addn} function: This function is defined by
pattern matching, with one of the branches stating exactly this
identity. Statements like
\C{(0 + n = n)} or \C{(0 < n.+1)} can be proved in a similar way, but
also \C{(2 + n = n.+2)}, which requires several steps of computation.

Last, the \C{by} tactical turns its argument into a \emph{terminating
tactic} --- and thus  \C{by []} is such a terminating tactic. A tactic
is said to be terminating if, whenever it does not solve the goal
completely, it
fails and stops \Coq{} from processing the proof script.
A terminating tactic is colored in red so that
the eye can immediately spot that a
proof, or more commonly a subproof, ends there.
\index[concept]{terminating tactic}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Case analysis}\label{ssec:case}
\index[concept]{case analysis}
%assia : I do not remember why the \C macro does not work here, seems
%to be a problem with ~~...
Let us now consider the tautology~\L+~~ (~~ b) = b+. The
``proof by computation'' technique of section~\ref{ssec:proofcomp}
fails in this case:

\begin{coqdef}{name=negbK}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof.
\end{coqdef}
\begin{coq}{def=negbK,done}{width=7cm,title=Double negation elimination}
Lemma negbK (b : bool) : ~~ (~~ b) = b.
Proof. by [].
\end{coq}
\coqrun{name=negbKerr;fail}{ssr,negbK,done}
\begin{coqout}{run=negbKerr}{width=5cm, title=Failing proof script}
Error: No applicable
tactic.
\end{coqout}
\index[coq]{\C{negbK}}

Indeed, proving this identity requires more than a simple unfolding of
the definition of \C{negb}:

\begin{coq}{name=negb}{}
Definition negb (b : bool) : bool := if b then false else true.
\end{coq}
\coqrun{name=testnegb}{ssr,negb}
One also needs to perform a \emph{case analysis} on the boolean value
of the parameter \C{b} and notice that the two sides coincide in
both cases. The tactic \C{case} implements this action:

\begin{coqdef}{name=negbkt2}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
\end{coqdef}
\coqrun{name=negbkt2}{ssr,negbkt2,show1,done,show2,verbose,done,qed}
\begin{coq}{def=negbkt2}{width=6cm,title=Reasoning by cases}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
$~$
$~$
$~$
\end{coq}
\begin{coqout}{run=negbkt2;out=g1}{width=6cm, title=Case analysis}
2 subgoals

  ============================
   ~~ ~~ true = true
subgoal 2 is:
 ~~ ~~ false = false
\end{coqout}
\index[ssr]{\C{case: name}}

More precisely, the tactic ``\C{case: b}'' indicates that we want to
perform a case analysis on term \C{b}, whose
name follows the separator \C{:}. The \Coq{} system displays the state
of the proof after this command: The proof now has two subcases,
treated in two parallel branches, one in which the parameter \C{b}
takes the value \C{true} and one in which the parameter \C{b} takes
the value \C{false}. More generally, the \C{case: t} tactic performs a
case analysis on (the shape of) a term \C{t} which should be of an
inductive type. As any inhabitant of an inductive type is necessarily
built from one of its constructors, this tactic creates as many
branches in the proof as the type has constructors, in the order in
which they appear in the definition of the type. In our example, the
branch for \C{true} comes first, because this constructor comes first
in the definition of type \C{bool}.

We shall thus provide two distinct pieces of
script, one per each subproof to be constructed,
starting with the branch associated with the \C{true} value. In order
to signal that we are starting a piece of script for a sub-proof, it
is a good practice to indent the corresponding script.\footnote{A
``sub-proof'' means a proof of a sub-goal; i.e., a proof whose
completion does not immediately conclude the proof of the lemma. Thus,
for example, if the \C{case:} tactic splits a proof into two goals,
then only the first case (i.e., the proof of the first of these goals)
counts as a sub-proof. The second case is not a sub-proof (as it
concludes the proof of the lemma), and thus is not indented.}
% [DG] Added this boring technical footnote, as this is guaranteed to
% confuse mathematicians.

Once the case analysis has substituted a concrete value for the
parameter \C{b}, the proof becomes trivial, in both cases: We are in a
similar situation as in the proofs of section~\ref{ssec:proofcomp} and
the tactic \C{by []} applies successfully:

\begin{coq}{def=negbkt2,done}{width=6cm,title=First trivial case}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
\end{coq}
\begin{coqout}{run=negbkt2;out=g2}{width=6cm, title=Second goal}
1 subgoal

 ============================
   ~~ ~~ false = false
\end{coqout}

Once the first goal is solved, we have only one subgoal left, and
we solve it using the same tactic.

\begin{coq}{def=negbkt2,done,done,qed}{width=6cm,title=Second trivial case}
Lemma negbK b : ~~ (~~ b) = b.
Proof.
case: b.
  by [].
by [].
Qed.
\end{coq}
\begin{coqout}{run=negbkt2}{width=6cm, title=Finished proof}
No more subgoals.
negbK is defined
$~$
$~$
$~$
$~$
\end{coqout}

Yet, as we mentioned earlier, we can also use the \C{by} tactical as a
prefix for any tactic (not just an empty list of tactics),
and have the system check that after the
\C{case} tactic, the proof actually becomes trivial, in both branches
of the case analysis. This way, the proof script becomes a one-liner:

\begin{coq}{name=negbkt3}{title=Double negation elimination: final script}
Lemma negbK b : ~~ (~~ b) = b.
Proof. by case: b. Qed.
\end{coq}
\coqrun{name=negbkt3run}{ssr,negbkt3}

\subsubsection{Case analysis with naming}
\index[concept]{case analysis!naming}

The boolean equivalence \C{leqn0} is another example of statement that
cannot be proved by computation only:

\begin{coq}{name=leqn0}{width=7cm}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
\end{coq}
\begin{coqout}{run=leqn0run1;stod}{width=5cm}
n : nat
=====================
  (n <= 0) = (n == 0)
\end{coqout}
\coqrun{name=leqn0run1}{ssr,leqn0,show,abort}
\index[coq]{\C{leqn0}}

Both comparison operations \C{<=} and \C{==} are defined by case
analysis on their \emph{first} argument, independently of the shape of
the second. The proof of \C{leq0n} thus goes by case analysis on
 term \C{(n : nat)}, as it appears as a first argument to
both these comparison operators.  Remember that the inductive type \C{nat} is
defined as:

\begin{coq}{name=natdef}{}
Inductive nat := O | S (n : nat).
\end{coq}
\coqrun{name=natdefrun}{natdef}
with two constructors, \C{O} which has no argument and \C{S} which has
one (recursive) argument. A case analysis on term \C{(n : nat)} thus
has two branches: one in which \C{n} is \C{0} and one in which \C{n} is
\C{(S k)}, denoted \C{k.+1}, for some \C{(k : nat)}. We hence need a
variant of the \C{case} tactic, in order to \emph{name} the parameter
\C{k} that pops up in the second branch as the argument of the \C{S}
constructor of type \C{nat}:

\begin{coq}{name=leqn01}{width=7cm,title=case with naming}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
$~$
$~$
\end{coq}
\begin{coqout}{run=leqn01run}{width=5cm}
2 subgoals

======================
  (0 <= 0) = (0 == 0)

subgoal 2 is:
 (k < 0) = (k.+1 == 0)
\end{coqout}
\coqrun{name=leqn01run}{ssr,leqn01,show,abort}

The tactic ``\C{case: n => [|k]}''  can be decomposed into two components,
separated by the arrow \C{=>}.  The left block ``\C{case: n}'' indicates
that we  perform a case analysis action, on term \C{(n : nat)}, while the right
block ``\C{[|k]}'' is an \emph{introduction pattern}. The brackets
surround slots separated by vertical pipes, and each slot allows to
name the parameters to be introduced in each subgoal created by the
case analysis, in order.

As type \C{nat} has two constructors, the introduction pattern \C{[|k]}
of our case analysis command uses two slots: the last one introduces
the name \C{k} in the second subgoal and the first one is
empty. Indeed, in the first subgoal (first branch of the case
analysis), \C{n} is substituted with \C{0}. In the second one, we can
observe that \C{n} has been substituted with \C{k.+1}.
As hinted in the first chapter, the term \C{(k.+1 <= 0)}
is displayed as \C{(k < 0)}.

The first goal
can be easily solved by computation, as both sides of the equality
evaluate to \C{true}.

\begin{coq}{def=leqn01,done}{width=7cm}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.
case: n => [| k].
  by [].
\end{coq}
\begin{coqout}{run=leqn02;stod}{width=5cm}
k : nat
=========================
  (k < 0) = (k.+1 == 0)
\end{coqout}
\coqrun{name=leqn02}{ssr,leqn01,done,show,abort}
\index[ssr]{\C{case: name => [$\mid$m]}}
The second and now only remaining goal corresponds to the case when
\C{n} is the successor of \C{k}. Note that \C{(k < 0)} is a
superseding notation for \C{(k.+1 <= 0)}, as mentioned in section
\ref{sec:notabrev}. This goal can also be  solved by computation, as
both sides of the equality evaluate to \C{false}.  The final
proof script is hence:

\begin{coq}{name=leqn04}{}
Lemma leqn0 n : (n <= 0) = (n == 0).
Proof.  by case: n => [| k].  Qed.
\end{coq}
\coqrun{name=leqn04run}{ssr,leqn04}
~\\

We will use a last example of boolean equivalence to introduce more
advanced proof techniques, leading to less verbose proof
scripts. Remember from chapter~\ref{ch:prog} that the product of two
natural numbers is defined as a function
\C{(muln : nat -> nat -> nat)}. From this definition, we prove that
the product of two (natural) numbers is zero if and only if one of the
numbers is zero:

\begin{coq}{name=almostMulnEq0}{title=Specifying muln: a double case analysis attempt}
Fixpoint muln (m n : nat) : nat :=
  if m is p.+1 then n + muln p n else 0.

Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
\end{coq}
\coqrun{name=muln1run}{ssr,almostMulnEq0,abort}
\index[coq]{\C{muln_eq0}}
\index[coq]{\C{muln}}
In the case when \C{m} is zero (whatever value \C{n} takes), both
sides of the equality evaluate to \C{true}: the left hand side is
equal modulo computation to \C{(0 == 0)}, which itself computes to
\C{true}, and the right hand side is equal modulo computation to
\C{((0 == 0) || (n == 0))}, hence to \C{(true || (n == 0))} and finally to
\C{true} because the boolean disjunction \C{(_ || _)} is defined by
case analysis on its first argument.
%\marginnote{We did not show the definition of orb.}

\begin{coq}{name=mulneq0}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
\end{coq}
\begin{coqout}{run=mulneq0run;stod}{width=5cm,title=One goal left}
n, m : nat
=========================
(m.+1 * n == 0) =
  (m.+1 == 0) || (n == 0)
\end{coqout}
\coqrun{name=mulneq0run}{ssr,mulneq0,show,abort}
In this script, we used the name \C{m} for the argument of the
constructor in the second branch of the case analysis. There is no
ambiguity here and this proof step reads: either \C{m} is zero, or it
is of the form \C{m.+1} (for a new \C{m}).

By default, the successor case is treated in the second subgoal,
according to the order of constructors in the definition of type
\C{nat}. If we want to treat it first, we can use the ``\C{; last
  first}'' tactic suffix:
\index[ssr]{\C{last first}}\index[concept]{reordering goals}

\begin{coq}{name=mulneq01}{}
Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
\end{coq}
\begin{coqout}{run=mulneq01run}{title=Two goals left (in reverse order)}
2 subgoals

m, k : nat
============================
(m.+1 * k.+1 == 0) = (m.+1 == 0) || (k.+1 == 0)

subgoal 2 is:
 (m.+1 * 0 == 0) = (m.+1 == 0) || (0 == 0)
\end{coqout}
\coqrun{name=mulneq01run}{ssr,mulneq01,show,abort}
Indeed it is a good practice to get rid of the easiest subgoals as
early as possible. And here the successor case is such an easy
subgoal: when \C{n} is of the form \C{k.+1}, it is easy to see that the
right hand side of the equality evaluates to \C{false}, as both
arguments of the boolean disjunction do. Now the left hand side
evaluates to \C{false} too: by the definition of \C{muln}, the term
\C{(m.+1 * k.+1)} evaluates to \C{(k.+1 + (m * k.+1))}, and by
definition of the addition \C{addn}, this in turn reduces to
\C{(k + (m * k.+1)).+1}. The left hand side term hence is of the form
\C{t.+1 == 0}, where \C{t} stands for \C{(k + (m * k.+1))}, and this
reduces to \C{false}.\label{proof:mulneq0}
In consequence, the successor branch of the case analysis is trivial
by computation.


\begin{coq}{name=mulneq02}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m].
  by [].
case: n => [|k]; last first.
  by [].
\end{coq}
\begin{coqout}{run=mulneq02run}{width=5cm}
1 subgoal

m : nat
=========================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
\coqrun{name=mulneq02run}{ssr,mulneq02,show,abort}
%\marginnote{We should make the remark somewhere explicitly that reflexivity for 0 or successor or any closed values is by computation but not reflexivity for a variable.}

This proof script can actually be made more compact and, more
importantly, more linear by using extra features of the introduction
patterns. It is indeed possible, although optional, to
inspect the subgoals created by a case analysis and to solve the
trivial ones on the fly, as the \C{by []} tactic would do, except that
in this case no failure happens in the case some, or even all,
subgoals remain. For instance in our case,
we can add the optional \C{//} \emph{simplify} switch to the
introduction pattern of the first case analysis:

\begin{coq}{name=mulneq03}{title=A simplify intro pattern,width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
\end{coq}
\begin{coqout}{run=mulneq03run;stod}{title=Proof state,width=5cm}
n, m : nat
=========================
(m.+1 * n == 0) =
  (m.+1 == 0) || (n == 0)
\end{coqout}
\coqrun{name=mulneq03run}{ssr,mulneq03,show,abort}

Only the first generated subgoal is trivial: Thus, it has been closed
and we are left with the second one. Similarly, we can get rid of the
second goal produced by the case analysis on \C{n}:

\begin{coq}{name=mulneq04}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{run=mulneq04run;stod}{width=5cm}
m : nat
=========================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
\coqrun{name=mulneq04run}{ssr,mulneq04,show,abort}

% We will see in section~\ref{} that
This \C{//} switch can be used in
more general contexts than just this special case of introduction patterns:
It can actually punctuate more complex combinations of tactics,
avoiding spurious branching in proofs in a similar
manner~\cite[section 5.4]{ssrman}.

The last remaining goal cannot be solved by computation.
The right hand side evaluates to
\C{true}, as the left argument of the disjunction is \C{false} (modulo
computation) and the right one is \C{true}. However, we need
more than symbolic computation to show that the left hand side is
\C{true} as well: the fact that \C{0} is a right absorbing element for
multiplication indeed requires reasoning by \emph{induction}
(see section~\ref{ssec:ind}).

To conclude the proof we need one more proof command, the
\C{rewrite} tactic, that lets us appeal to an already existing lemma.

% section~\ref{ssec:rw} explains how to complete this proof.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rewriting}\label{ssec:rw}

This section explains how to locally replace certain
subterms of a goal with other terms during the course of a formal
proof. In other words, we explain how to perform a
\emph{rewrite} proof step, thanks to the eponymous \C{rewrite} tactic.
Such a replacement is licit when the original subterm is equal
to the final one, up to computation or because of a proved
identity. The \C{rewrite} tactic comes with several options for
an accurate specification of the operation to be performed.

Let us start with a simple example and come back to the proof that we
left unfinished at the end of the previous section:

\begin{coq}{name=mulneq05}{width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
\end{coq}
\begin{coqout}{run=mulneq05run;stod}{width=5cm}
m : nat
=======================
(m.+1 * 0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
\coqrun{name=mulneq05run}{ssr,mulneq05,show,abort}
At this stage, if we replace subterm \C{(m.+1 * 0)} by \C{0}, the
subgoal becomes:

\begin{coq}{name=mulneq05bis}{}
(0 == 0) = (m.+1 == 0) || (0 == 0)
\end{coq}
which is equal modulo computation to \C{(true = true)}, hence trivial.
But since
the definition of \C{muln} proceeded by pattern matching on its \emph{first}
argument, \C{(m.+1 * 0)} does not evaluate symbolically to \C{0}: This
equality holds but requires a proof by induction, as explained in
section~\ref{ssec:ind}.
For now, let us instead derive \C{(m.+1 * 0 = 0)} from a lemma.
Indeed, the \mcbMC{} library provides a systematic review of the
properties of the operations it defines. The lemma we need is
available in the library as:

\begin{coq}{name=muln0}{}
Lemma muln0 n : n * 0 = 0.
\end{coq}
\coqrun{name=muln0run}{ssr,muln0,abort}
%\marginnote{But this is not the way lemma \C{muln0} is stated in the library...}

As a side remark, being able to find the ``right'' lemma is of
paramount importance for writing modular libraries of formal
proofs. See section~\ref{sec:search} which is dedicated to this topic.

Back to our example, we use the \C{rewrite} tactic with lemma
\C{muln0}, in order to perform the desired replacement.

\begin{coq}{name=mulneq06}{title=First rewrite,width=7cm}
Lemma muln_eq0 m n :
  (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
rewrite muln0.
\end{coq}
\begin{coqout}{run=mulneq06run;stod}{title=Proof state,width=5cm}
m : nat
=======================
(0 == 0) =
  (m.+1 == 0) || (0 == 0)
\end{coqout}
\coqrun{name=mulneq06run}{ssr,mulneq06,show,abort}
\index[ssr]{\C{rewrite}}

The \C{rewrite} tactic uses the \C{muln0} lemma in the following way:
It replaces an instance of the left hand side of this identity with the
corresponding instance of the right hand side. The left hand side of
\C{muln0} can be read as a \emph{pattern} \C{(_ * 0)}, where \C{_}
denotes a wildcard: The identity is
valid for any value of its parameter \C{n}. The tactic
automatically  finds  where in the goal the replacement should take
place, by searching for a subterm matching the pattern \C{(_ * 0)}.
In the present case, there is only one such subterm,
\C{(m.+1 * 0)}, for which the parameter (or the wild-card) takes the
value \C{m.+1}. This subterm is hence replaced by \C{0}, the right
hand side of \C{muln0}, which does not depend on the value of the
pattern. We can now conclude the proof script, using the
prenex \C{by} tactical\footnote{Passing a single tactic to
\C{by} requires no brackets; i.e., we can write
\C{by rewrite muln0} instead of \C{by [rewrite muln0]}.}:
\index[concept]{pattern}
\index[concept]{rewriting}

\begin{coq}{name=mulneq07}{}
Lemma muln_eq0 m n : (m * n == 0) = (m == 0) || (n == 0).
Proof.
case: m => [|m] //.
case: n => [|k] //.
by rewrite muln0.
Qed.
\end{coq}
\coqrun{name=mulneq07run}{ssr,mulneq07}

Arguments to the \C{rewrite} tactic are typically called
\emph{rewrite rules}\index[concept]{rewrite rule} and can
be prefixed by flags tuning the behavior of the tactic.

% Patterns are more generally useful both for subterm selection (in
% proof mode) and for searching existing results in the current context.
% This is the purpose of the \C{Search} command, which can for instance
% be used to (FIND AN EXAMPLE WHICH IS NOT muln0...)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rewriting many identities in one go}
\label{sec:multirew}

The boolean identity \C{muln_eq0} that we just established expresses a
logical equivalence that can in turn be used in proofs via the
\C{rewrite} tactic. For instance, let us consider the case of lemma
\C{leq_mul2l}, which provides a necessary and sufficient condition
for the comparison \C{(m * n1 <= m * n2)} to hold:

\begin{coq}{name=LeqMul2l}{title=Another example: product vs. order}
Lemma leq_mul2l m n1 n2 : (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
\end{coq}
\coqrun{name=LeqMul2lrun}{ssr,LeqMul2l,abort}

The proof goes as follows: The left
hand side can equivalently be written as \C{(m * n1 - m * n2 == 0)}, which
factors into \C{(m * (n1 - n2) == 0)}. But this is equivalent to one
of the arguments of the product being zero. And \C{(n1 - n2 == 0)}
means \C{(n1 <= n2)}.

The first step is performed using the following equation:

\begin{coq}{name=LeqDef}{}
Lemma leqE m n : (m <= n) = (m - n == 0).
Proof. by []. Qed.
\end{coq}
\coqrun{name=LeqDefrun}{ssr,LeqDef}

The proof of this identity is trivial, as the right hand side is the
definition of the \C{leq} relation, denoted by the \C{<=} infix
notation. Rewriting with this equation turns the left hand side of our
goal into a subtraction:

\begin{coqdef}{name=rew1}rewrite leqE.\end{coqdef}
\begin{coq}{def=LeqMul2l,proof,rew1}{title=Unfolding leq,width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite leqE.
\end{coq}
\begin{coqout}{run=LeqMul2lproof1run;stod}{title=Proof state,width=5.5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 <= n2)
\end{coqout}
\coqrun{name=LeqMul2lproof1run}{ssr,LeqDef,LeqMul2l,proof,rew1,show,abort}

The command \C{rewrite leqE} only affects the first
occurrence of \C{<=}, but we would like to substitute both. In order to
rewrite \emph{all} the possible instances of the rule in the goal, we
may use a repetition flag, which is \C{!}:

\begin{coqdef}{name=rew2}rewrite !leqE.\end{coqdef}
\begin{coq}{def=LeqMul2l,proof,rew2}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE.
\end{coq}
\begin{coqout}{run=LeqMul2lproof2run;stod}{width=5.5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=LeqMul2lproof2run}{ssr,LeqDef,LeqMul2l,proof,rew2,show,abort}
\index[ssr]{\C{rewrite}! "! (iteration)}

Now the definition of \C{<=} has been exposed
\emph{everywhere} in the goal, i.e., at both its occurrences in the
initial goal. We can now factor out \C{m} on the left, according to the
appropriate distributivity property:

\begin{coq}{name=mulnBr}{}
Lemma mulnBr n m p : n * (m - p) = n * m - n * p.
\end{coq}
\coqrun{name=mulnBr}{ssr,mulnBr,abort}

This time we need to perform a right-to-left rewriting of the
\C{mulnBr} lemma (instead of the
default left-to-right). The rewriting step first finds in the goal an
instance of pattern \C{(_ * _ - _ * _)}, where the terms matched by
the first and the third wildcards coincide. The syntax for
right-to-left rewriting consists in prefixing the
name of the rewrite rule
with a minus \C{-}:


\begin{coqdef}{name=rew3}rewrite !leqE. rewrite -mulnBr.\end{coqdef}
\begin{coq}{def=LeqMul2l,proof,rew3}{title=Rewrite right-to-left,width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE. rewrite -mulnBr.
\end{coq}
\begin{coqout}{run=LeqMul2lproof2run1;stod}{title=Proof state,width=5.5cm}
m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=LeqMul2lproof2run1}{ssr,LeqDef,LeqMul2l,proof,rew3,show,abort}
\index[ssr]{\C{rewrite}! \C{-} (right-to-left)}
Consecutive rewrite steps can be chained as follows:

\begin{coqdef}{name=rew4}rewrite !leqE -mulnBr.\end{coqdef}
\begin{coq}{def=LeqMul2l,proof,rew4}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE -mulnBr.
\end{coq}
\begin{coqout}{run=LeqMul2lproof2run2;stod}{width=5.5cm}
m, n1, n2 : nat
==========================
(m * (n1 - n2) == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=LeqMul2lproof2run2}{ssr,LeqDef,LeqMul2l,proof,rew4,show,abort}
\index[ssr]{\C{rewrite}! \C{-} (right-to-left)}
The last step of the proof uses lemma \C{muln_eq0} to align the left
and the right hand sides of the identity.


\begin{coqdef}{name=rew5}rewrite !leqE -mulnBr muln_eq0.\end{coqdef}
\begin{coq}{def=LeqMul2l,proof,rew5}{width=6.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || ...
Proof.
rewrite !leqE -mulnBr muln_eq0.
\end{coq}
\begin{coqout}{run=LeqMul2lproof3run;stod}{width=5.5cm}
m, n1, n2 : nat
==========================
(m == 0) || (n1 - n2 == 0) =
  (m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=LeqMul2lproof3run}{ssr,LeqDef,LeqMul2l,proof,rew5,show,abort}

The proof can now be completed by prefixing the tactic with the
\C{by} tactical.

We only provided here some hints on the basic features of the \C{rewrite}
tactic. Section~\ref{sec:rewrite2} gives more details on the matching
algorithm and on the flags supported by \C{rewrite}. The complete
description of the features of this tactic is found
in the manual~\cite{ssrman}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{More complex statements and proofs}
\mcbLEVEL{1}
\mcbsection{Quantifiers}

\subsection{Universal quantification, first examples}

Let us compare an example of a function we defined in
chapter~\ref{ch:prog}:

\begin{coq}{name=leqn}{}
Definition leq n m := m - n == 0.
\end{coq}
\coqrun{name=leqdeftest}{ssr,leqn}
with an example of a parametric statement we have used in the present
chapter:

\begin{coq}{name=leqn0x}{}
Lemma leqn0 n : (n <= 0) = (n == 0).
\end{coq}
\coqrun{name=leqn0xrun}{ssr,leqn0x,abort}

We recall, as seen in chapter~\ref{ch:prog}, that this concise syntax
for defining \C{leq} stands for:

\begin{coq}{name=LeqDefFun}{}
Definition leq := fun (n m : nat) => m - n == 0.
\end{coq}
\coqrun{name=leqdeftest2}{ssr,LeqDefFun}

and that the type of the constant \C{leq} is:

\begin{coq}{name=about-leq}{width=6cm}
About leq.
\end{coq}
\begin{coqout}{run=about;dots}{width=6cm}
leq : nat -> nat -> bool
\end{coqout}
\coqrun{name=about}{ssr,about-leq}

The curious reader might already have tested the answer of the
\C{About} command on some parametric lemmas:

\begin{coq}{name=negbktAbout}{width=5cm,title=Inspecting lemma leqn0}
About leqn0.
\end{coq}
\begin{coqout}{run=aboutleq;dots}{width=7cm, title=Universal quantification}
leqn0 : forall n : nat, (n <= 0) = (n == 0)
\end{coqout}
\coqrun{name=aboutleq}{ssr,negbktAbout}

She has thus observed that \Coq{}'s output features a prenex
\C{forall} quantifier. This universal quantifier binds a natural number, and
expresses --- as expected --- that the equation holds for \emph{any}
natural number. In fact, the types of the lemmas and theorems with
parameters all feature prenex universal quantifiers:

\begin{coq}{name=aboutmulneq0}{width=4cm}
About muln_eq0.
$~$
\end{coq}
\begin{coqout}{run=aboutmulneq0run;dots}{width=8cm}
muln_eq0 : forall m n : nat,
  (m * n == 0) = (m == 0) || (n == 0)
\end{coqout}
\coqrun{name=aboutmulneq0run}{ssr,aboutmulneq0}
Quantifiers may also occur elsewhere in a statement, and not only in
prenex position.  In the following example, we use the function
\C{nth}, extracting the element of a sequence at a given position, which was
the object of exercise~\ref{ex:nth}. This statement expresses that two
sequences with the same size and whose $n$-th elements coincide for any
$n$ are the same. The second hypothesis, about the elements, is
itself a quantified formula:

\begin{coq}{name=seqext}{}
Lemma seq_eq_ext (s1 s2 : seq nat) :
  size s1 = size s2 ->
  (forall i : nat, nth 0 s1 i = nth 0 s2 i) ->
  s1 = s2.
\end{coq}
\coqrun{name=testseqext}{ssr,seqext,abort}
Quantifiers are also allowed to range over functions:

\begin{coq}{name=sizemap1}{}
Lemma size_map (T1 T2 : Type) :
  forall (f : T1 -> T2) (s : seq T1), size (map f s) = size s.
\end{coq}
\coqrun{name=testsm1}{ssr,sizemap1,abort}
Observe that in the above statement of \C{size_map}, we have used a
compact notation for successive universal quantifications:
``\C{forall (f : T1 -> T2) (s : seq T1), ...}'' is syntactic sugar for
``\C{forall f : T1 -> T2, forall s : seq T1, ...}''. However, in this case
of prenex quantification, we could just as well write:

\begin{coq}{name=sizemap2}{}
Lemma size_map (T1 T2 : Type) (f : T1 -> T2) (s : seq T1) :
  size (map f s) = size s.
\end{coq}
\coqrun{name=testsm2}{ssr,sizemap2,abort}
\index[coq]{\C{size_map}}
as all quantifiers are in prenex positions.

Quantifiers may also occur in the body of definitions, which is
useful to define predicates expressing standard properties on
objects. For instance, the commutativity property of a binary operator
is defined as:

\begin{coq}{name=comm}{}
Definition commutative (S T : Type) (op : S -> S -> T) :=
  forall x y, op x y = op y x.
\end{coq}
\index[coq]{\C{commutative}}
and the lemma stating the commutativity of the \C{addn} operation is
in fact:

\begin{coq}{name=addncom}{}
Lemma addnC : commutative addn.
\end{coq}
\coqrun{name=testcomm}{ssr,comm,addncom,abort}
The \mcbMC{} library defines several such predicates, which are used
as molds in order to state standard properties in a consistent and
compact way. We provide below a few examples:

\begin{coq}{name=predicators}{}
Section StandardPredicates.
Variable T : Type.
Implicit Types (op add : T -> T -> T) (R : rel T).
Definition associative op := forall x y z, op x (op y z) = op (op x y) z.
Definition left_distributive op add :=
  forall x y z, op (add x y) z = add (op x z) (op y z).
Definition left_id e op := forall x, op e x = x.
End StandardPredicates.
\end{coq}
\coqrun{name=testpredicators}{ssr,predicators}
\index[coq]{\C{associative}}
\index[coq]{\C{left_id}}
\index[coq]{\C{left_distributive}}
\index[coq]{\C{rel}}
where \C{(rel T)} is an abbreviation for the type \C{(T -> T -> bool)}.

Beside the standardization of the statements through these
predicates, the \mcbMC{} library uses a systematic naming policy for the lemmas
that are instances of these predicates. A common suffix \C{C} is
used for commutativity properties like \C{addnC} or \C{mulnC}.
Such naming conventions are also useful to search the library, as detailed
in section~\ref{sec:search}.

Another class of predicates typically
describes usual properties of functions; these usually feature
quantifiers in their definitions:

\begin{coq}{name=combinators}{}
Section MoreStandardPredicates.
Variables rT aT : Type.
Implicit Types (f : aT -> rT).
Definition injective f := forall x1 x2, f x1 = f x2 -> x1 = x2.
Definition cancel f g := forall x, g (f x) = x.
Definition pcancel f g := forall x, g (f x) = Some x.
End MoreStandardPredicates.
\end{coq}
\coqrun{name=testcombinators}{ssr,combinators}
\index[coq]{\C{injective}}
\index[coq]{\C{cancel}}
\index[coq]{\C{pcancel}}
The types of these predicates deserve a few comments:

\begin{coq}{name=aboutcomm}{width=3.8cm}
About commutative.
\end{coq}
\begin{coqout}{run=aboutcomrun;dots}{width=8.2cm}
commutative : forall S T : Type, (S -> S -> T) -> Prop
\end{coqout}
\coqrun{name=aboutcomrun}{ssr,aboutcomm}
The constant \C{commutative} has a polymorphic parameter \C{T},
takes a binary operation as argument and builds a
\emph{proposition}. It is hence a polymorphic unary predicate on
a certain class of functions, the binary functions with both their
arguments and their result having the same type. Just like the
polymorphic binary predicate \C{eq}, the predicate \C{commutative} can
be used to form propositions:

\begin{coq}{name=checkpred}{width=6cm}
Check 3 = 3.
Check (commutative addn).
\end{coq}
\begin{coqout}{run=checkpredrun}{width=6cm}
3 = 3 : Prop
commutative addn : Prop
\end{coqout}
\coqrun{name=checkpredrun}{ssr,checkpred}
% Indeed, the class of propositions is closed under universal
% quantification \C{ forall} (and also under implication \C{->}).


\subsection{Organizing proofs with sections}

The \C{Section} mechanism presented in Section~\ref{sec:section} can
be used to factor not only the parameters but also the hypotheses of a
corpus of definitions and properties. For instance, the proof of the
Chinese Remainder Theorem is stated within such a section. It uses a
self-explanatory notation for congruences:

\begin{coq}{name=chinarem}{}
Section Chinese.

Variables m1 m2 : nat.
Hypothesis co_m12 : coprime m1 m2.

...

Lemma chinese_remainder x y :
  (x == y %[mod m1 * m2]) = (x == y %[mod m1]) && (x == y %[mod m2]).
Proof.
...
End.

End Chinese.
\end{coq}
The part of this excerpt up to the ``...''
corresponds to a mathematical sentence of the form: \emph{In this section,
  $m_1$ and $m_2$ are two coprime natural numbers\dots}. Within the
scope of this section, the parameters \C{m1} and \C{m2} are
fixed and the hypothesis \C{co_m12} is assumed to hold.
Outside the scope of the section (i.e., after the
\C{End Chinese} command), these variables and the hypotheses are
\emph{generalized}, so that the statement of \C{chinese_remainder}
becomes:

\begin{coq}{name=chinaremstm}{}
Lemma chinese_remainder m1 m2 (co_m12 : coprime m1 m2) x y :
  (x == y %[mod m1 * m2]) = (x == y %[mod m1]) && (x == y %[mod m2]).
\end{coq}
\coqrun{name=testchina}{ssr,chinaremstm,abort}
% [DG] At the latest at this stage, you might want to explain why
% assumptions (in an implication) are treated precisely in the same
% way as variables. (I know it, but it's a bit of a surprise to
% someone unused to Curry-Howard.)

In general, when a section ends, the types of the constants and the
statements of the lemmas change to include those section variables
and hypotheses that are actually used in their definitions or proofs.
% [DG] ... although it might not be very transparent which
% hypotheses the engine believes to be used:
% 
% Section test.
% 
% Variables x : nat.
% Hypothesis au : x = x.
% Hypothesis bu : 2 = 2.
% Variables y : nat.
% 
% Lemma ouch : x = x.
% Proof.
%   by [].
% Qed.
% 
% End test.
% 
% About ouch.
% 
% Turns out that Coq abstracts au (but not bu). Not sure if the reader
% needs to be warned at this place...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using lemmas in proofs}
\label{sec:quantifiedst}

In order to use a known lemma, one should provide the values of its
parameters that specify the instance relevant to the current
proof. Fortunately, \Coq{} can assist its user in
describing these values, and the \C{apply:} tactic, like the
\C{rewrite} one in section~\ref{sec:rewrite}, finds the appropriate
instance by comparing the lemma to the current goal:

\begin{coq}{name=apply1}{}
Lemma leqnn n : n <= n. Proof. Admitted.

Lemma example a b : a + b <= a + b.
Proof. by apply: leqnn. Qed.
\end{coq}
\coqrun{name=apply1run}{ssr,apply1}
\index[ssr]{\C{apply:}}
The lookup performed by the \C{apply} tactic works up to computation:

\begin{coq}{name=apply2}{}
Lemma example a b : a.+1 + b <= (a + b).+1.
Proof. by apply: leqnn. Qed.
\end{coq}
\coqrun{name=apply2run}{ssr,apply2}
In order to save the effort of explicitly mentioning trivial
steps in the proof script, we can extend the power of the \C{by}
terminator to make it aware of some lemmas available in
the library. The \C{Hint Resolve} command is used to tag these lemmas,
as in:
\index[vernac]{\C{Hint Resolve}}
\index[concept]{improving \C{by []}}

\begin{coq}{name=apply3}{}
(* This line belongs to the file where the lemma leqnn is stated and proved.*)
Hint Resolve leqnn.
Lemma example a b : a + b <= a + b.
Proof. by [].  Qed.
\end{coq}
\coqrun{name=apply3run}{ssr,apply3}
Observe that the goal is now closed without a mention of \C{leqnn},
although it has been used by the system to conclude the proof.

In order to illustrate more proof techniques related to the use of
lemmas inside proofs, let us scrutinize a formal proof that a prime
number which divides $m! + 1$ for a certain integer $m$ has to be
greater than $m$. This lemma is a key step in a proof that there are
infinitely many primes, which will be studied in
section~\ref{sec:infprimes}. The proof of the lemma goes by
contraposition: If $p$ is a prime number smaller than $m$, then it
divides $m!$ and thus it cannot divide $m! + 1$ as it does not divide
$1$. We first state this lemma as follows:

\begin{coq}{name=exp}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
\end{coq}
\coqrun{name=testexp}{ssr,exp,abort}

where \L+p %| m`!+ stands for ``\C{p} divides the factorial of \C{m}''.

The first step of our formal proof will be to give a name to the
hypothesis \C{(prime p)}, which means that we add it to the
current context of the goal. The dedicated tactic for this naming step is
\C{move=>} followed by the name given to the hypothesis, because the
hypothesis \emph{moves} from under the bar to above the bar:

\begin{coq}{name=exp1}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
\end{coq}
\begin{coqout}{run=exp1run;stod}{width=6cm}
m, p : nat
prime_p : prime p
====================
p %| m`! + 1 -> m < p
\end{coqout}
\coqrun{name=exp1run}{ssr,exp1,show,abort}
The second step of the proof is to transform the current goal into its
contrapositive. This means that we use the lemma

\begin{coq}{name=contraLR}{}
Lemma contraLR (c b : bool) :  (~~ c -> ~~ b) -> (b -> c).
\end{coq}
\coqrun{name=testcLR}{ssr,contraLR,abort}
\index[coq]{\C{contraLR}}

which describes (one direction of) the contraposition law (namely,
that an implication between booleans can be derived from its
contraposition). The \C{apply: contraLR} tactic
finds the appropriate values of the premise and conclusion and
instantiates the law, leaving us with the task of proving
that \C{p} is not a
divisor of \D{(m `! + 1)} under the assumption that \C{p} is not
greater than \C{m}:

\begin{coq}{name=exp2}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
apply: contraLR.
\end{coq}
\begin{coqout}{run=exp2run;stod}{width=6cm}
m, p : nat
prime_p : prime p
====================
 ~~ (m < p) -> ~~ (p %| m`! + 1)
\end{coqout}
\coqrun{name=exp2run}{ssr,exp2,show,abort}

More precisely, the values chosen by the tactic for the two parameters
\C{c, b} of lemma \C{contraLR} are \C{(m < p)} and
\D{(p \%| m `! + 1)}. They have been found by comparing the statement to be
proved with the conclusion \C{(b -> c)} of the statement of the lemma
\C{contraLR}.
The new statement of the goal is the corresponding instance of the
premise \C{(~~ c -> ~~ b)} of lemma \C{contraLR}.

The next steps in our formal proof are to improve the shape of the
hypothesis \C{\~\~ (m < p)} (using \C{rewrite -leqNgt})
and to give it a name (using \C{move=> leq_p_m}):


\begin{coq}{name=exp3}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
apply: contraLR.
rewrite -leqNgt.
move=> leq_p_m.
\end{coq}
\begin{coqout}{run=exp3run;stod}{width=6cm}
m, p : nat
prime_p : prime p
leq_p_m :  p <= m
====================
 ~~ (p %| m`! + 1)
\end{coqout}
\coqrun{name=exp3run}{ssr,exp3,show,abort}
And the next step uses the following lemma:

\begin{coq}{name=dvd}{}
Lemma dvdn_addr m d n : d %| m -> (d %| m + n) = (d %| n).
\end{coq}
\coqrun{name=testdvd}{ssr,dvd,abort}
This is a conditional equivalence, expressed as a conditional identity.
We can replace our current goal with \C{\~\~ (p \%| 1)} by rewriting
it using (the
appropriate instance of) this identity.  This operation will open an
extra goal requiring a proof of (the corresponding instance of) the side
condition \D{p \%| m`!}.

\begin{coq}{name=exp4}{width=6cm}
Lemma example m p : prime p ->
  p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
apply: contraLR.
move=> leq_p_m.
rewrite dvdn_addr.
\end{coq}
\begin{coqout}{run=exp4run}{width=6cm}
2 subgoals

  m, p : nat
  prime_p : prime p
  leq_p_m : p <= m
  ============================
   ~~ (p %| 1)

subgoal 2 is:
 p %| m`!
\end{coqout}
\coqrun{name=exp4run}{ssr,exp4,show,abort}
Observe the second goal at the bottom of the buffer, which displays the
statement of the side condition to be proved later. The context of
this subgoal is omitted but we do not really need to see it:
We know that statement \D{p \%| m`!} holds because \C{p <= m} and
because we can combine the following lemmas:

\begin{coq}{name=facts1}{}
Lemma dvdn_fact m n : 0 < m -> m <= n -> m %| n`!.
Lemma prime_gt0 p : prime p -> 0 < p.
\end{coq}

The first goal is also easy to solve, using the following basic facts:

\begin{coq}{name=facts2}{}
Lemma gtnNdvd n d : 0 < n -> n < d -> (d %| n) = false.
Lemma prime_gt1 p : prime p -> 1 < p.
\end{coq}
\coqrun{name=testfacts12}{ssr,facts1,facts2,abort,abort,abort,abort}
Finally, the resulting script would be:

\begin{coq}{name=exp1final}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p.
apply: contraLR.
rewrite -leqNgt.
move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd.
    by [].  (* ~~ false *)
    by [].  (* 0 < 1 *)
  by apply: prime_gt1.  (* 1 < p *)
apply: dvdn_fact.
  rewrite prime_gt0.  (* 0 < p *)
  rewrite leqNgt.
  by [].  (* true && ~~ (m < p) *)
by [].   (* prime p *)
Qed.
\end{coq}
\coqrun{name=testexp1}{ssr,exp1final}
For brevity, we record the goal solved by a tactic in a comment after
this tactic.\footnote{Some comments might still be helpful.
After \C{apply: dvdn_fact.}, our goal became
\C{0 < p <= m}, which is really an abbreviation for
\C{(0 < p) && (p <= m)}. The two subsequent \C{rewrite} commands
rewrote \C{(0 < p)} as a \C{true} and rewrote \C{(p <= m)} as
\C{\~\~ (m < p)} (which is an assumption); after that, the goal fell
prey to the \C{by []} tactic.}

We shall improve this script in two steps.  First, we take advantage of
\C{rewrite} simplification flags.  It is quite common
for an equation to be conditional, hence for \C{rewrite} to generate side
conditions.  We have already suggested that a good practice consists
in proving the easy side conditions
as soon as possible.  Here, the first two side conditions are indeed
trivial, and, just as with the introduction patterns of the \C{case} tactic,
we can use a simplification switch \C{//} to prove them.
We also combine on the same line the first three steps, using
the semicolon\footnote{From this example, one might take away the
wrong impression that a semicolon is synonymous to a dot. In general,
it is not. The semicolon is actually a tactical (like \C{by}) that
allows chaining tactics. A tactic of the form \C{t1; t2} (where
\C{t1} and \C{t2} are two tactics) amounts to first applying
\C{t1}, and then applying \C{t2} to \emph{each} of the subgoals
spawned by the application of \C{t1}. When \C{t1} spawns exactly
one subgoal, this is indeed equivalent to \C{t1. t2}. (Note that the
tactic \C{t2} has to work in each of these subgoals in order for
the notation to compile!)
A slight
variation of this syntax is \C{t0; [t1 | t2 | ... | tn]} for any
tactics \C{t0}, \C{t1}, \ldots, \C{tn}; this amounts to applying
tactic \C{t0}, and then applying tactic \C{t1} to the first subgoal
spawned, \C{t2} to the second, and so on.}.
The proof script (up to the end of the proof of the first
goal) then looks like this:

\begin{coq}{name=exp1rew}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  rewrite gtnNdvd //.
  by apply: prime_gt1.  (* 1 < p *)
\end{coq}
\coqrun{name=testexp1rev}{ssr,exp1rew,abort}
\index[ssr]{\C{rewrite}!\C{//} (close trivial goals)}
A careful comparison of the conclusions of \C{gtnNdvd}
and \C{prime_gt1} reveals that they are both rewriting rules.  While
the former features an explicit ``\C{.. = false}'', in the
latter one the ``\C{.. = true}'' part is hidden, but is there.
This means
both lemmas can be used as identities.

\mantra{All boolean statements can be rewritten as if they
were regular identities.  The result is that the matched
term is replaced with \C{true}.}

Rewriting with
\C{prime_gt1} leaves open the trivial goal \C{true} (i.e., \C{(true = true)}),
and the side condition \C{(prime p)}.  Both are trivial, hence
solved by prefixing the line with \C{by}.

\begin{coq}{name=exp1chain}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
\end{coq}
\coqrun{name=testexp1chain}{ssr,exp1chain,abort}
The same considerations hold for the last goal.

\begin{coq}{name=exp1short}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt; move=> leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1.
by rewrite dvdn_fact // prime_gt0.
Qed.
\end{coq}
\coqrun{name=testexp1short}{ssr,exp1short}


To sum up, both \C{apply:} and \C{rewrite} are able to find the right
instance of a quantified lemma and to generate subgoals
for its eventual premises.  Hypotheses can be named using \C{move=>}.

The proof script given above for \C{example m p} can be further
reduced in size. One simple improvement is to replace the chained
tactic \C{rewrite -leqNgt; move=> leq_p_m} by the equivalent
\C{rewrite -leqNgt => leq_p_m}. Indeed, as we will see later (in
subsection~\ref{ssec:stack}), the \C{move} tactic does nothing; it
is the \C{=>} that is responsible for the naming of the hypothesis.

In section~\ref{sec:rewrite2}, we shall describe some further
ways to shrink the proof script.

% [DG] I'd also mention how to use \C{apply:} when Coq isn't
% able to automatically guess how the parameters are to be filled in.
% So, apply: (lemma u v w).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Proofs by induction}\label{ssec:ind}
\index[concept]{induction}

Let us take the well known induction principle for Peano's natural numbers
and let us formalize it in the language of \Coq{}.  It reads:
let $\mathcal{P}$ be a property of natural numbers; if
$\mathcal{P}$ holds on $0$ and if, for each natural number $n$, the
property
$\mathcal{P}$ holds on $n + 1$ as soon as it holds on $n$, then $\mathcal{P}$
holds for any $n$.  Induction is typically regarded as a schema, where
the variable $\mathcal{P}$ stands for any property we could think about.

In the language of \Coq{}, it is possible to use a quantification to
bind the parameter  $\mathcal{P}$ in the schema, akin to the universal
quantification of polymorphic parameters in data types like
\C{seq}. Induction principles, instead of being ``schemas'', are
regular lemmas with a prenex quantification on predicates:

\begin{coq}{name=aboutnatind}{width=3.2cm}
About nat_ind.
\end{coq}
\begin{coqout}{run=aboutnatindrun;dots}{width=8.9cm}
nat_ind : forall P : nat -> Prop,
  P 0 -> (forall n : nat, P n -> P n.+1) -> forall n : nat, P n
\end{coqout}
\coqrun{name=aboutnatindrun}{ssr,aboutnatind}
Here \C{P} is quantified exactly as \C{n} is, but its type is a bit more
complex and deserves an explanation.  As we have seen in the first
chapter, the \C{->} denotes the type of functions; hence \C{P} is a
function from \C{nat} to \C{Prop}.  Recall that \C{Prop} is the type
of \emph{propositions}, i.e., something we may want to prove.  In the
light of that, \C{P} is a function producing a proposition out of a natural
number.  For example, the property of being an odd prime can be written as
follows:

\begin{coq}{name=P}{}
(fun n : nat => (odd n && prime n) = true)
\end{coq}
Indeed, if we take such function as the value for \C{P}, the first premise
of \C{nat_ind} becomes

\begin{coq}{name=Papplied}{width=6.5cm,title=P 0}
(fun n : nat => (odd n && prime n) = true) 0
\end{coq}
\begin{coq}{name=Preduced}{width=5.5cm,title=Equivalent by computation}
odd 0 && prime 0 = true
\end{coq}
\index[concept]{general term}
\index[concept]{higher-order}
Remark the similarity between the function argument to \C{foldr}
that is used to describe the general term of an iterated sum in
section~\ref{sec:bigopnat} and the predicate \C{P} here used
to describe a general property.
% [DG] Is there really much of a similarity?

\Coq{} defines an induction principle for every inductive type the
user defines, with standard names formed by adding a suffix \C{_ind}
to the name of the type. The statement of a generated induction principle
is shaped
by the structure of the definition of the inductive type. For example,
if we define an inductive type \C{bintree} (representing unlabeled planar
binary trees) as follows:
\begin{coq}{}{}
Inductive bintree := leaf | graft (u v : bintree).
\end{coq}
then we automatically are granted an induction principle called
\C{bintree_ind}:
\begin{coq}{}{width=3.8cm}
About bintree_ind.
\end{coq}
\begin{coqout}{}{width=8.1cm}
bintree_ind :
forall P : bintree -> Prop,
P leaf ->
(forall u : bintree, P u -> forall v : bintree, P v -> P (graft u v)) ->
forall b : bintree, P b

Argument P is implicit
\end{coqout}

For another example, here is the induction principle for sequences
(although denoted by \C{list_ind} rather than \C{seq_ind}, as
\C{seq} is defined merely as a synonym for \C{list}), which has some
similarities with the one for natural numbers:

\begin{coq}{name=aboutlind}{width=3.3cm}
About list_ind.
\end{coq}
\begin{coqout}{run=aboutlindrun;dots}{width=8.8cm}
list_ind : forall (A : Type) (P : seq A -> Prop),
  P [::] ->
  (forall (a : A) (l : seq A), P l -> P (a :: l)) ->
  forall l : seq A, P l
\end{coqout}
\coqrun{name=aboutlindrun}{ssr,aboutlind}

To sum up: reasoning by induction on a term \C{t} means
finding the induction lemma associated to the type of \C{t}
\emph{and} synthesizing
the right predicate \C{P}.  The \C{elim:} tactic has these two
functionalities, while \C{apply:} does not. Thus, while both \C{elim:}
and \C{apply:} can be used to formalize a proof by induction, the
user would have to explicitly specify both \C{t} and \C{P} in order to
make use of the \C{apply:} tactic, whereas the \C{elim:} tactic
does the job of determining these parameters itself:
The induction principle
to be used is guessed from the type of the argument of the tactic. Let
us illustrate on an example how the value of the parameter \C{P} is
guessed by the \C{elim:} tactic and let us prove by induction on \C{m}
that \C{0} is neutral on the right of \C{addn}.
\index[ssr]{\C{elim: name => [$\mid$m IHm]}}

\begin{coq}{name=addn0p}{width=6cm}
Lemma addn0 m : m + 0 = m.
Proof.
elim: m => [ // |m IHm].
\end{coq}
\begin{coqout}{run=addn0prun;stod}{width=6cm}
m : nat
IHm : m + 0 = m
=======================
m.+1 + 0 = m.+1
\end{coqout}
\coqrun{name=addn0prun}{ssr,addn0p,show,abort}
The \C{elim:} tactic is used here with an introduction pattern similar
to the one we used for \C{case:}. It has two slots, because of the

two constructors of type \C{nat} (corresponding naturally to what is
commonly called the ``induction base'' and the ``induction step''),
and in the second branch we give a
name not only to the argument \C{m} of the successor, but also to the
induction hypothesis. We also used the \C{//} switch to deal with the

base case because if
\C{m} is \C{0}, both sides evaluate to zero. The value of the parameter
\C{P} synthesized by \C{elim:} for us is
\C{(fun n : nat => n + 0 = n)}. It has been obtained by
\emph{abstracting} the term \C{m} in the goal (see
section~\ref{ssec:deffun}). The proof concludes by using lemma \C{addSn}
to  pull the \C{.+1} out of the sum, so that the induction hypothesis
\C{IHm} can be used for rewriting.
% [DG] If you want to use the slang "rewrite [something]" for
% "rewrite the goal using [something]", then it should be explained.

Unfortunately proofs by induction do not always run so smooth.
To our aid the \C{elim:} tactic provides two additional services.
The first one is to let one \emph{generalize}
the goal.  It is typically needed when the goal mentions a recursive function
that uses an accumulator: its value is going to change during recursive calls;
hence the induction hypothesis must be general.
% [DG] I didn't understand this. What is an accumultor? And how can I
% generalize the goal?

Another service provided by \C{elim:} is specifying an alternative
induction principle. For example, one may reason by induction on
a list starting from its end, using the following induction principle:

\begin{coq}{name=lastind}{}
Lemma last_ind A (P : list A -> Prop) :
  P [::] -> (forall s x, P s -> P (rcons s x)) -> forall s, P s.
\end{coq}
\coqrun{name=testlastind}{ssr,lastind,abort}
where \C{rcons} is the operation of concatenating
a sequence with an element, as in \C{(s ++ [::x])}.

For example \C{last_ind} can be used to relate the
\C{foldr} and \C{foldl} iterators as follows:

\begin{coq}{name=foldrev}{}
Fixpoint foldl T R (f : R -> T -> R) z s :=
  if s is x :: s' then foldl f (f z x) s' else z.

Lemma foldl_rev T R f (z : R) (s : seq T) :
  foldl f z (rev s) = foldr (fun x z => f z x) z s .
\end{coq}
\coqrun{name=testfoldrev}{ssr,foldrev,abort}

The proof uses the following lemmas:

\begin{coq}{name=foldrevutils}{title=Tools}
Lemma cats1 T s (z : T) : s ++ [:: z] = rcons s z.
Lemma foldr_cat T R f (z0 : R) (s1 s2 : seq T) :
  foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1.
Lemma rev_rcons T s (x : T) : rev (rcons s x) = x :: rev s.
\end{coq}
\coqrun{name=testfoldrevutils}{ssr,foldrevutils,abort,abort,abort}
% Lemma cats1 T s (z : T) : s ++ [:: z] = rcons s z.
% Proof.
%  elim: s => [| t ts IH] //=.
%   by rewrite IH.
% Qed.
% 
% Lemma cats0 T (s : seq T) : s ++ nil = s.
% Proof.
%   elim: s => [| t ts IH] //=.
%   by rewrite IH.
% Qed.
%
% Lemma foldr_cat T R (f : T -> R -> R) z0 (s1 s2 : seq T)  :
%   foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1.
% Proof.
%   move: s2 z0.
%   elim: s1 => [| p t1 IH] //=.
%   move=> s1 z0.
%   by rewrite IH.
% Qed.
%
% Lemma rev_rcons T s (x : T) : rev (rcons s x) = x :: rev s.
% Proof.
%   rewrite /rev.
%   move: s x.
%   have: forall (s w : seq T) (x : T), catrev (rcons s x) w = x :: catrev s w.
%     move=> s.
%     elim: s => [| t ts IH] //=.
%   move=> generalization.
%   move=> s x.
%   by apply generalization.
% Qed.

The complete proof script follows:

\begin{coq}{name=foldrevfinal}{}
Lemma foldl_rev T A f (z : A) (s : seq T) :
  foldl f z (rev s) = foldr (fun x z => f z x) z s .
Proof.
elim/last_ind: s z => [|s x IHs] z //.
by rewrite -cats1 foldr_cat -IHs cats1 rev_rcons.
Qed.
\end{coq}
\coqrun{name=testfoldrevfinal}{ssr,foldrevfinal}
\index[concept]{induction!generalizing}

Here ``\C{elim/last_ind: s z}'' performs the induction using the
\C{last_ind} lemma on \C{s} after having generalized the initial value of
the accumulator \C{z}. The resulting value for \C{P} hence
features a quantification on \C{z}:

\begin{coq}{name=foldrevPind}{}
(fun s => forall z, foldl f z (rev s) = foldr (fun x z => f z x) z s)
\end{coq}

The ``\C{z}'' that comes \emph{after}
``\C{elim/last_ind: s z => [|s x IHs]}'' deserves further explanation.
Had we stopped at ``\C{elim/last_ind: s z => [|s x IHs] //}'', our goal
would look like this:

\begin{coqout}{}{}
forall z : A,
  foldl f z (rev (rcons s x)) = foldr (fun x0 : T => f^~ x0) z (rcons s x)
\end{coqout}
(ignore the ``\C{f^~}'', which is coming out of the blue here, but
is merely the standard abbreviation for \C{fun x z => f z x} in the
\mcbMC{} library).
The additional ``\C{z}'' after the ``\C{=> [|s x IHs]}''
is responsible for pulling the
``\C{forall z : A}'' out of the goal again, back into the heap of
variables and assumptions. (See subsection~\ref{ssec:stack} for more
detail about this kind of operations.)

We have thus generalized \C{z} only to pull it out of the goal again
soon after. It might appear as if this was a useless detour.
However, it was not. Thanks to the generalization, the induction
hypothesis \C{IHs} states:

\begin{coq}{name=foldrevIH}{}
IHs : forall z : A, foldl f z (rev s) = foldr (fun x z => f z x) z s
\end{coq}
which is more general than what we had obtained if we had not
generalized \C{z} beforehand.
The quantification on \C{z} is crucial since the goal in the induction step,
just before we use \C{IHs}, is the following one:

\begin{coq}{name=foldrevgoal}{}
foldl f z (rev (s ++ [:: x])) =
  foldr (fun y w => f w y) (foldr (fun y w => f w y) z [:: x]) s
\end{coq}

The instance of the induction hypothesis that we need is
one where \C{z} takes the value \C{(foldr (fun y w => f w y) z [:: x])}.
The generalization of \C{z} gave us the freedom to substitute a
different value for \C{z}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsection{Rewrite, a swiss army knife}\label{sec:rewrite}

Approximately one third of the proof scripts in the \mcbMC{} library is made of
invocations of the \C{rewrite} tactic. This proof command provides many
features we cannot extensively cover here.  We just sketch a very common idiom
involving conditional rewrite rules and we mention the \C{RHS} pattern for
the casual reader.  The interested reader can find more about the pattern
language in section~\ref{sec:rewrite2} or in the dedicated chapter of
the Ssreflect language user manual~\cite{ssrman}.

% One feature of the \C{rewrite} tactic is the optional iterator \C{?}.
% A rewrite rule prefixed by \C{?}
% (as in ``\C{rewrite dvdn_addr ?dvdn_fact}'') is applied
% zero-or-more times on each of the 

We have seen before that applying the \C{rewrite} tactic can
create side conditions which themselves need to be proven (i.e., they
are sub-goals). (For example, we obtained the side condition
\D{p \%| m`!} when we used the \C{rewrite dvdn_addr} tactic in proving
\C{example m p}, since the lemma \C{dvdn_addr} had a
\D{d \%| m} condition.)
These side conditions (by default) become the second, third and higher
sub-goals in a proof script, so their proofs are usually postponed to
after the first sub-goal (the main one) is proven. This is not always
desirable; therefore, it is helpful to have a way to prove
side conditions right away, on the same line where they arise.
One way to do this (which we have already seen in action) is using the
simplification item \C{//}.
When this does not suffice, one can invoke another rewrite rule using
the optional iterator \C{?}.  A rule prefixed by \C{?} is applied to
all goals zero-or-more times.  For example, recall our proof of
\C{example m p}:

\begin{coq}{name=exp2x}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt => leq_p_m.
rewrite dvdn_addr.
  by rewrite gtnNdvd // prime_gt1. (* ~~ (p %| 1) *)
by rewrite dvdn_fact // prime_gt0. (* p %| m`! *)
Qed.
\end{coq}
\coqrun{name=testexp2x}{ssr,exp2x}

The side condition \D{p \%| m`!} spawned by \C{rewrite dvdn_addr} was
proven in the last line of the script. Instead, we could have solved
it right away by rewriting using \C{?dvdn_fact ?prime_gt0}.
In fact, optionally rewriting with \C{dvdn_fact} on all goals affects only
the side condition, since the main goal mentions no ``divides'' predicate.
The same holds for \C{prime_gt0}. The resulting proof script is:

\begin{coq}{name=exp3x}{}
Lemma example m p : prime p -> p %| m `! + 1 -> m < p.
Proof.
move=> prime_p; apply: contraLR; rewrite -leqNgt => leq_p_m.
rewrite dvdn_addr ?dvdn_fact ?prime_gt0 //.
by rewrite gtnNdvd // prime_gt1.
Qed.
\end{coq}
\coqrun{name=testexp3x}{ssr,exp3x}
\index[ssr]{\C{rewrite}! \C{?} (optional iteration)}

The prefix \C{!} works similarly to \C{?}, but instead of applying
the rewrite rule zero-or-more times, it applies it one-or-more times.
% [DG] Not sure if this is relevant here, but you use a ! prefix
% a few pages further down, so I figured it should be explained
% somewhere.

Another functionality offered by \C{rewrite} is the possibility
to focus the search for the term to be replaced by providing a
context.  For example, the most frequent context is \C{RHS} (for Right
Hand Side) and is used to force \C{rewrite} to operate only on the right
hand side of an equational goal.

\begin{coq}{name=silly}{}
Lemma silly_example n : n + 0 = (n + 0) + 0.
Proof. by rewrite [in RHS]addn0. Qed.
\end{coq}
\coqrun{name=testsilly}{ssr,silly}

\index[ssr]{\C{rewrite}! \C{[in RHS]} (focusing)}

The last rewrite flag worth mentioning is the \C{/=} simplification
flag.  It performs computations in the goal to obtain a ``simpler'' form.
\index[ssr]{\C{rewrite}!\C{/=} (simplification)}

\begin{coq}{name=UserRwPat}{width=7cm}
Lemma simplify_me : size [:: true] = 1.
Proof.
rewrite /=.
\end{coq}
\begin{coqout}{run=UserRwPatrun;stod}{width=5cm}
==========================
1 = 1
\end{coqout}
\coqrun{name=UserRwPatrun}{ssr,UserRwPat,show,abort}
The \C{/=} flag simply invokes the \Coq{} standard \C{simpl}
tactic.  Whilst being handy, \C{simpl} tends to oversimplify
expressions, hence we advise using it with care.
In section~\ref{sec:edivn} we propose a less risky alternative.
The sequence ``\C{// /=}'' can be collapsed into \C{//=}.
\index[ssr]{\C{rewrite}!\C{//=} (simplify close)}

Another version of the \C{rewrite} tactic allows
\emph{unfolding} a definition
-- i.e., replacing an object by its definition.
For example, the lemma \C{leqE} that we used in
the proof of \C{leq_mul2l} back in section~\ref{sec:multirew}
does not exist in the library, and there is no name associated to this
equation. It is simply the definition of \C{leq}, and we actually do
not need to state a lemma in order to relate
the name of a definition, like \C{leq}, to its body
\C{fun n m => n - m == 0}. This unfolding operation can be
performed by calling the \C{rewrite} tactic, prefixing the name of the
object with \C{/}, as in \C{rewrite /leq}. Unfolding a definition is
indeed not a deductive operation but an instance of computation, as
made more precise in chapter~\ref{ch:ttch}. Our proof of
\C{leq_mul2l} thus takes the form

\begin{coq}{}{width=9.7cm}
Lemma leq_mul2l m n1 n2 :
 (m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
by rewrite /leq -mulnBr muln_eq0.
Qed.
\end{coq}

Notice that \C{rewrite /leq} unfolded the definition of \C{leq}
both in the expression \C{(m * n1 <= m * n2)} and in the expression
\C{(n1 <= n2)}. In general, each appearance of the object is being
unfolded. Sometimes it is desirable to unfold only some of them; see
\cite[\S 7.1]{ssrman} for various ways to fine-tune the tactic for such
purposes. One option is to
tell \Coq{} what instances of the object are to be unfolded. For
example, had we used \C{rewrite /(leq n1 n2)} instead of
\C{rewrite /leq}, we would only have gotten \C{(n1 <= n2)} unfolded.

A less frequently used variant of the \C{rewrite} tactic is the \C{-/}
prefix; it allows \emph{folding} a definition, i.e., the reverse of
unfolding. (For instance, \C{rewrite /(leq n1 n2)} could be undone by
\C{rewrite -/(leq n1 n2)}.)

\index[ssr]{\C{rewrite}! \C{/} (unfolding)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{2}
\mcbsubsection{Rewrite contextual patterns}\label{sec:rewrite2}

The example \C{leq_mul2l} illustrates how the \C{rewrite} tactic, provided a
rewrite rule like \C{mulnBr} or \C{muln_eq0}, is able
to identify a
subterm in the goal to be substituted. The usability of the
tactic crucially relies on an appropriate combination of automation
and control. The user should be able to predict which subterm will be
substituted and to drive the tactic if needed, with enough control
options, but not too much verbosity. A key ingredient of the
\C{rewrite} tactic is hence the \emph{matching} algorithm that
elects this subterm from the arguments provided to the tactic. Let us
provide some insights on the power and on the limitations of this
algorithm, as well as on the control primitives that can drive it.
\index[concept]{matching algorithm}

First, remember that our first attempt, using the simple
\C{rewrite leqE} command, only
affected the left hand side of the initial goal because of the
behavior of this matching algorithm.
Indeed, the matching algorithm traverses the entire goal
left-to-right, looking for the first subterm matching pattern
\C{(_ <= _)},  and hence picks the subterm \C{(m * n1 <= m * n2)}.
Now suppose we want to pick
the other instance of a subterm matching this pattern in the goal. We
can use the command \C{rewrite [n1 <= _]leqE}: the
pattern given by the user overrides the one inferred from the rewrite
rule and is used to select the subterm to be rewritten. In this case,
term \C{(m * n1 <= m * n2)} is ruled out because the first argument of
\C{<=}, namely \C{(m * n1)}, does not match the first argument \C{n1}
required in the user-given pattern. Therefore, \C{rewrite} picks the term
\C{(n1 <= n2)}, in the right hand side.

\begin{coq}{name=ctxpat1}{title=User provided pattern,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [n1 <= _]leqE.
\end{coq}
\begin{coqout}{run=ctxpat1run;stod}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=ctxpat1run}{ssr,LeqDef,ctxpat1,show,abort}

The same result could have been achieved by explicitly specifying
the parameters in the matching subterm to be rewritten: viz., by
using \C{rewrite (leqE n1 n2)} instead of
\C{rewrite leqE}.\footnote{Sometimes, an even more precise
specification is needed. Namely, it can happen that the term
\C{(n1 <= n2)} appears twice in the goal: for example, when the goal
is \C{(n1 <= n2) || (n1 <= n2)}. In this case, we would need
\C{rewrite \{1\}(leqE n1 n2)} to rewrite only the first appearance of
the term, and
\C{rewrite \{2\}(leqE n1 n2)} to rewrite only the second. In general,
the \C{\{k\}} prefix (for a positive integer \C{k})
has the effect that the tactic is being applied in the
\(k\)-th of the possible positions where it is applicable; for
instance, in the proof of \C{silly_example}, we could have used
\C{rewrite \{2\}(addn0 n)} instead of \C{rewrite [in RHS]addn0}.
Care must be taken when the \C{\{k\}} prefix is applied without fully
specifying the parameters, e.g., in the form \C{rewrite \{1\}leqE}; the
behavior of \Coq{} in this situation is counterintuitive (it starts by
finding one subterm of the goal matching \C{leqE}, then infers its
parameters,
and then rewrites the \(k\)-th among the appearances of the subterm
with these parameters, rather than the \(k\)-th of all appearances).}
% [DG] This footnote is probably less than optimal. I think it is
% important to know how to specify a precise point of rewriting if all
% the tricks and heuristics fail. Probably the use of {k} together
% with fully specified parameters is the gold standard here. But if I
% explain this, I need to warn against using {k} with non-fully
% specified parameters, since people would otherwise consider it the
% logical middle ground. I'm not sure if I've done this warning well,
% and if I got the confusing behavior right.

Another way of driving the matching algorithm is by providing a
\emph{context}, restricting the part of the goal to be explored. For
instance, in this case, the instance we want to pick is on
the right hand side of the identity to be proved. We can implement
this specification using the pattern \C{[in RHS]}:

\begin{coq}{name=ctxpat2}{title=RHS pattern,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in RHS]leqE.
\end{coq}
\begin{coqout}{run=ctxpat2run;stod}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
(m == 0) || (n1 - n2 == 0)
\end{coqout}
\coqrun{name=ctxpat2run}{ssr,LeqDef,ctxpat2,show,abort}

More generally, one can provide context patterns like \C{[in X in T]}
where \C{X} is a variable name, bound in \C{T}. For instance pattern
\C{[in RHS]} is just syntactic sugar for the context pattern
\C{[in X in _ = X]}.  We invite the interested reader to check the
reference manual~\cite[section 8]{ssrman} for more variants of patterns and for a
more precise description of the different phases in the matching
algorithm used by this tactic.

As we have said, the lemma \C{leqE} does not in fact exist in the
library, and instead is just the definition of \C{leq}. %  Indeed the
% identity it states holds by symbolic computation, and we have seen in
% section~\ref{ssec:proofcomp} that such class of proof steps can be
% typically omitted.
However if we
try to omit the first \C{rewrite !leqE} command, then the next one,
% [DG] Why the exclamation mark in "!leqE"?
namely \C{rewrite -mulnBr}, fails:

\begin{coq}{name=ctxpat3}{width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -mulnBr.
\end{coq}
\begin{coqout}{run=ctxpat3run}{width=5cm}
Error: The RHS of mulnBr
  (_ * _ - _ * _)
does not match any subterm
of the goal
\end{coqout}
\coqrun{name=ctxpat3run;fail}{ssr,ctxpat3}
\index[concept]{keyed matching}

This indicates in particular that, although the term \C{(m * n1 <= m * n2)}
is equal up to computation to the term \C{(m * n1 - m * n2 == 0)}, the matching
algorithm is not able to see it. This is due to the compromise that
has been chosen, between predictability and cleverness. Indeed the
algorithm looks for a verbatim occurrence of the head symbol of the
% [DG] "Head symbol" should probably be defined. I guess I know what
% it means (the root of the syntax tree), but I don't believe I could
% explain it well.
pattern: in this case it hence looks for an occurrence of \C{(_ - _)},
which is not found. As a consequence, we need an explicit step in the
proof script in order to expose the subtraction before being able to
rewrite right to left with \C{mulnBr}. However if we tackle the proof
in reverse, starting from the right hand side, the first \C{-muln_eq0}
step will succeed:

\begin{coq}{name=ctxpat4}{width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[_ || _]muln_eq0.
\end{coq}
\begin{coqout}{run=ctxpat4run;stod}{width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
  (m * (n1 - n2) == 0)
\end{coqout}
\coqrun{name=ctxpat4run}{ssr,ctxpat4,show,abort}

Indeed, the \C{[_ || _]} pattern identifies term \C{(m == 0) || (n1 <= n2)}, as
their head symbols coincide. Now that we have selected a subterm, the
\C{rewrite} tactic is able to identify it with the term
\C{(m == 0) || (n1 - n2 == 0)}, itself an instance of the right hand side
of \C{muln_eq0}. Indeed,
while matching only sees syntactic occurrences of the
head symbols of patterns, it is able to compare the other parts of the
pattern up to symbolic computation.
Note that the \C{[_ || _]} pattern is redundant here; there is no
other location in the goal where the right hand side of \C{muln_eq0}
could appear.
% [DG] I have switched the last two sentences since I think the
% "able to compare the other parts up to symbolic computation"
% explains not why the pattern [_ || _] is redundant, but why the
% rewrite works to begin with.

Patterns can not only be used in combination with a rewriting rule,
but also with a simplification step \C{/=} or an unfolding step
like \C{/leq}. For example:

\begin{coq}{name=ctxpat5}{title=Focused unfold,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite [in LHS]/leq.
\end{coq}
\begin{coqout}{run=ctxpat5run;stod}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 - m * n2 == 0) =
  (m == 0) || (n1 <= n2)
\end{coqout}
\coqrun{name=ctxpat5run}{ssr,ctxpat5,show,abort}

One can also re-fold a definition, but in such a case one has to specify,
at least partially, its folded form.

\begin{coq}{name=Unfold}{title=Refold,width=7cm}
Lemma leq_mul2l_modified m n1 n2 :
  (m * n1 - m * n2 == 0) =
    (m == 0) || (n1 <= n2).
Proof.
rewrite -/(leq _ _).
\end{coq}
\begin{coqout}{run=Unfoldrun;stod}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * n1 <= m * n2) =
  (m == 0) || (n1 <= n2)
\end{coqout}
\coqrun{name=Unfoldrun}{ssr,Unfold,show,abort}
\index[ssr]{\C{rewrite}! \C{-/} (folding)}

More generally, the \C{rewrite} tactic can be used to replace a
certain subterm of the goal by another one, which is equal to the
former modulo computation:

\begin{coq}{name=Fold}{title=Replacing computationally equal terms,width=7.7cm}
Lemma leq_mul2l m n1 n2 :
(m * n1 <= m * n2) = (m == 0) || (n1 <= n2).
Proof.
rewrite -[n1]/(0 + n1).
\end{coq}
\begin{coqout}{run=Foldrun;stod}{title=Proof state,width=5cm}
m, n1, n2 : nat
==========================
(m * (0 + n1) <= m * n2) =
(m == 0) || (0 + n1 <= n2)
\end{coqout}
\coqrun{name=Foldrun}{ssr,Fold,show,abort}
\index[ssr]{\C{rewrite}! \C{-[term]/(term)} (changing)}

Last, an equation local to the proof context, like an
induction hypothesis, can be disposed of after using it by
prefixing its name with \C{\{\}}.  For example
\C{rewrite -\{\}IHn} rewrites with \C{IHn} right to
left and drops \C{IHn} from the context.
\index[ssr]{\C{rewrite}! \C{\{name\}} (clear)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsection{Searching the library}\label{sec:search}
\index[concept]{search}

Finding the name of the ``right'' lemma in a library that contains
thousands of them may be quite a challenge. In spite of their digital
nature, formal libraries are not so easy to browse and the state
of the art of search tools for formal libraries is far from being as
advanced as what exists for instance for the world wide web.

In order to help the users find their needle in the haystack,
the \mcbMC{} library follows uniform naming policies, and the Ssreflect
proof language provides a \C{Search} command which displays lists of
items filtered using patterns, like \C{(_ * _ + _)}
or \C{(addn _ _)}, and substrings of the names, like \C{"rev" "cons"}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsubsection{Search by pattern}

The \C{Search} command takes a list of filters and prints the lemmas
that do match all the criteria.

The \emph{first} pattern provided is special, since it is required to match
the conclusion of a lemma, while all other patterns can match anywhere.

For example ``\C{Search (odd _)}'' only prints one lemma:

\begin{coq}{name=searchres}{}
dvdn_odd  forall m n : nat, m %| n -> odd n -> odd m
\end{coq}
Indeed the conclusion matches the pattern.  Note that one is not forced to
use wildcards; \C{odd} alone is a perfectly valid pattern.  Many more
lemmas are found by leaving the conclusion unspecified,
as in ``\C{Search _ odd}''.

If we require the lemma to be an equation, as in ``\C{Search eq odd}'', we find
the following two lemmas (among many other things):

\begin{coq}{name=searchres2}{}
dvdn2  forall n : nat, (2 %| n) = ~~ odd n
coprime2n  forall n : nat, coprime 2 n = odd n
\end{coq}
If we want to rule out all lemmas about coprimality we can refine the
search by writing ``\C{Search eq odd -coprime}''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mcbLEVEL{1}
\mcbsubsection{Search by name}

Being acquainted to the naming policy followed by the \mcbMC{} library
provides one of the more effective ways of finding lemmas in the
loaded libraries. The name  \C{my_first_lemma} we chose in
section~\ref{ssec:groundeq} is a very bad name, as it gives no
insight about what the lemma says. Most of the time, we
refrain  from naming lemmas with numbers, as is typically done in
standard mathematical texts. Finding an appropriate name for a
lemma can be a delicate task. It should convey as much information as
possible, while striving to remain short and handy. In particular,
bureaucratic lemmas that are frequently used but represent no deep
mathematical step should have a short name: this way they are both
easy to type and easy to disregard when skimming through a proof
script.

Partial names can be used as filters by the \C{Search} command. For example
\C{Search "C"} prints, among other things, \C{addnC} and \C{mulnC},
the commutativity properties of addition and multiplication.  Multiple
strings can be specified, for example \C{Search "1" "muln"}.  This time
we find \C{muln1} but also \C{muln_eq1}, the equation saying that
the product of two natural numbers is $1$ if and only if they are both $1$.

Here are the general principles governing the names of lemmas
in the \mcbMC{} library:
\begin{itemize}
\item{\bf Generalities}
  \begin{itemize}
  \item Most of the time the name of a lemma can be read off its
    statement: a lemma named \L+fee_fie_foe+ will say something about
    \L+(fee .. (fie ..(foe ..) ..) ..)+, e.g. lemma \L+size_cat+ in
    {\tt seq.v}.
  \item We often use a one-letter suffix to resolve overloaded
    notation, e.g., \C{addn}, \C{addb}, \C{addr} denote nat, boolean, ring
    addition, respectively. This policy does not necessarily apply to
    constants that should always be hidden behind a generic notation,
    and handled by a more generic theory.
    % [DG] What does the preceding sentence mean?
  \item Finally, a handful of theorems have historical names,
    e.g, \L+Cayley_Hamilton+ or \L+factor_theorem+.
  \end{itemize}
\item{\bf Structures and Records}
  \begin{itemize}
  \item Each structure type starts with a
    lower case letter, and its constructor has the same name but with a
    capital first letter.
    % [DG] What is a structure type?
  \item Each instance of a structure type has a name formed with the
    name of the carrier type, followed by an underscore and the one of
    the structure type like in \L+seq_sub_subType+, the structure of
    \L+subType+ defined on \L+seq_sub+ (see {\tt fintype.v}). Notable
    exceptions to this rule are canonical constructions taking
    benefits of modular name spaces, like in {\tt ssralg.v}.
  \end{itemize}
\item {\bf Suffixes}
  \begin{itemize}
  \item If the conclusion of a lemma is a predicate or an equality for
    a predicate, then that predicate is a suffix of the lemma name,
    like in \L+addn_eq0+ or \L+rev_uniq+.
  \item If the conclusion of a lemma is a standard property such as
    \L+\char+, \L+<|+, etc.\footnote{These examples are taken from
      libraries in the Mathematical Component distribution.}:
    the property should be
    indicated by a suffix (like \L+ _char+, \L+_normal+, etc), so
    the lemma name
    should start with a description of the argument of the property, such as
    its key property, or its head constant.
    Thus we have \L+quotient_normal+, not \L+normal_quotient+, etc. This
    convention does not apply to monotony rules, for which we either
    use the name of the property with the suffix for the operator
    (e.g., \L+groupM+), or the name of the operator with the S
    suffix for subset monotony (e.g., \L+mulgS+).
  \item We try to use and maintain the following set of lemma suffixes:
    \begin{itemize}
    \item {\tt 0} : zero, or the empty set
    \item {\tt 1} : unit, or the singleton set (use \L+_set1+ for
      the latter to disambiguate)
    \item {\tt 2} : two, doubling, doubletons
    \item {\tt 3} etc, similarly
    \item {\tt A} : associativity
    \item {\tt C} : commutativity, or set complement (use \L+Cr+
      for trailing complement)
    \item {\tt D} : set difference, addition
    \item {\tt E} : definition elimination (often conversion
      lemmas)
    \item {\tt F} : boolean false, finite type variant (as in
      \L+canF_eq+), or group functor
    \item {\tt G} : group argument
    \item {\tt I} : set intersection, injectivity for binary operators
    \item {\tt J} : group conjugation
    \item {\tt K} : cancellation lemmas
    \item {\tt L} : left hand side (as in \L+canLR+)
    \item {\tt M} : group multiplication
    \item {\tt N} : boolean negation, additive opposite
    \item {\tt P} : characteristic properties (often reflection
      lemmas)
    \item {\tt R} : group commutator, or right hand side (as in
      \L+canRL+)
    \item {\tt S} : subset argument, or integer successor
    \item {\tt T} : boolean truth and Type-wide sets
    \item {\tt U} : set union
    \item {\tt V} : group or ring multiplicative inverse
    \item {\tt W} : weakening
    \item {\tt X} : exponentiation, or set cartesian product
    \item {\tt Y} : group join
    \item {\tt Z} : module/vector space scaling
    \end{itemize}
  \end{itemize}
\end{itemize}


% Standard properties are
% always stated with predicates to impose
% consistency in their statements.  Indeed the real statement of
% \C{addnC} is \C{(commutative addn)}, where \C{addn} is the
% name of the addition operation and \C{commutative} is the
% following predicate.
%
% \begin{coq}{name=macro}{title=Predicate for stating commutativity (suffix ``C'')}
% Definition commutative op := forall x y, op x y = op y x.
% \end{coq}
%
% Predicates, being standard definitions, are completely transparent for the
% system.\footnote{not yet for \C{Search}, but here I'm describing an ideal
% situation}  Consistency is not only aesthetically, but ease the use of
% lemmas: as we will see later, the order of the quantification may make
% a lemma easier to use under certain circumstances.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Exercises}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:boolid,difficulty=0,title={Truth tables}]

Prove the following boolean tautologies:

\begin{coq}{name=ex1}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
\end{coq}
\coqrun{name=testex1}{ssr,ex1,abort,abort,abort}

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:rewrite,difficulty=0,title={Rewriting}]

Prove the following lemma by rewriting:

\begin{coq}{name=ex2}{}
Lemma subn_sqr m n : m ^ 2 - n ^ 2 = (m - n) * (m + n).
\end{coq}
\coqrun{name=testex2}{ssr,ex2,abort}
The \C{(_ ^ _)} notation is attached to the \C{expn} function.

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:induction,difficulty=1,title={Induction}]

Prove the following lemma by induction:

\begin{coq}{name=ex3}{}
Lemma odd_exp m n : odd (m ^ n) = (n == 0) || odd m.
\end{coq}
\coqrun{name=testex3}{ssr,ex3,abort}
Recall that a local equation can be disposed of (after use)
by prefixing its name with \C{\{\}}.

\end{Exercise}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Exercise}[label=ex:induction2,difficulty=2,title={Multiple induction}]

Prove the following lemma by induction.

\begin{coq}{name=ex4}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].
Lemma size_all_words n T (alphabet : seq T) :
  size (all_words n alphabet) = size alphabet ^ n.
\end{coq}
\coqrun{name=testex4}{ssr,ex4,abort}

(where \C{all_words} is as defined in the solution of
exercise~\ref{ex:allwords}).
This requires two inductions: first on the length of words,
then on the alphabet.  In this last case, a non-trivial
sub expression has to be generalized just before starting
the induction.

\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:boolid]

\begin{coq}{name=sol1}{}
Lemma orbA b1 b2 b3 : b1 || (b2 || b3) = b1 || b2 || b3.
Proof. by case: b1; case: b2; case: b3. Qed.
Lemma implybE a b : (a ==> b) = ~~ a || b.
Proof. by case: a; case: b. Qed.
Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
Proof. by case: a; case: b. Qed.
\end{coq}
\coqrun{name=testsol1}{ssr,sol1}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:rewrite]

\begin{coq}{name=sol2}{}
Lemma subn_sqr m n : m ^ 2 - n ^ 2 = (m - n) * (m + n).
Proof. by rewrite mulnBl !mulnDr addnC [m * _]mulnC subnDl !mulnn. Qed.
\end{coq}
\coqrun{name=testsol2}{ssr,sol2}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:induction]

\begin{coq}{name=sol3}{}
Lemma odd_exp m n : odd (m ^ n) = (n == 0) || odd m.
Proof.
elim: n => // n IHn.
by rewrite expnS odd_mul {}IHn orKb.
Qed.
\end{coq}
\coqrun{name=testsol3}{ssr,sol3}
\end{Answer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Answer}[ref=ex:induction2]

\begin{coq}{name=sol4}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].

Lemma size_all_words n T (alphabet : seq T) :
  size (all_words n alphabet) = size alphabet ^ n.
Proof.
elim: n => [|n IHn]; first by rewrite expn0.
rewrite expnS -{}IHn [in LHS]/all_words iterS -/(all_words _ _).
elim: alphabet (all_words _ _) => //= w ws IHws aw.
by rewrite size_cat IHws size_map mulSn.
Qed.
\end{coq}
\coqrun{name=testsol4}{ssr,sol4}
\marginnote{The second elim is a bit too much for ch2}
\end{Answer}







% To get a better feeling on how lemmas are named let's see some other
% lemmas already proved for us.

% \begin{coq}{}{width=5cm,title=Lemmas of the library}
% Check add0n.
% Check addnC.
% \end{coq}
% \begin{coqout}{}{title=Response,width=7cm}
% add0n : forall n : nat, 0 + n = n
% addnC : forall n m : nat, n + m = m + n
% \end{coqout}

% First of all, note the quantification. So far \C{forall} was used to quantify
% over types and describe polymorphic functions.  Now it ranges over terms of
% type \C{nat} and describes generic lemmas, holding for any natural numbers
% \C{n} and \C{m}.

% Going back to the naming conventions, note that both names begin with ``add'',
% that is the principal operation involved.  In particular is the head symbol
% (the most external one) in the left hand side of the equation.  The addition
% operation is the one on natural numbers, hence then ``n'' component in
% the suffix.

% For the first equation, the other symbol involved in the name is ``0'',
% that indeed plays an important role in the lemma.  The relative position
% of ``0'' and ``n'' is chosen to recall to the user if the neutral element
% is added to the left or to the right.  For example the lemma named
% \C{addn0} would state \C{forall n : nat, n + 0 = n}.


% \subsection{Writing proof scripts}

% indentation, naming, using closing tactics.

% \subsection{Searching existing content}

% END OF THE REVISED ORGANIZATION.
%%%--------------- oldies

% \subsection{Stating and proving an equality}
%
% The \C{by} terminator is systematically used to prefix any proof sentence
% that terminates a goal.  A proof sentence ends with a dot, and can
% combine more than one proof command via the semi colon punctuation,
% again more examples will follow.
% The use of \C{by} is not limited to asserting no goals are left,
% but is also used to close goals by trivial means.  The notion of triviality
% is an important point we will discuss many times, for now lets just
% say it is extensible by the user and that it includes reflexivity.
% Hence the previous proof can be written as \C{by [].} where \C{[]}
% denotes the empty list of proof commands.
%
% \begin{coq}{title=Same proof}
% Lemma my_first_lemma : 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% The \C{Qed} keyword terminates the proofs, checks it, and adds to
% the library the new lemma.  We can hence access
%
% Given that our first lemma is now part of the library as the result
% of the \C{Qed} command we can access it.
% \marginnote{should we use About ?}
%
% \begin{coq}{width=6cm,title=Printing a lemma statement}
% Check my_first_lemma.
% \end{coq}
% \begin{coqout}{title=Response,width=6cm}
% my_first_lemma : 3 = 3
% \end{coqout}
%
% Now that we are satisfied with the statement, we look into proving it.
% At the current stage we need to use the two already existing
% lemmas \C{add0n} and \C{addnC} and the fact that the equality predicate
% is substitutive: given an equation we can replace any instance of
% its left hand side with the corresponding instance of the right hand side.
%
% The command is called rewrite, and its argument its called rule.
%
% \begin{coq}{title=Pedestrian proof}
% rewrite add0n.
% rewrite addnC.
% by [].
% Qed.
% \end{coq}
%
% \begin{coqout}{title=Response line 1,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    a + b = b + a
% \end{coqout}
% \begin{coqout}{title=Response line 2,width=6cm}
% 1 subgoal
%
%   a, b : nat
%   ============================
%    b + a = b + a
% \end{coqout}
%
% Explain the job of instantiation rewrite does: picks \C{(a + b)} for
% \C{n} in \C{add0n} and picks \C{a} for \C{n} and \C{b} for \C{m} in
% \C{addnC}.  Explain it is guided by the head symbol \C{+} and traverses
% the goal left to right.  Define "pattern".
%
% \begin{coq}{width=4cm,title=The new lemma}
% Check add0nmC.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% add0nmC : forall a b : nat, 0 + (a + b) = b + a.
% \end{coqout}
%
% The rewrite proof command is very recurrent, hence a shorter form
% using multiple rules.
%
% \begin{coq}{title=More compact proof}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite add0n addnC. Qed.
% \end{coq}
%
% Note that the equations are used in order, e.g. the script
%
% \begin{coq}{title=Wrong proof}
% Lemma add0nmC_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite addnC add0n. Qed.
% \end{coq}
%
% Fails because \C{addnC} flips \C{0} with \C{(a + b)}, then
% \C{add0n} finds no matching sub term.  In any case the proof
% is wrong, commutativity has to be employed to flip \C{a} and \C{b},
% or \C{b} and \C{a}, but not \C{0}.  If one wants to keep the rules
% in that order he needs to drive \Coq{} by better specifying the
% pattern he infers from \C{addnC}.
%
% \begin{coq}{title=Rewrite pattern}
% Lemma add0nmC a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC add0n. Qed.
% \end{coq}
%
% Explain pattern: overrides the pattern inferred.
% Explain underscore: saves space if b is large.
%
% Discuss: stating an equation (LHS is bigger).
%
% \subsection{Equality up to computation}
%
% As we said at the beginning, equality is up to computation.
% Since \C{(0 + 3)} computes to \C{3}, proving the equality among
% the two expressions is trivial.
%
% \begin{coq}{title=Computation in proofs}
% Eval compute in (0 + 3).  (* prints 3 *)
% Eval compute in (true || false).  (* prints true *)
% Lemma example3 : 0 + 3 = 3.
% Proof. by []. Qed.
% \end{coq}
%
% Indeed \C{reflexivity}, and \C{by []} as well, take computation
% into account.
% Note it also works for symbolic expressions.
%
% \begin{coq}{title=Computation in proofs}
% Lemma add0n n : 0 + n = n.
% Proof. by []. Qed.
% \end{coq}
%
% Explain addn0 is different, why, and that it will be shown later,
% when induction will be introduced.
%
% If we go back playing with the previous proof, we see that the
% last rule can be omitted.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite [a + _]addnC. Qed.
% \end{coq}
%
% The reason is that \C{(0 + (b + a))} is equal
% to \C{(b + a)} up to computation.
% Note that add0n  is not only for free (in its proof) but
% also in its use.
%
% Maybe talk about \C{/=} here.
%
% \begin{coq}{title=This also works}
% Lemma add0nm_bad a b : 0 + (a + b) = b + a.
% Proof. by rewrite /= addnC. Qed.
% \end{coq}
%
% Note the pattern can go, since \C{/=} leaves the goal with
% no ambiguity.
% Note that, if we mind computation, the lemma is just an alias
% for \C{addnC} and hence is useless.  It may feel depressing, but
% it is actually a very important hygiene measure: only useful lemmas
% are kept, trade off between all combinations or few base blocks that
% combine well (harder in principle, requires a language that glues well).
%
%
%
% % \subsection{old}
% %
% % \begin{itemize}
% % \item \Coq{} comes with an equality predicate, that we see as axiomatic for the
% % moment (in this section). It is called \C{eq} and has an infix
% % notation \C{=}. Example: \C{Check 3 = 3}, \C{Check 3 = 4}.
% % \item Observe that, \C{Check} just checks the well-formedness of the
% %   statement, not its truth. Well-formedness here means that \C{=}
% %   requires both hand sides to be of the same type.
% %   Example \C{Check 3 = [::4]}. Observe that statement also have a
% %   type, called \C{Prop}.
% % \item We can give a name to a statement, that we would like to prove
% %   formally. Example \C{Lemma foo : 3 = 3}. Observe what happens at the
% %   level of the interface (we start a proof).
% % \item And now, how to prove equality statements. Observational, \C{=}
% %   behaves as expected: this is trivially true because \C{=} is
% %   reflexive.
% % \item End of the proof, \C{Qed}.
% % \item Now we have a theorem called \C{foo} at hand in the
% %   environment: \C{Check foo}. We can use it but it is useless...
% % \item In fact the libraries you load provide theorems that you can use
% %   in your proofs. Example:  \C{Check add0n}, \C{Check addnC}. Note the
% %   universal quantification.
% % \item How to state lemmas like this:
% % \C{Example toto a b : 0 + (a + b) = a + b}.
% % \item Equality is not just reflexive, it is also substitutive. This is
% %   implemented via the \C{rewrite} tactic, that we can use to prove
% %   this lemma, using \C{add0n}. Note that the tactic found the right
% %   instance of \C{add0n} to be used, with \C{(a + b)}.
% % \item \C{Qed}, \C{Check}, observe the universal quantification.
% % \item Rewrite steps can be chained, in order. Example:
% % \C{Example toto a b : 0 + (a + b) = b + a}. can be proved by rewriting
% % \C{add0n} then, \C{addnC}. Note that \C{addnC} then \C{add0n} does
% % something different.
% % \item In fact reflexivity is more than syntactic equality. Prove
% % \C{3 + 1 = 4}, \C{true || false = true}. But also with variables,
% % e.g. \C{add0n}, connect with the programs written in the previous
% % chapters.
% %
% % \item More advanced forms of proofs by the \C{rewrite} tactic allow to
% %   select a pattern and to simplify the goal for free by
% %   computation. Hence \C{addn0} just does not need to be stated
% %   explicitly in the proof script. Warning: simpl is a Pandora
% %   box. This should come very early
% %   and go with/before boolean reflection style proofs by rewriting.
% %
% % \item Special case of equality statements that play a pervasive role
% %   throughout the libraries: \C{_ = true}. For instance
% %   \C{odd (2 * x + 7) = true}. This is both a 'logical' statement,
% %   saying that any expression \C{(2x+7)} is an odd number, and
% %   an equation that can be rewritten during the course of a proof. Find
% %   an example, like \C{odd (2 * x + 7) || odd (2 * x)}. rewrite and
% %   compute.
% %
% % \item Now we should point the coercion, because people will search and
% %   check.
% % \end{itemize}
%
%
%
% \mcbLEARN{case}
% \mcbREQUIRE{}
% \mcbPROVIDE{case, -, indentation, brute force proofs, semicolon, => after case}
% \mcbLEVEL{1}
% \mcbsection{Case analysis}
%
% In programming inductive data is matched against to consider all
% possible cases.  In the same way, when we reason on a program
% whose input is symbolic, we can proceed by considering all possible
% cases.
%
% \begin{coq}{title=First De Morgan's law: pedestrian proof}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof.
% case: a.
% - by []
% case: b.
% - by [].
% by [].
% Qed.
% \end{coq}
% \begin{coqout}{title=Response line 3,width=8cm}
% 2 subgoals
%
%   b : bool
%   ============================
%    ~~ (true && b) = ~~ true || ~~ b
%
% subgoal 2 is:
%  ~~ (false && b) = ~~ false || ~~ b
% \end{coqout}
%
% Explain the decorator and the indentation policy.
% Note a removed from context, substituted by true and false.
% Note first goal computes to b=b.
% Note second goal does not, computation blocked, we case b.
%
% \begin{coqout}{title=Response line 5,width=8cm}
% 2 subgoals
%
%   ============================
%    ~~ (false && true) = ~~ false || ~~ true
%
% subgoal 2 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Now all computes.  We are not satisfied, we could write
% as the only tactic \C{case: a; case: b.}.
%
% \begin{coqout}{title=Response,width=8cm}
% 4 subgoals
%
%   ============================
%    ~~ (true && true) = ~~ true || ~~ true
%
% subgoal 2 is:
%  ~~ (true && false) = ~~ true || ~~ false
% subgoal 3 is:
%  ~~ (false && true) = ~~ false || ~~ true
% subgoal 4 is:
%  ~~ (false && false) = ~~ false || ~~ false
% \end{coqout}
%
% Explain semicolon.
% Note that all computes. Note that this is always possible
% for finitary data, it amounts to comprehensive testing.
%
% \begin{coq}{title=First De Morgan's law}
% Lemma negb_and (a b : bool) : ~~ (a && b) = ~~ a || ~~ b.
% Proof. by case: a; case: b. Qed.
% \end{coq}
%
% other examples, exercises, can be
%
% \begin{coq}{title=possible exampels}
% Lemma andbA : associative andb.        Proof. by do 3!case. Qed.
% Lemma orbCA : left_commutative orb.    Proof. by do 3!case. Qed.
% Lemma andbN b : b && ~~ b = false.     Proof. by case: b. Qed.
% \end{coq}
%
% to explain A and N suffixes, plus do iteration, plus stack top.
%
% When data is not finitary, then case is not sufficient.
%
% \begin{coq}{}
% Lemma eqnxx (x : nat) : eqn x x = true.
% Proof. case: x => [|x'].
% \end{coq}
%
% Name subterms.
%
% \begin{coqout}{title=Response,width=8cm}
%   x' : nat
%   ============================
%    eqn x'.+1 x'.+1 = true
% \end{coqout}
%
% But before induction we look at implication
%
% \mcbLEARN{apply}
% \mcbREQUIRE{}
% \mcbPROVIDE{apply, ->, =>, //}
% \mcbLEVEL{1}
% \mcbsection{Implication and backchaining}
%
% \begin{coq}{width=4cm}
% Check @dvdn_mul.
% \end{coq}
% \begin{coqout}{title=Response,width=8cm}
% dvdn_mul : forall d1 d2 m1 m2 : nat,
%   d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
% \end{coqout}
%
% Explain implication symbol, the ambiguity with function space will
% be explained later on.
%
% \begin{coq}{}
% Lemma stupid x : 3 * x %| 6 * x^2.
% Proof.
% apply: dvdn_mul.
% - by [].
% apply: dvdn_mulr.
% exact: dvdnn.
% Qed.
% Lemma stupid2 x : 3 * x %| 6 * x^2.
% Proof.
% rewrite dvdn_mul // dvdn_mulr // dvdnn.
% Qed.
% \end{coq}
%
% How do we prove this kind of lemmas
%
% \begin{coq}{}
% Lemma stupid3 x y : x %| y -> 3 * x %| 6 * y.
% Proof.
% move=> div_xy.
% by apply: dvdn_mul.
% Qed.
% \end{coq}
%
% by looks in the hyps.
%
% \begin{coq}{}
% Lemma stupid3 x y (div_xy : x %| y) : 3 * x %| 6 * y.
% Proof. exact: dvdn_mul. Qed.
% \end{coq}
%
% equivalent syntax, uncommon.
%
% Make another example working on the stack
%
% \begin{coq}{}
% Lemma andb_idl (a b : bool) : (b -> a) -> a && b = b.
% Proof. by case: a; case: b => // ->. Qed.
% \end{coq}
%
% note // in =>, note -> in =>, note runs on 4 goals.
%
% one last example with true=false in the context.
%
% \section{Proofs by induction}
%
% \begin{coq}{}
% Lemma eqnxx x : eqn x x.
% Proof.
% elim: x=> [|x' IH].
% rewrite /=.
% apply: IH.
% by [].
% Qed.
% Lemma eqnxx x : eqn x x.
% Proof. by elim: x. Qed.
% \end{coq}
%
% requires induction.
%
% \section{Curry-Howard}
%
% Explain CH for arrows, foralls, equality and induction. Show Proof for
% some examples of proofs.
%
% First implication, start with comparing the source and target of the
% arrows that are common to this chapter and the preceeding.
%
% \begin{coq}{}
% Inductive list (A : Type) : Type :=
%     nil : list A | cons : A -> list A -> list A
%
% list: Type -> Type
%
% Definition is_equal_to_2 (x : nat) : x = 2.
%
% is_equal_to_2 : nat -> Prop
% \end{coq}
%
%
%
%
%
%
% \section{To be sorted}
%
% \subsection{Universal quantification}
%
% \begin{coq}{}
% Variable A : Prop.
% Definition toto : A -> A := fun x => x.
% Lemma  toto : A -> A.
%  Proof.
%   move => x.
%   Show Proof.
%   apply: x.
%  Qed.
% \end{coq}
%
% Note : \C{toto :  A -> A : Prop}
% discuss interactive proof construction, other example with a real
% apply that open subgoals.
%
% In CH style we see a proof, where lambdas/apply work too (same tactics)
%
% Specialization of an quantified lemma via application (maybe also
% \C{move/(_ x) in H}).
% Soft intro of the work of unification (FO) during application (infer
% arguments of conclusion's predicate symbol \C{prime _}).
%
% We should also display her  HO "predicators": commutative.  Discuss
% order of quantification in transitive and similar, naming conventions
%
% \subsection{Curry-Howard for equality proofs}
%
%
% Show \C{rewrite -H}, plus the idea that one may want to select
% occurrences (with simple patterns).
%
%
% May be should we say rather early that rewriting under binders is not
% allowed by the system.
%
% \subsection{proof term for rewrite (CH)}
%
% There are also proof terms for equality proofs (show \C{refl})
% The work rewrite does is non-trivial (infer P)
%
% \begin{coq}{}
% Check eq_rect (* : forall P : nat -> Prop, .... forall n, P n *)
% \end{coq}
%
% Write a proof term by hand.
% (note that it works because of beta being part of conversion).
% See that rewrite does the verbose part for you (infer P).
%
% An example of ambiguous P from above, driving rewrite means driving the
% synthesis of P.
%
% \subsection{other eq related tactics}
%
% Congr, injection \C{[= ]}, discriminate (//), \C{->}.
%
%
% \subsection{proof term for induction}
%
% Again show that it boils down to infer P
%
%
% \subsection{proofs by induction in their generality}
%
% Show that even for commutativity of addition one needs to
% "load the goal" (or to help synthesize a more general P).
%
%
% \section{Exercises (explained)}
%
% xor-odd, then cancel encode decode, or something on primes.
%
% Take the occasion to present last/first, bullets, by, syntaxes for
% \C{=> [|IH x xs]} after a case.
%
%
% \section{Notes}
%
% % From calculability to proofs, hence the CC, and the fact that
% % reasoning principles without a computational content become axioms.
% %
% % This is a non-technical chapter and message should be:
% % \begin{itemize}
% % \item instantiation of a universal statement is application (also the pair)
% % \item Excluded middle is not available by default (choice?)
% % \item Conversion as a pervasive indistinguishable, what inside
% %   (beta, definition unfolding,...)
% % \item Dependent types: eq, sigma (which example?)
% % \end{itemize}
% %
% % One options is: avoid relating type theory and other logics. We say:
% % we have a formal game where the basic elements are programs/functions
% % that come with types to avoid confusion. full stop. (no relation with
% % proof theory, set theory). maybe mention that roots are in calculability (hence
% % the choice to pick functions as primitive and not sets). This is lucky because
% % (computable) functions are today executable by a computer.  Still not all
% % concepts are "computable" hence some principles are problematic: EM,.... we
% % mainly stay in the lucky fragment (again no propaganda on intuitionistic logic,
% % constructive math; just a mention).
% %
%
% running topic: statements and their proofs. This chapter provides a gentle
% introduction to the implicative fragment of the logic and to the
% interactive construction of formal proofs. The reference to
% Curry-Howard should come as late as possible. It should indeed be
% possible to present a substantial amount of example and intuitions
% before explaining this. Specially if we carefully use the automated
% introduction of variables bound before the semi-column. At the tactic
% level, we should be able to avoid the need for Curry Howard related
% constructions like \C{apply: (H x)} in the first part of the chapter.
%
% \begin{itemize}
% \item \C{Prop} as the type of statements
% \item forall-lambda, predicates as functions to Prop.  The difference with the forall in the previous chapter is that the type the var ranges in is not "Type" but a data type like nat.
% \item examples with implicative predicate logic, modus ponens
% \item definition = lemma (proofs of implications are lambdas-app)
% \item tactics to generate the terms in a less pedestrian way (move, apply)
% \item if one calls Show Proof in the middle he sees one is building
% 	the proof term incrementally, as one draws a proof tree (in CH style)
% \end{itemize}
%
% Now we make the point of Qed, the kernel checks the term produced via
% tactics (or hand-written).
%
% Examples of predicates: equality
% \begin{itemize}
% \item not to talk about indexes of inductive families we introduce eq as
% 	an axiom and refl as another axiom to prove eq and we insist on
% 	conversion
% \item examples, among which a beta expansion (to help later on with elimination)
% \item now, what are the proofs of an equality? maybe we start with rewrite
% \item examples are symmetry, transitivity
% \item then we give the elimination principle as an axiom, and explain the
% 	work rewrite does in synthesizing the predicate
% \item the job of rewrite is not trivial nor un-ambiguous: to drive the synthesis show occurrence selection (later on we see the same problem for elim)
% \item other exercise on other eq related "commands" like discriminate, injection arrows, congr.
% \end{itemize}
%
% Showing universal properties on inductive data
% \begin{itemize}
% \item first enouce some lemmas on concrete examples, like not true = false,
% 	then try to say "froall b : bool, ...".
% \item first on enumerated types (bool) via case
% \item them on nat via case and elim
% \item then show the proof term as an application of nat-rect, again the problem
% 	is to write down P and elim does that.
% \item here an additional problem: loading the goal before using it to generate P
% \end{itemize}
%
% We should manage to prove stuff on the concepts defined in chapter 1,
% notably \C{odd(a+b) = xor (odd a) (odd b)}.  But before you need lemmas
% on "odd (S x) = not (odd x)", to make the point that the proof is trivial with
% a library that has all the needed facts.  Also the base case goes away by ssr (in general spell out where the computation saves work).
%
% Comparison with other approaches:
% \begin{itemize}
% \item Compare an axiomatic, equational presentation of arithmetic to
%   its formalization as an inductive type with functions that
%   compute.
% \end{itemize}
%
%
% Another example is set-nth of rcons as done by Florent Hivert, that has not
% developed the theory of set-nth with cat, and hence messes up the proof
% that gets shorter if one does the homework.
%
% Another example could be a proof that requires the induction principle
% on nat that (strong/course of values induction).
%
% A maybe good example that forces you to do patterns or occ numbers and explain
% that 2  contains syntactically 0 is the proof that code/decode cancel (in
% choice).
%
% We lack example with a mathematical interest, maybe arithmetic is sufficient like binomial.v.
%
% We need also /= and hence Arguments simple never (and we try to omit nosimpl).
% Maybe we should document that nosimpl has been superseeded by
% the option of Arguments in the manual.
% Let say that controlling reduction is an important topic when you
% do ssr style.
%
% In this chapter we present several features of the proof language, but it it is
% not about the proof language itself (reference manual). What one adds to the
% reference manual here is an example of usage in the right context of the
% commands.  E.g. we give an hint of what patterns do (rewrite) but we don't
% discuss all the matching discipline... nor the most advanced syntaxes)
