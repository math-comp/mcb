% The header
\begin{coqdef}{name=ssr}
 From mathcomp Require Import all_ssreflect.
 Set Implicit Arguments.
 Unset Strict Implicit.
 Unset Printing Implicit Defensive.
\end{coqdef}
\begin{coqdef}{name=check}
Check
\end{coqdef}
\begin{coqdef}{name=dot}
.
\end{coqdef}

\Chapter{Functions and Computation}{}\label{ch:prog}

In the formalism underlying the \Coq{} system, functions play a
central role akin to the one of sets in set theory. In this chapter,
we give a flavor of how to define functions in \Coq{}, how to perform
computations and how to define basic mathematical objects in this
formalism.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functions}\label{sec:functions}
 Before being more
precise about the logical foundations of the \Coq{} system in
chapter~\ref{ch:ttch},
we review in this section some vocabulary and notations associated
with functions.
We will use the words \emph{function} and \emph{operation}
interchangeably. Sometimes, we will also use the word \emph{program}
to talk about functions described in an effective way, i.e. by a code
that can be executed. As a consequence we borrow from computer science
some jargon, like \emph{input} or \emph{return}. For example we say that
an operation takes as input a number and returns its double to mean
that the corresponding program computes or outputs the double of its
input, or that the function maps a number to its double. For
this purpose, we study examples involving natural numbers. In \Coq{}
syntax, we casually use \C{nat} to refer to the collection of natural
numbers and the infix symbol  \C{+} (resp. \C{*}) to denote the  addition
(resp. product) operation on natural numbers,  before providing their
actual formal definition in section~\ref{ssec:nat}. We will also
assume implicitly that numerals $0, 1, 2, \dots$ denote natural numbers,
represented by their analogue \C{0}, \C{1}, \C{2}, \dots in \Coq{} syntax.


\subsection{Defining functions, performing computation}\label{ssec:deffun}
Mathematical formulas are expressions composed of operation symbols,
of a certain arity, applied to some arguments which are
either variables or themselves (sub)-expressions.
In many cases these
expressions are written using notations for the operations, like the
infix $+$ the expression
\[ 2 + 1 \]
This expression represents a natural number, obtained as the result of
an operation applied to its arguments. For instance, it is the result
of the binary operation of addition, applied to two natural numbers
$2$ and $1$. The same expression can also represent the result of the
unary operation of {\em adding one on the right to a natural number},
applied to a natural number $2$.

In \Coq{}, the operation of {\em adding one on the right to a natural number} is
written in the following manner:

\begin{coq}{name=exfun}{}
  fun n => n + 1
\end{coq}
\coqrun{name=exfunrun}{check,exfun,dot}
\index[coq]{\C{fun .. => ..}}
The syntactic transformation of expression \C{(2 + 1)} into an
explicit application of this function to one argument can be
described as follows: select the sub-expression that is considered as
the argument of the function, here \C{2}, and replace it with a
symbolic name, here \C{n}. Then encapsulate the resulting expression
\C{(n + 1)} with the prefix ``\C{fun n =>}''. We commonly
say that the prefix ``\C{fun n =>}'' \emph{binds} the variable \C{n} in the
expression \C{n + 1}. The keyword ``\C{fun}'' stands for
\emph{function}.
\index[concept]{binder}

Now we still need to \emph{apply} this operation to the argument
\C{2}, and this is written as:

\begin{coq}{name=exapp}{title=Adding one to two, label=coq:exapp}
  (fun n => n + 1) 2
\end{coq}
\coqrun{name=exapprun}{check,exapp,dot}
\index[concept]{function application}
Note that applying a function to an argument is represented
simply by writing the function on the left of the argument,
with a separating space but {\em not
  necessarily with parentheses around the argument}; we will come back to this
later in the present section. As a first approximation, we can see
that expressions, also called \emph{terms}, in the syntax of \Coq{}
are either variables, or
functions of the form \C{(fun x => e)}, where \C{e} is itself an
expression, or the application \C{(e1 e2)} of an expression \C{e1} to
another expression \C{e2}. However, just like with pen and paper, the addition
operation is denoted in the \Coq{} syntax using an infix notation \C{+}.
The transformation we just detailed, from expression \C{(2 + 1)} to expression
\C{(fun n => n + 1) 2}, is called \emph{abstracting \C{2} in  \C{(2 + 1)}}.
\index[concept]{abstraction}

While expression \C{(fun n => n + 1)} describes an operation
without giving it a name, the usual mathematical practice would be to
rely on a sentence like {\em consider the function \(f\) from {\(\mathbb{N}\)}
to {\(\mathbb{N}\)} which maps \(n\) to \(n + 1\)}, or on a written
definition like:

\begin{equation}\label{equation:f}
f :
\begin{array}{ccc}
{\mathbb{N}} &\rightarrow& {\mathbb{N}}\\
n &\mapsto& n + 1
\end{array}
\end{equation}

In \Coq{}, the user can also associate a name with the operation
\C{(fun n => n + 1)}, in the following manner:

\begin{coq}{name=exdef}{}
Definition f := fun n => n + 1.
\end{coq}
\index[vernac]{\C{Definition}}
An alternative syntax for exactly the same definition is as follows
and this alternative syntax is actually preferred.

\begin{coq}{name=exdef_pref}{}
Definition f n := n + 1.
\end{coq}
\coqrun{name=exdefp1}{exdef_pref}

In this syntax, the name of the argument \C{n} is provided
\emph{on the left of} the separating \C{:=}, to be then referenced
\emph{on the right of} the separating \C{:=}, in the actual
definition of the function. The code of the actual definition is
hence comprised between the \C{:=} symbol and the terminating dot.

The information on the domain and codomain of \C{f},
as in \(f\ :\ {\mathbb{N}}\rightarrow{\mathbb{N}}\), is provided using
the \C{nat} label to annotate the argument and the output in the
\Coq{} definition:

\begin{coq}{name=exdef_type}{}
Definition f (n : nat) : nat := n + 1.
\end{coq}
\coqrun{name=exdeftyperun}{exdef_type}
The label \C{nat} is actually called a {\em type}.
We refer once again to chapter~\ref{ch:ttch} for a more accurate
description of types: in the present chapter we rely on the loose intuition
that a type refers to a collection of objects that can be treated in a
uniform way. A type annotation has the shape \C{(t : T)}, where a colon
\C{:} surrounded by two spaces separates an expression \C{t} on its
left from the type \C{T} itself on the right. For instance in
\C{(n : nat)}, the argument \C{n} of the function \C{f} is annotated with
type \C{nat}.

The other occurrence  of \C{nat}, visible in \C{ ... : nat := ...},
annotates the output of the function and indicates that this output is
of type \C{nat}. In other words, the type of any expression made of
\C{f} applied to an argument is \C{nat}.
\index[concept]{type}

\Coq{} provides a command to retrieve relevant information about the
definitions completed so far. Here is the response to a query about \C{f}:

\begin{coq}{name=about_f}{width=5.5cm,title=Gathering information on f}
About f.
\end{coq}
\begin{coqout}{run=about_f_run;dots}{title=Response,width=6.5cm}
f : nat -> nat
\end{coqout}
\coqrun{name=about_f_run}{exdef,about_f}
\index[vernac]{\C{About}}
which confirms the type information about the domain and codomain of
\C{f}: the arrow \C{->} separates the type of the input of \C{f} from
the type of its output.
% We also learn that the \Coq{} system will pay attention to
% arguments of \C{f} in such a way that overloaded notations
% will be interpreted as notation for natural numbers.
% \marginnote{maybe place a footnote here to point to another paragraph
% about overloaded notations.  To  be discussed.}

We can be more inquisitive in our requests for information about
\C{f}, and ask also for the value behind this name \C{f}:

\begin{coq}{name=print_f}{width=6cm}
Print f.
$~$
\end{coq}
\begin{coqout}{run=print_f_run;dots}{width=6cm}
f = fun n : nat => n + 1
  : nat -> nat
\end{coqout}
\coqrun{name=print_f_run}{exdef,print_f}
\index[vernac]{\C{Print}}

The output of this \C{Print} query has some similarities with the
 mathematical notation in \eqref{equation:f} and provides both the
 actual definition of \C{f} and its type information. Actually the way
 the definition is printed also features a type annotation of the
 arguments of the function, in the fragment ``\C{fun n : nat =>}''.

Types are used in particular to avoid confusion and rule out
ill-formed expressions. \Coq{} provides a command to check whether
an expression is \emph{well typed}.
\index[concept]{well typed}

For example the function \C{f} we just defined can \emph{only be
  applied to a natural number}, i.e., a term of type \C{nat}. Therefore
this first query succeeds, as \C{3} is a natural number:

\begin{coq}{name=check_f3}{width=5.1cm,title=Check well-typedness}
Check f 3.
\end{coq}
\begin{coqout}{run=check_f3_run}{title=Response,width=7cm}
 f 3 : nat
\end{coqout}
\coqrun{name=check_f3_run}{exdef,check_f3}
\index[vernac]{\C{Check}}
But \C{f} cannot be applied to something that is not a natural number,
like for example a function:

\begin{coq}{name=type_err_f}{width=6cm,title=Type error}
Check f (fun x : nat => x + 1).
$~$
$~$
\end{coq}
\begin{coqout}{run=type_err_run}{title=Response,width=6cm}
Error:
The term "(fun x : nat => x + 1)"
has type "nat -> nat" while it is
expected to be "nat".
\end{coqout}
\coqrun{name=type_err_run;fail}{exdef,type_err_f}
\index[concept]{type error}
As expected, it makes little sense to compute the addition between
a function and $1$.

Expressions that are well typed can be \emph{computed} by \Coq{},
meaning that they are \emph{reduced} to a ``simpler'' form, also
called a \emph{normal form}. For example computing \C{(f 3)} returns
value \C{4}:

\begin{coq}{name=compute_f3}{width=6cm,title=Evaluating a function}
Eval compute in f 3.
\end{coq}
\begin{coqout}{run=compute_f3_run}{title=Response,width=6cm}
 = 4 : nat
\end{coqout}
\coqrun{name=compute_f3_run}{exdef,compute_f3}
\index[vernac]{\C{Eval compute}}

At the very least, we can observe that the argument \C{3} has been
substituted for the argument variable in the definition of function
\C{f} and that the addition has been evaluated.
Although this capability of \Coq{} plays a crucial role
in the \mcbMC{} library, as we will see in chapter~\ref{ch:proofs}, it
is too early to be
more precise about this normalization strategy. This would require
at least describing in more details the formalism underlying the
\Coq{} system, which we do only in chapter~\ref{ch:ttch}. The
interested reader should actually refer to \cite[section
8.7.1]{Coq:manual} for the official documentation of \C{compute}.
For now, we suggest to keep only the intuition that this
normalization procedure provides the ``expected value'' of a
computation.

\index[concept]{computation}

\subsection{Functions with several arguments}
\label{sec:fun-sev-args}
The syntax we used to define a function with a single argument
generalizes to the case of functions with several arguments, which are
then separated by a space. Here is an example of a function with two
arguments:

\begin{coq}{name=def_g_attempt}{}
Definition g (n : nat) (m : nat) : nat := n + m * 2.
\end{coq}
\coqrun{name=def_g_attempt_run}{def_g_attempt}
In fact, for the sake of compactness, contiguous arguments of one and
the same
type can be grouped and share the same type annotation, so that the
above definition is better written:

\begin{coq}{name=def_g}{}
Definition g (n m : nat) : nat := n + m * 2.
\end{coq}
\coqrun{name=def_g_run}{def_g}
which asserts firstly
(by the \C{(n m : nat)} type annotation)
that both arguments \C{n} and \C{m} have type \C{nat},
and secondly that the
output of the function also has type \C{nat}, as prescribed by the
\C{... : nat := ...} type annotation. Again, the  \C{About} command
provides information on the type of the arguments and values of
\C{g}:

\begin{coq}{name=about_g}{width=5.5cm,title=Gathering information on g}
About g.
\end{coq}
\begin{coqout}{run=about_g_run;dots}{title=Response,width=6.5cm}
g : nat -> nat -> nat
\end{coqout}
\coqrun{name=about_g_run}{def_g,about_g}

The two first occurrences of \C{nat} in the response
 \C{nat -> nat -> nat} assert that function \C{g} has two arguments,
 both of type \C{nat}; the last occurrence refers to the type of
 the output. This response actually reads \C{nat -> (nat -> nat)},
 as the \C{->} symbol associates to the right. Otherwise said,
 {\em a multiple
 argument function is a single argument function that returns a
 function}.  This idea that multiple argument functions can be
represented using single argument functions (rather, for instance, than
tuples of arguments) is called {\em currying} and will play a special
role in chapter~\ref{ch:ttch}. For now, let us just insist on the fact
that in \Coq{}, functions with several arguments are not represented
with a tuple of arguments.
\index[concept]{currying of functions}


Back to our example, here is an alternative definition
 \C{h} which has a single argument \C{n} of type \C{nat} and returns
 a function of one argument as a result:

\begin{coq}{name=def_h}{}
Definition h (n : nat) : nat -> nat := fun m => n + m * 2.
\end{coq}
\coqrun{name=def_h_run}{def_h}

Queries on the respective types of \C{g} and \C{h} provide identical answers:

\begin{coq}{name=about_h}{width=5.5cm,title=Gathering information on h}
About h.
\end{coq}
\begin{coqout}{run=about_h_run;dots}{title=Response,width=6.5cm}
h : nat -> nat -> nat
\end{coqout}
\coqrun{name=about_h_run}{def_h,about_h}

If we go further in our scrutiny and ask the \Coq{} system to print
the definitions associated to names \C{g} and \C{h}, we see that these
definitions are exactly the same: The \Coq{} system does not make any
difference between these two ways of describing a two-argument function.

\begin{coq}{name=print_gh}{width=6cm}
Print g.
$~$
Print h.
$~$
\end{coq}
\begin{coqout}{run=print_gh_run}{width=6cm}
g = fun n m : nat => n + m * 2
  : nat -> nat -> nat
h = fun n m : nat => n + m * 2
  : nat -> nat -> nat
\end{coqout}
\coqrun{name=print_gh_run}{def_h,def_g,print_gh}
\index[vernac]{\C{Print}}

Since \C{g} is also a one-argument function, it is sensible to apply this
function to a single argument.  We can call this {\em partial application}
because \C{g} is also meant to be applied to two arguments.
As expected, the value we obtain this way is itself a function, of a
single argument, as illustrated by the following query:

\begin{coq}{name=check_g3}{width=5.5cm,title=Applying g partially}
Check g 3.
\end{coq}
\begin{coqout}{run=check_g3_run}{title=Response,width=6.5cm}
g 3 : nat -> nat
\end{coqout}
\coqrun{name=check_g3_run}{def_g,check_g3}
\index[concept]{partial application}
\index[concept]{typing an application}

Now function \C{g} can be applied to the numbers \C{2} and \C{3}, as
in \C{g 2 3}. This results in a term of type \C{nat}, the type of the
outputs of \C{g}, and we can even compute this value:

\begin{coq}{name=eval_g_2_3}{width=5cm}
Eval compute in g 2 3.
\end{coq}
\begin{coqout}{run=eval_g_2_3_run}{width=5cm}
= 8 : nat
\end{coqout}
\coqrun{name=eval_g_2_3_run}{def_g,eval_g_2_3}

Term \C{(g 2 3)} actually reads \C{((g 2) 3)} and features three
nested sub-expressions. The symbol \C{g} is the deepest
sub-expression and it is applied to \C{2} in \C{(g 2)}. The value of
this sub-expression is a function, which can be written:

\begin{coq}{name=step1}{}
fun m => 2 + m * 2
\end{coq}
\coqrun{name=step1run}{check,step1,dot}

Finally, \C{(g 2 3)} is in turn the application of the latter function to
\C{3}, which results in:

\begin{coq}{name=step2}{}
2 + 3 * 2
\end{coq}
\coqrun{name=step2run}{check,step2,dot}

by substituting the bound variable \C{m} in \C{fun m => 2 + m * 2} by
the value \C{3}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Higher-order functions}

Earlier in this section we defined functions like \C{f}, \C{g} and \C{h}
which operate on natural numbers. Functions whose arguments are
themselves functions are called \emph{higher-order functions}.
\index[concept]{higher-order}
For instance, the following definition introduces a function that
takes a function from \C{nat} to \C{nat} and produces a new function
from \C{nat} to \C{nat}, by iterating its argument.

\begin{coq}{name=repeat_twice_def}{}
Definition repeat_twice (g : nat -> nat) : nat -> nat :=
  fun x => g (g x).
\end{coq}
\coqrun{name=repeat_twice_def_run}{repeat_twice_def}

Once again, let us scrutinize this \Coq{} statement. The first line
asserts that the name of the function to be defined is \C{repeat_twice}.
We also see that it has one argument, a function of
type \C{nat -> nat}.  For later reference in the definition of
\C{repeat_twice}, the argument is given the name \C{g}.  Finally
we see that the value produced by the function \C{repeat\_twice}
is itself a function from \C{nat} to \C{nat}.

Reading the second line of this statement, we see that the value
of \C{repeat_twice} when applied to one argument is a new
function, described using the ``\C{fun .. => ..}'' construct.  The
argument of that function is called \C{x}.  After the \C{=>} sign, we
find the ultimate value of this function.  This fragment of text, \C{g
(g x)}, also deserves some explanation. It describes the
application of function \C{g} to an expression \C{(g x)}.  In turn,
the fragment \C{(g x)} describes the application of function \C{g} to
\C{x}. Remember that the  application of a function to an
argument is denoted by juxtaposing the function (on the left) and
the argument (on the right), separated by a space. Moreover,
application associates to the left: expressions made with
several sub-expressions side by side should be read as if there were
parentheses around the subgroups on the left. Parentheses are
only added when they are needed to resolve ambiguities.
For instance, the inner \C{(g x)} in
\C{(g (g x))} needs surrounding parentheses because expression
\C{(g g x)} reads \C{((g g) x)}.  The latter expression would be
ill-formed because it contains the sub-expression \C{(g g)} where
\C{g} receives a function as argument, while it is expected to receive
an argument of type \C{nat}.

We can play a similar game as in section~\ref{sec:fun-sev-args},
and scrutinize the expression obtained by applying the
function \C{repeat_twice} to  the function
\C{f} and the number \C{2}. Let us compute the resulting value of this
application:

\begin{coq}{name=eval_repeat_twice_f_two}{width=6cm}
Eval compute in repeat_twice f 2.
\end{coq}
\begin{coqout}{run=eval_repeat_twice_f_two_run}{width=6cm}
= 4 : nat
\end{coqout}
\coqrun{name=eval_repeat_twice_f_two_run}{exdef,repeat_twice_def,eval_repeat_twice_f_two}

Expression \C{(repeat_twice f 2)} actually reads
\C{((repeat_twice f) 2)} and features three nested sub-expressions separated by
spaces. The symbol \C{repeat_twice} is the deepest
sub-expression and it is applied to \C{f} in \C{(repeat_twice f)}.
According to the definition of the \C{repeat_twice} function, the value of
this sub-expression is a function, which is then applied to \C{2}.
% The value of the
%intermediate function is \C{(fun x => f (f x))}, so
The resulting expression is \C{(f (f 2))}, and given the
%Remembering the
definition of \C{f}, this expression can also
be read as \C{((2 + 1) + 1)}.  Thus, after computation, the result is \C{4}.

Function  \C{repeat_twice} is an instance of a function with several
arguments: as illustrated in section~\ref{sec:fun-sev-args}, its
partial application to a single argument provides a well-formed
function, from \C{nat} to \C{nat}:

\begin{coq}{name=check_repeat_twice_f_two}{width=6cm,title=Partial application}
Check (repeat_twice f).
\end{coq}
\begin{coqout}{run=check_repeat_twice_f_two_run}{title=Response,width=6cm}
repeat_twice f : nat -> nat
\end{coqout}
\coqrun{name=check_repeat_twice_f_two_run}{exdef,repeat_twice_def,check_repeat_twice_f_two}

Now looking at the type of \C{repeat_twice} and adding redundant parentheses
we obtain \C{(|==(nat -> nat)==| -> (|--nat--| -> nat))}:
once the first argument
\C{(f : |==nat -> nat==|)} is passed, we obtain a term the type of which is
the right hand side of the main arrow, that is \C{(|--nat--| -> nat)}.
By passing another argument, like \C{(2 : |--nat--|)}, we obtain an expression
the type of which is, again, the right hand side of the main arrow,
here \C{nat}.
Remark that each function has an arrow type and that the type of its
argument matches the left hand side of this arrow (as depicted with
different underline styles). When this is not the case, \Coq{} issues a
type error.

\begin{coq}{name=fail_check_repeat_twice_f}{width=5.5cm,title=Ill-formed
  application}
Check (repeat_twice f f).
\end{coq}
\begin{coqout}{run=fail_check_repeat_twice_f_run}{title=Response,width=6.2cm}
Error: The term "f" has type "nat -> nat"
while it is expected to have type "nat".
\end{coqout}
\coqrun{name=fail_check_repeat_twice_f_run;fail}{exdef,repeat_twice_def,fail_check_repeat_twice_f}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Local definitions}

The process of abstraction described at the beginning of this section
can be seen as the introduction of a name, the one used for the bound
variable, in place of a sub-expression that may appear at
several occurrences. For instance, in expression
\C{(fun x => x + x + x) B}, we use the variable \C{x} as an
abbreviation for \C{B}. It is specially useful when \C{B} happens to
be a very large expression: readability is improved by avoiding the
repetition of \C{B}, which may otherwise obfuscate the triplication
pattern. In the \Coq{}
language, declaring such an abbreviation can be made even more
readable by bringing closer the name of the abbreviation \C{x} and the
expression it refers to:

\begin{coq}{name=let}{}
let x := B in
   x + x + x
\end{coq}

In this expression the variable \C{x} is {\em bound} and can be used in
the text that comes after the \C{in} keyword.
Variants of this syntax make it possible to state the
type ascribed to the variable \C{x}, which may come handy when the
code has to be very explicit about the nature of the values being
abbreviated.
\index[concept]{binder}
Here is an example of usage of this syntax:

\begin{coq}{name=eval_let_expr}{width=6cm,title=Evaluating local definitions,label=lst:eval_let_expr}
Eval compute in
  let n := 33 in
  let e := n + n + n in
    e + e + e.
\end{coq}
\begin{coqout}{run=eval_let_expr_run}{title=Response,width=6cm}
 = 297 : nat
\end{coqout}
\coqrun{name=eval_let_expr_run}{eval_let_expr}

When it comes to comparing the values of computations, a local definition
has the same result as the expression where all occurrences of the bound
variable are replaced by the corresponding expression.  Thus, the example
expression above has exactly the same value as:

\begin{coq}{name=let_reduced}{}
(33 + 33 + 33) + (33 + 33 + 33) + (33 + 33 + 33)
\end{coq}

However, in practice the evaluation strategy used in a normalization
command like \C{Eval compute in ..} takes advantage of the
 \C{let  .. in ..} notation to
avoid duplicating computation efforts. In our example, the value of
the partial sum \C{(33 + 33 + 33)} is computed only once and shared at
every occurrence of the bound variable. This abbreviation facility can
thus also be used to organize intermediate computations.

\section{Data types, first examples}

A well-formed mathematical expression is just a juxtaposition of
symbols of a given language (and variables)
that respects the prescribed arities of
the operations. For instance, the expression:
\[(\top \vee \bot) \wedge b\]
is a well formed expression in the language $\{\top, \bot,\vee,\wedge\}$ of
boolean arithmetic, while expression:

\[ 0 + x \times (S\ 0) \]
is a well formed expression in the language $\{0,S, +, \times\}$ of
Peano arithmetic. In these examples, however, the usual axioms that
formalize the respective arithmetics confer a distinctive status to
the symbols $\top$ and $\bot$ for booleans, and to the symbols $0$ and
$S$ for natural numbers. More precisely, any variable-free boolean expression
is equal to either $\top$ or $\bot$ modulo these axioms, and any
variable-free expression in Peano arithmetic is equal either to $0$ or
to an iterated application of the symbol $S$ to $0$. In both
cases, the other symbols in the signature represent functions, whose
computational content is prescribed by the axioms.

In \Coq{}, such expressions are represented using a \emph{data type},
whose definition provides in a single declaration the name of the
type, the symbols of (constants and) operations that \emph{build}
elements of this type, plus some rules on how to compute on these
elements. These data types are introduced by the means of an
\emph{inductive type definition}.
One can explicitly define more operations on the elements of
the type by describing how they compute on a given argument in the
type using a case analaysis (or even a recursive definition) on the
syntactic shape of this argument.
This approach is used in a systematic way to define a variety of basic
data types, among which boolean values, natural numbers, pairs or
sequences of values are among the most prominent examples.
\index[concept]{inductive type}

%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean values}\label{ssec:boolval}

The collection $\mathbb{B} := \{\top, \bot\}$ of boolean values is
formalized by a type called \C{bool}, with two inhabitants \C{true}
and \C{false}. The declaration of this type happens
in one of the first files to be automatically loaded when \Coq{} starts,
so booleans look like a built-in notion.  Nevertheless, the type of
boolean values is actually defined in the following manner:

\begin{coq}{name=bool}{title=Declaration of bool}
Inductive bool := true | false.
\end{coq}
\coqrun{name=bool_run}{bool}
\index[vernac]{\C{Inductive}}

It is actually one of the simplest possible inductive definitions,
with only base cases, and no inductive ones. This
declaration states explicitly that there are exactly two
elements in type \C{bool}: the distinct constants \C{true} and \C{false},
called the \emph{constructors} of type \C{bool}.


\index[concept]{inductive type!constructor}

In practice, this means that we can \emph{build} a well-formed expression of
type \C{bool} by using either \C{true} or \C{false}.

\begin{coq}{name=check_true}{width=6cm,title=Queries}
Check true.
\end{coq}
\coqrun{name=check_true_run}{check_true}
\begin{coqout}{run=check_true_run}{width=6cm,title=Response}
true : bool
\end{coqout}

In order to \emph{use} a boolean value in a computation, we need a
syntax to represent the two-branch case analysis that can be performed
on an expression of type \C{bool}. The \Coq{} syntax for this case analysis is
``\C{if .. then .. else ..}'' as in:

\begin{coq}{name=if_example}{}
if true then 3 else 2
\end{coq}
\coqrun{name=if_example_run}{check,if_example,dot}
\index[coq]{\C{if .. then .. else ..}}
More generally, we can define a function that takes a boolean value as
input and returns one of two possible natural numbers in the following
manner:

\begin{coq}{name=definetwoVthree}{}
Definition twoVthree (b : bool) := if b then 2 else 3.
\end{coq}
\coqrun{name=definetwoVthree_run}{definetwoVthree}

As one expects, when \C{b} is \C{true}, the expression
\C{(twoVthree b)} evaluates to \C{2}, while it evaluates to \C{3} otherwise:

\begin{coq}{name=eval_twoVthree}{width=7cm,title=Evaluating twoVthree}
Eval compute in twoVthree true.
Eval compute in twoVthree false.
\end{coq}
\begin{coqout}{run=eval_twoVthree_run}{title=Response,width=5cm}
  = 2 : nat
  = 3 : nat
\end{coqout}
\coqrun{name=eval_twoVthree_run}{definetwoVthree,eval_twoVthree}

As illustrated on this example,
the \C{compute} command rewrites any term of the shape
\C{if true then t1 else t2} into \C{t1} and any term of the shape
\C{if false then t1 else t2} into \C{t2}.

The \mcbMC{} library provides a collection of boolean operations that
mirror reasoning steps on truth values.  The functions are called
\C{negb}, \C{orb}, \C{andb}, and \C{implyb}, with notations
\C{\~\~},  \C{||}, \C{&&}, and \C{==>}, respectively
(the last three operators are
infix, i.e., they appear between the arguments, as in \C{b1 && b2}).
Note that the symbol \C{\~\~} uses two characters \C{\~}: it should
not be confused with two consecutive occurrences of the one-character symbol
\C{\~}, which would normally be written with a separating space.
The latter has a meaning in \Coq{}, but is almost never used
in the \mcbMC{} library.

For instance, the functions \C{andb} and \C{orb} are defined as follows.

\begin{coq}{name=define_andb_orb}{}
Definition andb (b1 b2 : bool) := if b1 then b2   else false.
Definition orb  (b1 b2 : bool) := if b1 then true else b2.
\end{coq}
\coqrun{name=andor}{define_andb_orb}
\index[coq]{\C{andb}}

% \subsubsection{TODO : A note on associativity for notations}

\subsection{Natural numbers}\index[concept]{natural number}
\label{ssec:nat}

The collection of natural numbers is formalized by a type called
\C{nat}. An inhabitant of this type is either the constant \C{O}
(capital ``o'' letter) representing zero, or an
application to an existing natural number of the function symbol \C{S}
representing the successor:

\begin{coq}{name=coq_nat}{}
Inductive nat := O | S (n : nat).
\end{coq}
\coqrun{name=nat}{coq_nat}
\index[coq]{\C{nat}}
\index[coq]{\C{S}}
\index[coq]{\C{O}}

This inductive definition of the expressions of type \C{nat} has one
base case, the constant \C{O}, and one inductive case, for the natural
numbers obtained using the successor function at least once: therefore
\C{O} has type \C{nat}, \C{(S O)} has type \C{nat}, so does
\C{(S (S O))}, and
so on, and any natural number has this shape. The constant \C{O} and
the function \C{S} are the constructors of type \C{nat}.

When interacting with
\Coq{}, we will often see decimal
notations, but these are only a parsing and display
facility provided to the user for readability: \C{O} is displayed
$0$, \C{(S O)} is displayed $1$, etc.  Users can also type decimal
numbers to describe values in type \C{nat}: these are automatically
translated into terms built (only) with \C{O} and \C{S}. In the rest
of this chapter, we call such a term a \emph{numeral}.

The \mcbMC{} library provides a few notations to make the use of the
constructor \C{S} more intuitive to read.  In particular, if \C{x}
is a value of type \C{nat}, \C{x.+1} is another way to write
\C{(S x)}.  The ``\C{.+1}'' notation binds more strongly than function
application, so that this notation makes it possible to avoid some
needs for parentheses: assuming  that \C{f} is a function of type
\C{nat -> nat} the expression \C{(f n.+1)} reads
\C{(f (S n))}.

\begin{coq}{name=f_plus_one}{width=5cm,title=Queries}
Check fun n => f n.+1.
\end{coq}
\begin{coqout}{run=f_plus_one_run}{width=7cm,title=Response}
fun n : nat => f n.+1 : nat -> nat
\end{coqout}
\coqrun{name=f_plus_one_run}{ssr,exdef,f_plus_one}
\index[coq]{\C{(_ .+1)}|seealso {\C{S}}}

When defining functions that operate on natural numbers, we can
proceed by case analysis, as was done in the previous section for boolean
values. Here as well, there are two cases: either the natural number used in
the computation is \C{O} or it is \C{p.+1} for
some \C{p}, and the value of \C{p} may be used to describe the
computations to be performed. This case analysis can be seen as
matching against \emph{patterns}: if the data fits one of
the patterns, then the computation proceeds with the expression in the
corresponding branch.  Such a case analysis is therefore also called
\emph{pattern matching}. Here is an example:

\begin{coq}{name=predn}{}
Definition predn n := if n is p.+1 then p else n.
\end{coq}
\coqrun{name=predn_run}{ssr,predn}
\index[coq]{\C{predn} |seealso {\C{.-1}}}

The function \C{predn} returns the predecessor of a natural number
when it exists, and 0 otherwise. In this definition \C{p.+1} is a
pattern. The value bound to the name \C{p} mentioned in this pattern is not
known in advance; it is actually computed at the moment the \C{n} is matched
against the pattern. For instance:

\begin{coq}{name=compute_match}{width=7cm,title=Evaluating predn}
Eval compute in predn 5.
\end{coq}
\begin{coqout}{run=compute_match_run}{width=5cm,title=Response}
= 4 : nat
\end{coqout}
\coqrun{name=compute_match_run}{ssr,compute_match}

The \C{compute} command rewrites any term of the shape
\C{if 0 is p.+1 then t1 else t2} into \C{t2} and any term of the shape
\C{if k.+1 is p.+1 then t1 else t2} into \C{t1} where all occurrences of
\C{p} have been replaced by \C{k}. In our example, as the value of
\C{k.+1} is \C{5}, \C{k} and hence \C{t2} is \C{4}.


The symbols that are allowed in a pattern are essentially restricted
to the constructors, here \C{O} and \C{S}, and to variable names.
Thanks to notations however, a pattern can also contain
occurrences of the notation ``\C{.+1}'' which represents \C{S}, and
decimal numbers, which represent the corresponding terms built with
\C{S} and \C{O}.  When a variable name occurs, this variable can be
re-used in the result part.
Remark that we did omit the type of the input \C{n}. We can omit this
type because matching
\C{n} against  the \C{p.+1} pattern imposes that \C{n} has type
\C{nat}, as the \C{S} constructor belongs to \emph{exactly}
one inductive definition, namely the one of \C{nat}.

The pattern used in the \C{if} statement can be composed of
several nested levels of the \C{.+1} pattern.  For instance,
if we want to write a function
that returns \(n-5\) for every input \(n\) larger than or equal to 5 and 0
for every input smaller than 5, we can write the following definition:

\begin{coq}{name=pred5}{}
Definition pred5 n :=
  if n is u.+1.+1.+1.+1.+1 then u else 0.
\end{coq}
\coqrun{name=pred5_run}{ssr,pred5}

On the other hand, if we want to describe a different computation for
three different cases and use variables in more than one case, we need
the more general ``\C{match .. with .. end}'' syntax.  Here is an
example:

\begin{coq}{name=awkward5}{}
Definition three_patterns n :=
  match n with
    u.+1.+1.+1.+1.+1 => u
  | v.+1 => v
  | 0 => n
  end.
\end{coq}
\coqrun{name=awk5_run}{ssr,awkward5}

This function maps any number \(n\) larger than or equal to 5 to \(n-5\),
any number \(n \in \{1, \ldots, 4\}\) to \(n-1\), and \(0\) to \(0\).

The pattern matching construct ``\C{match .. with .. end}'' may contain an
arbitrarily large number of {\em pattern matching rules} of the form
``\emph{pattern}\C{ =>$~$}\emph{result}''
separated by the \C{|} symbol.  Optionally one can
prefix the first pattern matching rule with \C{|}, in order to make each line
begin with \C{|}. Each pattern matching rule results in a new rewrite
rule available to the \C{compute} command.
\index[concept]{pattern matching}
All
the pattern matching rules are tried successively against the input.  The
patterns may overlap, but the result is given by the first pattern that
matches.
For instance with the function \C{three_patterns}, if the input is
\C{2}, in other words \C{0.+1.+1}, the first
rule cannot match, because this would require that \C{0} matches
\C{u.+1.+1.+1} and we know that \(0\) is not the successor of any
natural number; when it comes to the second rule \C{0.+1.+1} matches
\C{v.+1}, because the rightmost \C{.+1} in the value of \C{2} matches
the rightmost \C{.+1} part in the pattern and \C{0.+1} matches the \C{v} part
in the pattern.

A fundamental principle is enforced by \Coq{} on case analysis:
\emph{exhaustiveness}.  The patterns must cover all constructors of
the inductive type.  For example, the following definition is
rejected by \Coq{}.

\begin{coq}{name=f_plus_one_err}{width=6cm,title=Non-exhaustive case analysis}
Definition wrong (n : nat) :=
  match n with 0 => true end.
$~$
\end{coq}
\begin{coqout}{run=f_plus_one_err_run}{width=6cm,title=Response}
Error: Non exhaustive pattern-matching:
no clause found for
pattern S _
\end{coqout}
\coqrun{name=f_plus_one_err_run;fail}{f_plus_one_err}
\index[concept]{pattern matching!exhaustiveness}

We conclude the section by showing a syntactic facility to scrutinize
multiple values at the same time.

\begin{coq}{name=awkward6}{}
Definition same_bool b1 b2 :=
  match b1, b2 with
  | true, true => true
  | false, false => true
  | _, _ => false
  end.
\end{coq}
\coqrun{name=awk6_run}{ssr,awkward6}

Here, the reserved word \C{_} stands for a ``throwaway variable'', i.e.,
a variable that we choose to give no name because we are not going to
reference it (for example, the constant function
\C{fun (n : nat) => 2} can also be written
\C{fun (_ : nat) => 2}).
\index[coq]{\C{_}}

The above code defining \C{same_bool} is parsed as follows:

\begin{coq}{name=awkward7}{}
Definition same_bool b1 b2 :=
  match b1 with
  | true => match b2 with true => true | _ => false end
  | false => match b2 with true => false | _ => true end
  end.
\end{coq}
\coqrun{name=awk7_run}{ssr,awkward7}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Recursion on natural numbers}\label{ssec:recnat}

\index[concept]{recursion}

Using constructors and pattern matching, it is possible to add or
subtract one, but not to describe the addition or subtraction of
arbitrary numbers. For this purpose, we resort to recursive
definitions. The addition operation is defined in the
following manner:

\begin{coq}{name=redefine_add}{}
Fixpoint addn n m :=
  if n is p.+1 then (addn p m).+1 else m.
\end{coq}
\coqrun{name=redef_run}{ssr,redefine_add}
\index[vernac]{\C{Fixpoint}}
\index[coq]{\C{addn}}
As this example illustrates, the keyword for defining a recursive
function in \Coq{} is \C{Fixpoint}: the function being
defined, here called \C{addn}, is used in the definition of the
function \C{addn} itself.  This text expresses that the value of
\C{(addn p.+1 m)} is
\C{(addn p m).+1} and that the value \C{(addn 0 m)} is \C{m}.
This first equality may
seem redundant, but there is progress when reading this equality from
left to right: an addition with \C{p.+1} as the first argument
is explained with the help of addition with \C{p} as the first
argument, and \C{p} is a smaller number than \C{p.+1}.  When considering the
expression \C{(addn 2 3)}, we can know the value by performing the following
computation:
\begin{tabbing}
\C{adfasdfasdfafafafafafaf}\=\kill
\C{(addn 2 3)} \> use the ``then'' branch, \C{p = 1}\\
\C{(addn 1 3).+1} \> use the ``then'' branch, \C{p = 0}\\
\C{(addn 0 3).+1.+1} \> use the ``else'' branch\\
\C{3.+1.+1}\> remember that \C{5 = 3.+1.+1}
\end{tabbing}
\index[concept]{computation}
When the computation finishes, the symbol \C{addn} disappears.  In
this sense, the recursive definition is really a definition.  Remark that
what the \C{(addn n m)} program does is simply to pile \C{n} times the
successor symbol on top of \C{m}.

An alternative way of writing \C{addn} is to provide explicitly the
rules of the pattern-matching at stake instead of relying on an \C{if}
statement. This can be written as follows:

\begin{coq}{name=addn_redef2}{}
Fixpoint addn n m :=
  match n with
  | 0 => m
  | p.+1 => (addn p m).+1
  end.
\end{coq}
\coqrun{name=test_addn_redef2}{ssr,addn_redef2}
\index[coq]{\C{addn}}
With this way of writing the recursive function, it becomes obvious that
pattern-matching rules describe equalities between two symbolic
expressions, but these equalities are always used from left to right during
computations.

When writing recursive functions, the \Coq{} system imposes the
constraint that the described computation must be \emph{guaranteed to
terminate}.  The reason for this requirement is sketched in
section~\ref{ssec:indreason}.
This guarantee is obtained by analysing the description of the
function, making sure that recursive calls always happen on a
given argument that decreases.
Termination is obvious when the recursive calls happen
only on ``syntactically smaller arguments''. For instance, in our
example \C{addn}, the function is defined by matching its first
argument \C{n} against the patterns \C{p.+1} and \C{0}; in the branch
corrsponding to the pattern \C{p.+1}, the recursive call happens on
\C{p}, a strict subterm of \C{p.+1}. Had we matched the argument \C{n}
against the pattern \C{p.+1.+1}, then the recursive call would have been
allowed on arguments \C{p} or \C{p.+1}, but not \C{p.+1.+1}.
\marginnote{Here and earlier, we do not comment (yet) on the fact that
\C{.+1.+1} is displayed \C{.+2}}
\marginnote{Refer to CoqArt for more on termination issues?}
\index[concept]{recursion!termination}
\index[concept]{termination}

  An erroneous, in the sense of non-terminating,
definition is rejected by \Coq{}:

\begin{coq}{name=loop}{width=6cm,title=Non-terminating program}
Fixpoint loop n :=
 if n is 0 then loop n else 0.
$~$
\end{coq}
\begin{coqout}{run=loop_run}{title=Response,width=6cm}
Error: Recursive call to loop has
principal argument equal to "n"
instead of a subterm of "n".
\end{coqout}
\coqrun{name=loop_run;fail}{ssr,loop}

% In function \C{add}, the first argument \C{n} is only used to
% repeat \C{n} times the operation of adding a \C{.+1} on the second
% argument.  This corresponds to the fact that the \C{p} is only used in
% the recursive call.  The programming language makes it possible to do
% more.  For instance, for a given function \(f\), we might want to add all
% the values \(f 0 + f 1 + \cdots + f n\).  This would be done in the
% following manner:
%
% \begin{coq}{name=example_sum_f}{}
% Fixpoint sum_f (f : nat -> nat) (n : nat) :=
%   if n is p.+1 then add (f n) (sum_f p) else f 0.
% \end{coq}
%
If addition amounts to repeating the operation of applying \C{.+1}
to one of the arguments, subtraction amounts to repeating the
operation of fetching a subterm of the first argument.  This is also
easily expressed using pattern matching constructs.  Here again,
subtraction is already defined in the libraries, but we can play the game
of re-defining our own version.

\begin{coq}{name=sub}{}
Fixpoint subn m n : nat :=
  match m, n with
  | p.+1, q.+1 => subn p q
  | _ , _ => m
  end.
\end{coq}
\coqrun{name=sub_run}{ssr,sub}
\index[coq]{\C{subn}}
From a mathematical point of view, this definition can be quite
unsettling. The second pattern matching rule indicates that when
any argument of the subtraction is 0, then the result is
the first argument.  This is exactly what one would expect when the
second argument is 0; but this rule also covers the case where the
second argument is non-zero while the first argument is 0: in that
case, the result of the function is zero.

On paper, the expression \(m - n\), for $m, n \in
\mathbb{N}$, is usually understood as an integer, which is negative
when $n > m$. But here the output of \C{subn} is constraint by its
output type to be a natural number. Moreover, any function defined in
\Coq{} has to be total, i.e., has to assign a value to any element in
the type of its arguments.

Since \C{subn} has type \C{nat -> nat -> nat},
an element \emph{in type} \C{nat} has to be output by the function
even in the case when the second argument is non-zero and the first
argument is zero. The default value output in this case is \C{0}, so
that in the end \C{subn} sends two naturals \(m\) and
\(n\) to \(\max\left\{m-n, 0\right\}\) as opposed to \(m-n\).


 Thus, mathematically speaking,
\C{subn} sends two naturals \(m\) and \(n\) to
\(\max\left\{m-n, 0\right\}\) as opposed to \(m-n\).
This oddity is imposed by
the fact that any function defined in \Coq{} has to be total, i.e., has
to assign a value to any element in the type of its arguments. Since
\C{subn} has type \C{nat -> nat -> nat},
an element \emph{in type} \C{nat} has to be
output by the function even in the case when  the second argument is
non-zero and the first argument is zero. This problem disappears with
the introduction of another type of numbers, with negative integers.
(Alternatively, it is possible to implement partial functions by
extending the output type; see Section~\ref{sec:othercontainers}.)
\marginnote{The discussion above needs to be improved. And subn is may
be not the right example, for its main raison d'Ãªtre is the definition
of comparison.}

We can also write a recursive function with two arguments of
type \C{nat}, that returns \C{true} exactly when the two arguments are
equal:

\begin{coq}{name=nat_eq_def}{}
Fixpoint eqn m n :=
  match m, n with
  | 0, 0 => true
  | p.+1, q.+1 => eqn p q
  | _, _ => false
  end.
\end{coq}
\coqrun{name=nateq_run}{ssr,nat_eq_def}

The last rule in the code of this function actually covers two cases :
\C{0, _.+1} and \C{_.+1, 0}.

For equality test functions, it is useful to add a more intuitive
notation.  For instance we can attach a notation to \C{eqn} in
the following manner:

\begin{coq}{name=notation_my_eq}{}
Notation "x == y" := (eqn x y).
\end{coq}
\coqrun{name=notation_eq}{ssr,notation_my_eq}

Now
that we have programmed this equality test function, we can verify
that the \Coq{} system really identifies various ways to write the same
natural number.

\begin{coq}{name=equalities}{width=6cm}
Eval compute in 0 == 0.
Eval compute in 1 == S 0.
Eval compute in 1 == 0.+1.
Eval compute in 2 == S 0.
Eval compute in 2 == 1.+1.
Eval compute in 2 == addn 1 0.+1.
\end{coq}
\begin{coqout}{run=equalities_run}{width=6cm}
= true : bool
= true : bool
= true : bool
= false : bool
= true : bool
= true : bool
\end{coqout}
\coqrun{name=equalities_run}{ssr,equalities}

% Indeed, rules \C{eqn 0 0 $\rightarrow$ true},
% \C{eqn p.+1 q.+1 $\rightarrow$ eqn p q},
% \C{eqn p.+1 0 $\rightarrow$ false} and
% \C{eqn 0 p.+1 $\rightarrow$ false} are included in the \C{compute}
% normalization strategy, after the recursive definition of the \C{eqn}
% function.


In this section, we introduced a variety of functions and notations
for operations on natural numbers.  In practice, these functions and
notations are already provided by the \mcbMC{} library.  In particular
it provides addition (named \C{addn}, infix notation \C{+}),
multiplication
(\C{muln}, \C{*}), subtraction (\C{subn}, \C{-}), division (\C{divn},
\C{\%/}),  modulo (\C{modn}, \C{\%\%}), exponentiation (\C{expn}, \C{\^}),
equality comparison (\C{eqn}, \C{==}), order
comparison (\C{leq}, \C{<=}) on natural numbers. All these operations
output natural numbers: as explained above, subtraction is made to
return \(0\) when the subtrahend exceeds the minuend; similarly,
division is integer division.  The trailing \C{n} in
the names is chosen to signal that these operations are on the \C{nat} data
type.  Postfix notations such as \C{.-1} and \C{.*2} are provided for
the predecessor and double functions.
\index[coq]{\C{(_ .-1)}}
\index[coq]{\C{(_ .*2)}}

We detail here the definition of \C{leq} since it will be often used
in examples.

\begin{coq}{name=leq}{}
Definition leq m n := m - n == 0.
Notation "m <= n" := (leq m n).
\end{coq}
\coqrun{name=leq_run}{ssr,leq}

Note that this definition crucially relies on the fact that
subtraction computes to \C{0} whenever the first argument is less than
or equal to the second argument.

The \mcbMC{} library also provides concepts that make sense only
for the \C{nat} data type, like the
test functions identifying \C{prime} and \C{odd} numbers. In that
case, the trailing \C{n} is omitted in their name.

We strongly advise the reader wanting to explore the \mcbMC{} library
to browse their source
files\footnote{\url{http://math-comp.github.io/math-comp/htmldoc/libgraph.html}}
and not to limit herself to queries to the toplevel. The
information provided by the \C{Print} and \C{About} commands is
useful to understand how to use the objects defined in the libraries
once they are known by their name. By contrast, the source
files describe what is formalized, under which name and notation.

\mantra{Each file in the \mcbMC{} library
starts with a banner describing all the concepts and associated
notations introduced by the file.
There is no better way to browse the library than reading these banners.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Container datatypes}\label{sec:poly}
\section{Containers}\label{sec:poly}


A \emph{container} is a data type which describes a collection of
objects grouped together so that they can be manipulated as a single
object. For instance, we might want to compute the sequence of all
predecessors or all divisors of a number.  We could define the
following data type for this purpose:

\begin{coq}{name=listn_def}{}
Inductive listn := niln | consn (hd : nat) (tl : listn).
\end{coq}

The elements of this datatype are (one possible implementation of)
lists of zero or more natural numbers; the first constructor
\C{niln} builds the empty list, whereas the second constructor
\C{consn} builds a nonempty list by combining a natural number \C{hd}
with an already existing list \C{tl}.
For example:

\begin{coq}{name=cons_mono_err}{width=6.5cm}
Check consn 1 (consn 2 niln).
Check consn true (consn false niln).
$~$
$~$
\end{coq}{}{}
\begin{coqout}{run=cons_mono_err_run}{width=5.7cm}
consn 1 (consn 2 niln) : listn
Error: The term "true" has
type "bool" while it is
expected to have type "nat".
\end{coqout}{}{}
\coqrun{name=cons_mono_err_run;fail}{listn_def,cons_mono_err}

As expected, \C{listn} %elements of this data type
cannot hold boolean values.
So if we need to
manipulate a list of booleans we have to define a similar data type:
\C{listb}.

\begin{coq}{name=listb_def}{}
Inductive listb := nilb | consb (hd : bool) (tl : listb).
\end{coq}
\coqrun{name=listb_run}{listb_def}

This approach is problematic for two reasons.  First, every time we
write a function that manipulates a list, we have to decide a priori
if the list holds numbers or booleans, even if the program does not
really use the objects held in the list.
A concrete example is the function that computes the size of the list;
in the current setting such a function has to be written twice.
Worse, starting from the next chapter we will prove properties of programs,
and given that the two size functions are ``different'', we would have
to prove such properties twice.

However it is clear that the two data types we just defined follow
a similar schema, and so do the two functions for computing the size of
a list
or the theorems we may prove about these functions.  Hence, one would
want to be able to write something
like the following, where $\alpha$ is a schematic variable:

\begin{coq}{name=list_def}{}
Inductive list := nil | cons (hd : $\alpha$) (tl : list).
\end{coq}
\coqrun{name=list_run;fail}{list_def}

\noindent This may look familiar jargon to some readers. In the
present context however, we would rather like to avoid appealing to
any notion of schema, that would be somehow added on top of the
\Coq{} language. This way, we will make possible the writing of
formal sentences with arbitrary quantifications on this parameter
$\alpha$.

%  We want to
% reason and
% prove theorems about such data types and related programs inside the formal
% language \Coq{} provides and we want the proofs of these theorems
% theorems to be first
% class citizen too (see for example chapter~\ref{ch:sigmabool}).
%
% This language is powerful enough to fully characterize the generic
% list data type without appealing to an intuitive but external notion of
% schema.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The (polymorphic) sequence data type}
\index[concept]{polymorphism}

The \mcbMC{} library provides a generic data type to hold
several objects of any given type \C{A}. This is the data type \C{seq},
defined as follows:

\begin{coq}{name=seq_def}{}
Inductive seq (A : Type) := nil | cons (hd : A) (tl : seq A).
\end{coq}
\coqrun{name=seq_run}{seq_def}


The name \C{seq} refers to (finite) ``sequences'', also called
``lists''. This definition actually describes the type
of lists as a {\em polymorphic type}. This means that there is a
different type \C{(seq A)} for each possible choice of type \C{A}.  For example
\C{(seq nat)} is the type of sequences of natural numbers, while
\C{(seq bool)} is the type of sequences of booleans.
The type \C{(seq A)} has two
constructors, named \C{nil} and \C{cons}. Constructor \C{nil}
represents the empty sequence. The type of the
constructor \C{cons} is devised specifically to describe how to produce a
new list of type \C{(seq A)} by combining an element of \C{A}, the
\emph{head} of the sequence, and an
existing list of type \C{(seq A)}, the \emph{tail} of the sequence.  This
also means that this data-type
does not allow users to construct lists where the first element would be
a boolean value and the second element would be a natural number.

In the declaration of \C{seq}, the keyword \C{Type} denotes the
\emph{type of all data types}.  For example \C{nat} and \C{bool} are of type
\C{Type}, and can be used in place of \C{A}.
In other words \C{seq} is a function of type \C{(Type -> Type)}, sometimes
called a \emph{type constructor}.  The symbol \C{seq} alone does not
denote a data type,
but if one passes to it a data type, then it builds one.  Remark
that this also means that \C{(seq (seq nat))} is a valid data type
(namely, the type of lists of lists of natural numbers), and
that the construction can be iterated.
Types again avoid confusion: it is not licit to form the type \C{(seq 3)},
since the argument \C{3} has type \C{nat}, while the function
\C{seq} expects an argument of type \C{Type}.\footnote{For historical
reasons \Coq{} may display the type of \C{nat} or \C{bool} as \C{Set}
and not \C{Type}.  We beg the reader to ignore this detail, which
plays no role in the \mcbMC{} library.}

In principle, the constructors of such a polymorphic data type feature
a type argument:
\C{nil} is a function that takes a type \C{A} as argument and returns
an empty list of type \C{(seq A)}. The \emph{type} of the output of
this function hence depends on the \emph{value of this input}. The
type of \C{nil} is thus not displayed with the arrow notation
``\C{.. -> ..}'' that we have used so far for the type of
functions. It is rather written as follows:

\begin{coq}{name=type_of_nil}{}
  forall A : Type, seq A
\end{coq}
\index[coq]{\C{forall}}
so as to \emph{bind} the value \C{A} of the argument in the type of
the output. The same goes for the other constructor of \C{seq}, named
\C{cons}.  This function actually takes three arguments: a type \C{A},
a value in this type, and a value in the type \C{(seq A)}.  The type
of \C{cons} is thus written as follows:

\begin{coq}{name=type_of_cons}{}
  forall A : Type, A -> seq A -> seq A
\end{coq}
 Since the type of
the output does not depend on the second and third arguments of
\C{cons}, respectively of type \C{A} and \C{(seq A)}, the type of
\C{cons} features two arrow separators for these.
Altogether, we conclude
that the sequence holding a single element \C{2 : nat} can be
constructed as
\C{(cons nat 2 (nil nat))}. Actually, the two
occurrences of type \C{nat} in this term are redundant: the tail of a
sequence is a sequence with elements of the same type. Better yet,
this type can be
\emph{inferred} from the type of the given element \C{2}. One can
thus write the sequence as  \C{(cons _ 2 (nil _))}, using the
placeholder \C{_} to
denote  a subterm, here a type, to be inferred by \Coq{}.
In the case of \C{cons}, however,
one can be even more concise. Let us ask for
information about \C{cons} using the command \C{About}:

\begin{coq}{name=about_cons}{width=3cm,title=Query}
About cons.
$~$
$~$
\end{coq}
\begin{coqout}{run=about_cons_run;dots}{width=9cm,title=Response}
cons : forall A : Type, A -> seq A -> seq A
...
Argument A is implicit and maximally inserted
\end{coqout}
\coqrun{name=about_cons_run}{ssr,about_cons}
\index[concept]{implicit argument}

The \Coq{} system provides a mechanism to avoid that
users need to give the type argument to the \C{cons} function when it
can be inferred.  This is
the information meant by the message ``\C{Argument A is implicit and
  ..}''.  Every time users write \C{cons}, the system automatically
inserts an argument in place of \C{A}, so that this argument does not
need to be written (the argument is {\em implicit}).  It is then the
job of the \Coq{} system to guess what this argument is when looking at
the first explicit argument given to the function.  The same happens
to the type argument of \C{nil} in the built-in version of \C{seq}
provided by the \mcbMC{} library (although not in the version we
defined above).  In the end, this ensures that users can
write the following expression.

\begin{coq}{name=check_list_2}{width=6cm,title=Query}
Check cons 2 nil.
\end{coq}
\begin{coqout}{run=check_list_2_run}{width=6cm,title=Response}
[:: 2] : seq nat
\end{coqout}
\coqrun{name=check_list_2_run}{ssr,check_list_2}
\index[coq]{\C{(_ :: _)}}
This example shows that the function \C{cons} is only applied
explicitly to two arguments (the two arguments effectively declared
for \C{cons} in the inductive type declaration).
The first argument, which is implicit,
has been guessed so that it matches the actual type of \C{2}.  Also for
\C{nil} the argument has been guessed to match the constraints
that it is used in a place where a list of type \C{(seq
nat)} is expected.

To locally disable the
status of implicit arguments, one can prefix the name of a
constant with \C{@} and pass all arguments explicitly, as in
\C{(@cons nat 2 nil)} or \C{(@cons nat 2 (@nil nat))} or even
\C{(@cons _ 2 (@nil _))}.

This example, and the following ones, also show
that \Coq{} and the \mcbMC{} library provide
a collection of notations for lists.

\begin{coq}{name=check_list_3}{width=6cm,title=Query}
Check 1 :: 2 :: 3 :: nil.
Check fun l => 1 :: 2 :: 3 :: l.
$~$
\end{coq}
\begin{coqout}{run=check_list_3_run}{width=6cm,title=Response}
[:: 1; 2; 3] : seq nat
fun l : seq nat => [:: 1, 2, 3 & l]
  : seq nat -> seq nat
\end{coqout}
\coqrun{name=check_list_3_run}{ssr,check_list_3}
\index[coq]{\C{[:: .. , .. & ..]}}

In particular \Coq{} provides the infix notation \C{::} for
\C{cons}.  The \mcbMC{} library follows a general pattern for
n-ary operations obtained by the (right-associative)
iteration of a single binary one. In
particular \C{[::} begins the repetition
of \C{::} and \C{]} ends it.  Elements are separated by \C{,} (comma)
but for the last one separated by \C{&}.
For example, the above \C{[:: 1; 2; 3 & l]} stands for
\C{1 :: (2 :: (3 :: l))}.
For another example, one
can write  the boolean conjunction
of three terms as \C{[&& true, false & true]}.\footnote{Some n-ary
  notations use a different, but more evocative, last separator.  For
  example one writes \C{[|| b1, b2 | b3]} and \C{[==> b1, b2 => b3]}.}
\index[coq]{\C{["|"| .. , .. "| ..]}}
\index[coq]{\C{[&& .. , .. & ..]}}
\index[coq]{\C{[==> .. , .. => ..]}}
For sequences that are \C{nil}-terminated, a very frequent case,
the \mcbMC{} library provides an additional notation where all elements are
separated by \C{;} (semi-colon) and the last element, \C{nil},
is omitted.
\index[coq]{\C{[seq .. ; ..]}}

Pattern matching can be used to define functions on sequences, like
the following example which computes the first element of a non-empty
sequence, with a default value for the empty case:

\begin{coq}{name=head}{}
Definition head T (x0 : T) (s : seq T) := if s is x :: _ then x else x0.
\end{coq}
\coqrun{name=head_run}{ssr,head}

\subsection{Recursion for sequences}

\index[concept]{recursion}
Terms of type \C{(seq A)}, for a type \C{A}, are finite piles of
\C{cons} constructors, terminated with a \C{nil}. They are similar to
the terms of type \C{nat}, except that each \C{cons} constructor
carries a datum of type \C{A}. Here as well, recursion provides a way
to process sequences of arbitrary size.


The \Coq{} system provides support for the recursive definition of
functions over any inductive type (not just \C{nat}). The recursive
definition of the value of a
function at a given constructor can use the value of the function at
the arguments of the constructor. This defines the function over the
entire type since all values of an inductive type are finite piles of
constructors.

The size function counts the number of elements in a sequence:
% implements the correspondence between natural numbers and sequences:
% [DG] I wouldn't call it a "correspondence".

\begin{coq}{name=def_size}{}
Fixpoint size A (s : seq A) :=
  if s is _ :: tl then (size tl).+1 else 0.
\end{coq}
\coqrun{name=size_run}{ssr,def_size}
\index[coq]{\C{size}}
During computation on a given sequence, this function traverses
the whole sequence, incrementing the result for every
\C{cons} that is encountered.  Note that in this
definition, the function \C{size} is described as a two argument
function, but the recursive call \C{(size tl)} is done by providing
explicitly only one argument, \C{tl}. Remember that
%we started the
%\Coq{} session with, among other commands, the command ``\C{Set Implicit
%  Arguments}''.  According to this directive,
the \Coq{} system makes
arguments of functions that can be guessed from the type of the following
arguments automatically implicit, and \C{A} is implicit here. This
feature is already active in the expression defining \C{size}.

Another example of recursive function on sequences is a function that constructs
a new sequence whose entries are values of a given function applied to
the elements of an input sequence.  This function can be defined as:

\begin{coq}{name=def_map}{}
Fixpoint map A B (f : A -> B) s :=
  if s is e :: tl then f e :: map f tl else nil.
\end{coq}
\coqrun{name=map_run}{ssr,def_map}
\index[coq]{\C{map}}
This function provides an interesting case study for the definition of
appropriate notations. For instance, we will add a notation that
makes it more apparent that the result is {\em the sequence of all
expressions \(f(i)\) for \(i\) taken from another sequence}.

\begin{coq}{name=notation_map}{}
Notation "[ 'seq' E | i <- s ]" := (map (fun i => E) s).
\end{coq}
\coqrun{name=notation_map_run}{ssr,notation_map}
For instance, with this notation we write the computation of successors
for a given sequence of natural numbers as follows:

\begin{coq}{name=try_map_notation}{width=7.8cm,title=Query}
Eval compute in [seq i.+1 | i <- [:: 2; 3]].
\end{coq}
\begin{coqout}{run=try_map_notation_run}{width=4.3cm,title=Response}
= [:: 3; 4] : seq nat
\end{coqout}
\coqrun{name=try_map_notation_run}{ssr,try_map_notation}
\index[concept]{list comprehension}
\index[coq]{\C{[seq .. "| .. <- ..]}}
In addition to the function \C{map} and the associated notation
we describe here, the \mcbMC{} library
provides a large collection of useful functions and notations to work on
sequences, as described in the header of the file \lib{seq}.  For
instance \C{[seq i <- s | p]} filters the sequence \C{s} keeping only
the values selected by the boolean test \C{p}.
Another useful function for sequences is \C{cat} (with infix notation \C{++})
that is used to concatenate two sequences together.
\index[coq]{\C{(_ ++ _)}}
\index[coq]{\C{[seq .. <- .. "| ..]}}

%\marginnote{assia: Missing exercises here?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Option and pair data types}\label{sec:othercontainers}

Here is another example of polymorphic data type, which represents a
box that can be either empty, or contain a single value:

\begin{coq}{name=option}{}
Inductive option A := None | Some (a : A).
\end{coq}
\index[coq]{\C{option}}

Akin to a pointed version of \C{A}, type  \C{(option A)} contains a
copy of all the elements of \C{A},
built using the \C{Some} constructor, plus an extra element given by
the constructor \C{None}. It may be used to represent the output of a
partial function or of a filtering operation, using \C{None} as a
default element.

For example, function \C{only_odd} ``filters'' natural numbers, keeping the
odd ones and replacing the evens by the \C{None} default value:

\begin{coq}{name=only_odd}{}
Definition only_odd (n : nat) : option nat :=
  if odd n then Some n else None.
\end{coq}
\coqrun{name=only_odd_run}{ssr,option,only_odd}

Similarly, one can use the \C{option} type to define a partial function
\marginnote{This fails since None has no implicits}
which computes the head of a non-empty list:


\begin{coq}{name=ohead}{}
Definition ohead (A : Type) (s : seq A) :=
  if s is x :: _ then Some x else None.
\end{coq}
\coqrun{name=ohead_run}{ssr,option,ohead}


See also the sub-type kit presented in chapter~\ref{ch:sigmabool},
which makes use of the option type to describe a partial injection.
%\marginnote{assia: mention also odflt, omap and friends, in exercise?}

Another typical polymorphic data type is the one of pairs, that
lets one put together any two values:
\index[coq]{\C{(_ * _)} (pair)}
\index[coq]{\C{(_ , _)}}

\begin{coq}{name=pair}{}
Inductive pair (A B : Type) : Type := mk_pair (a : A) (b : B).
Notation "( a , b )" := (mk_pair a b).
Notation "A * B" := (pair A B).
\end{coq}
\coqrun{name=pair_run}{ssr,pair}

The type \C{pair} has two type parameters, \C{A} and
\C{B}, so
that it can be used to form any instance of pairs: \C{(pair nat bool)}
is the type of pairs with an element of type \C{nat} in its first
component and one of type \C{bool} in its second, but we can also form
\C{(pair bool nat)}, \C{(pair bool bool)}, etc. The type \C{pair} is
denoted by an infix \C{*} symbol, as in \C{(nat * bool)}.
% is the type of
%pairs that have a natural number as their first component and a boolean
%value as the second one.
This inductive type has
a \emph{single constructor} \C{mk_pair}. It takes over the two
polymorphic parameters, that become its two first, implicit arguments.
The constructor \C{mk_pair} has two more explicit arguments which are
the data stored in the pair. This constructor is associated with
a notation so that \C{(a, b)} builds the pair of \C{a} and \C{b}, and
\C{(a, b)} has type \C{(pair A B)}. For a given pair, we can
extract its first element, and we can provide a polymorphic definition
of this projection:

\begin{coq}{name=fst}{}
Definition fst A B (p : pair A B) :=
  match p with mk_pair x _ => x end.
\end{coq}
\coqrun{name=fst_run}{ssr,pair,fst}

We leave as an exercise the definition of the projection on the second
component of a pair. The \mcbMC{} library has a notation for these
projections: \C{c.1} is the first component of the pair \C{c}
and \C{c.2} is its second.

\begin{coq}{name=pairs}{width=6cm}
Check (3, false).
Eval compute in (true, false).1.
\end{coq}
\begin{coqout}{run=pairs_run}{width=6cm}
(3, false) : nat * bool
 = true : bool
\end{coqout}
\coqrun{name=pairs_run}{ssr,pairs}
As one expects, pairs can be nested. \Coq{} provides a slightly more complex
notation for pairs, which makes possible to write \C{(3,true,4)} for
\C{((3,true),4)}. In this example, the value \C{true} is the second
component of this tuple, or more precisely the second component of its
first one: it can thus be obtained as \C{(3,true,4).1.2}. This may be
a drawback, consequence of representing tuples as nested pairs. If
tuples of a certain fixed length are pervasive to a development, one
may consider defining another specific container type for this
purpose. See for instance exercise~\ref{ex:triple} for the definition
of triples.

We conclude this example with a remark on notations. After declaring
such a notation for the type of pairs, the expression \C{(a * b)}
becomes ``ambiguous'',
in the sense that the same infix \C{*} symbol can be used to multiply two
natural numbers as in \C{(1 * 2)} but also to write the type of pairs \C{(nat *
bool)}.  Such an ambiguity is somewhat justified by the fact that the pair
data type can be seen as the (Cartesian) product of the arguments.  The
ambiguity can be resolved by annotating the expression with a specific
label: \C{(a * b)\%N} interprets the infix \C{*} as multiplication of natural numbers,
while \C{(a * b)\%type} would interpret \C{*} as the pair data type
constructor. The \C{\%N} and \C{\%type} labels are said to be
\emph{notation scope delimiters} (for more details see
\cite[section 12.2]{Coq:manual}).\index[concept]{notation scope}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aggregating data in record types}
\index[concept]{record}\label{sec:records}

Inductive types with a single constructor, like the type \C{pair} in
section~\ref{sec:othercontainers} or the type \C{triple} of
exercise~\ref{ex:triple}, provide a general pattern to define a type
which aggregates existing objects into a single packaged one. This
need is so frequent that \Coq{} provides a specialized command
to declare this class of data type, called \C{Record}.

For example here is an instance of a type representing triples of
natural numbers, which can be used to represent a grid point in a
3-dimensional cone:

\begin{coq}{name=point}{}
Record point : Type := Point { x : nat; y : nat; z : nat }.
\end{coq}
\coqrun{name=point_run}{point}
\index[vernac]{\C{Record}}
This line of code defines an inductive type \C{point}, with no
parameter and with a single constructor \C{Point}, which has three
arguments each of type \C{nat}. Otherwise said, this type is:

\begin{coq}{name=point_ind}{}
Inductive point : Type := Point (x : nat) (y : nat) (z : nat).
\end{coq}
\coqrun{name=point_run2}{point_ind}
\index[concept]{record}

Using the \C{Record} version of this definition instead of its
equivalent \C{Inductive} allows us to declare names for the projections
at the time of the definition. In our example, the record \C{point}
defines three projections, named \C{x}, \C{y} and \C{z}
respectively. In the case where they come from a record definition,
these projections are also called \emph{fields} of the record.
One can thus write:

\begin{coq}{name=eval_point}{width=8.5cm,title=Query}
Eval compute in x (Point 3 0 2).
Eval compute in y (Point 3 0 2).
\end{coq}{}{}
\begin{coqout}{run=eval_point_run}{width=3.5cm,title=Response}
= 3 : nat
= 0 : nat
\end{coqout}{}{}
\coqrun{name=eval_point_run}{point,eval_point}

As expected, the code for the \C{x} projection is:

\begin{coq}{name=x}{}
Definition x (p : point) := match p with Point a _ _ => a end.
\end{coq}
\coqrun{name=x_run;fail}{point,x}

When an inductive type has a single constructor, like in the case of
\C{pair} or for records, the name of this constructor is not relevant
in pattern matching, as the ``case analysis'' has a single, irrefutable,
branch. There is a specific syntax for irrefutable patterns, letting
one rewrite the definition above as follows:

\begin{coq}{name=x2}{}
Definition x (p : point) := let: Point a _ _ := p in a.
\end{coq}
\coqrun{name=x2_run;fail}{ssr,point,x2}
\index[coq]{\C{let: .. := .. in ..}}
\index[concept]{pattern matching!irrefutable}

Record types are as expressive as inductive types with one
constructor: they can be polymorphic, they can package data with
specifications, etc. In particular, they will be central to the
formalization techniques presented in Part~\ref{part:form}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Section mechanism}\label{sec:section}
\index[concept]{section}
When several functions are designed to work on similar data, it is
useful to set a working environment where the common data is declared
only once.  Such a working environment is called a \C{Section}, and
the data that is local to this section is declared using \C{Variable}
commands.  A typical example happens when describing functions that
are polymorphic. In that case, definitions rely in a uniform way on a
given type parameter plus possibly on existing functions in this type.


\begin{coq}{name=iter}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Implicit Type x : T.

Fixpoint iter n op x :=
  if n is p.+1 then op (iter p op x) else x.

Fixpoint foldr a s :=
  if s is y :: ys then f y (foldr a ys) else a.

End iterators.
\end{coq}
\coqrun{name=iter_run}{ssr,iter}
\index[vernac]{\C{Section}}
\index[vernac]{\C{Variable}}
\index[vernac]{\C{Implicit Type}}
\index[coq]{\C{foldr}}\index[coq]{\C{iter}}
The \C{Section} and \C{End} keywords delimit a scope in which
the types \C{T} and \C{A} and the function \C{f} are given as
parameters: \C{T}, \C{A} and \C{f} are called \emph{section
  variables}.  These variables
are used in the definition of \C{iter} and \C{foldr}.

The \C{Implicit Type} annotation
tells \Coq{} that, whenever we name
an input \C{x} (or \C{x'}, or \C{x1}, \ldots), its type is supposed to be
\C{T}.  Concretely, it lets us omit an explicit type annotation
in the definition of programs using \C{x}, such as \C{iter}.
The  \C{Implicit Type} command is used frequently in the
\mcbMC{} library; the reader can refer to~\cite[section 2.7.18]{Coq:manual}
for a more detailed documentation of it.

When
the section is closed (using the \C{End} command), these variables
are abstracted: i.e., from then on, they start appearing as arguments
to the various functions that use them in the very same
% Variables are abstracted in their
order in which they are declared.
%In our example,
%\C{T} and \C{A} appear in the same order in the type of {\tt foldr} as
%in the variables declarations for the section.
Variables that are not actually used
in a given definition are omitted. For example, \C{f} plays no
role in the definition of \C{iter}, and thus does not become an
argument of \C{iter} outside the section.
This process %, where a function appears to have more arguments outside
%the section where it was defined than inside the section
is called
an {\em abstraction mechanism}.\index[concept]{Abstracting variables}

Concretely, the definitions written inside the section are
elaborated to the following ones.

\begin{coq}{name=iter2}{}
Fixpoint iter (T : Type) n op (x : T) :=
  if n is p.+1 then op (iter p op x) else x.
Fixpoint foldr (T A : Type) (f : T -> A -> A) a s :=
  if s is x :: xs then f x (foldr f a xs) else a.
\end{coq}
\coqrun{name=iter2_run}{ssr,iter2}

Finally, remark that \C{T} and \C{A} are implicit arguments; hence they
are not explicitly passed to \C{iter} and \C{fold} in the recursive calls.
\begin{coq}{name=about_fold}{width=2.9cm}
About foldr.
$~$
\end{coq}
\begin{coqout}{run=about_fold_run}{width=9.3cm}
foldr : forall T A : Type, (T -> A -> A) -> A -> seq T -> A
Arguments T, A are implicit ...
\end{coqout}
\coqrun{name=about_fold_run}{ssr,iter2,about_fold}


% It occurs when a section variable is used inside the definition or
% the type of a defined object.  In this case, the type \C{T} is a section
% variable that is used in the type of \C{iter}, so it needs to be
% abstracted for \C{iter} when the section is closed.
%
%
% The definition of \C{iter} in the Section has three explicit
% arguments. The first one, \C{n}, is used in
% a pattern-matching if-then-else statement and matched with a pattern of the
% form \C{p.+1}.  For this reason, we can guess that \C{n} has the type \C{nat}.
% The value returned by \C{iter} is either \C{x} or \C{op (iter p op x)}, so this
% tells us the value must have the same type as \C{x}.  Here the type of
% \C{x} is not fixed by the definition of \C{iter}, but by the previous clause:
% \C{Implicit Type x : T}.  So we know that the value returned by \C{iter}
% has to be \C{T}.  Scrutinizing the ``then'' part of the if-then-else statement,
% we can also infer that \C{op} must have the type \C{T -> T}.  So the type
% of \C{iter} relies in several occasions on the type \C{T}.  However, we are
% now outside the section, so the variable \C{T} is not in
% scope anymore.  This means that the function \C{iter}, when considered
% outside the section, must be ready to receive, {\em first an arbitrary type
%  \C{T}, then a natural number, then a function of type \C{T ->T}, then a
% value of type \C{T}}.  In the text defining \C{iter} (inside the section), the
% type \C{T} did not appear to be an argument, but once we are outside
% the section, the type \C{T} has to be an argument of \C{iter}.  Moreover,
% the argument for \C{T} receives a name, so that it can be mentioned
% in the type of the other arguments.  We need to re-use the \C{forall}
% notation that was already useful when mentioning generic data types.

% Now, let us study how this abstraction process works for the other definition
% in this section, \C{foldr}.  We know that the last argument \C{s} of \C{foldr}
% must be a sequence, because it is matched with a pattern that is specific
% to sequences.  Moreover, we know that the first element of this sequence,
% when it exists, is passed as first argument of the function \C{f}, and
% we know (from the type declaration at line 4) that the first argument of
% \C{f} should be of type \C{T}.  So \C{s} has to have type \C{seq T}.
% Looking at the ``then'' branch of the if-then-else statement, we also see
% that \C{foldr a xs} is used as the second argument to \C{f}, so it should
% have type \C{A}, so we can also infer that \C{a} should have the type \C{A}.
% So in all, the function \C{foldr} depends on all the section variables and
% they all have to be mentioned as arguments in its type outside the section.

We can now use \C{iter} to compute, for example,
the subtraction of \C{5} from \C{7}, or \C{foldr}
to compute the
sum of all numbers in \C{[:: 1; 2]}:

\begin{coq}{name=eval_iter}{width=8cm}
Eval compute in iter 5 predn 7.
Eval compute in foldr addn 0 [:: 1; 2].
\end{coq}
\begin{coqout}{run=eval_iter_run}{width=4cm}
 = 2 : nat
 = 3 : nat
\end{coqout}
\coqrun{name=eval_iter_run}{ssr,iter,eval_iter}

%\marginnote{assia: what about a good practice box here? for naming policy
%  for bound variables}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic computation}\label{sec:symcomp}
\index[concept]{computation!symbolic}

As we mentioned in section~\ref{sec:functions}, the \C{Eval compute}
command of \Coq{} can be used to normalize expressions, which
eventually leads to simpler terms, like numerals. This flavour of
computation can however accommodate to the presence of parameters in
the expression to be computed.

% Let us come back to the example studied in Section~\ref{sec:section} where
% the definition of the \C{iter} function happens under a so called
% \emph{local context}, consisting of the parameter variables \C{T},
% \C{A} and \C{f}. While staying in the scope of the \C{iterators}
% section, this local context is fixed and parameterizes all the
% definitions or queries to \Coq{}.

\begin{coqdef}{name=enditer}End iterators.\end{coqdef}

\begin{coq}{name=sec}{}
Section iterators.

Variables (T : Type) (A : Type).
Variables (f : T -> A -> A).

Fixpoint foldr a s :=
  if s is x :: xs then f x (foldr a xs) else a.
\end{coq}

If we ask for the type of
\C{foldr} in the middle of the section, we see that
it is not a polymorphic function (yet).

\begin{coq}{name=about_fold_sec}{width=3.5cm}
About foldr.
\end{coq}
\begin{coqout}{run=before_section_run;dots}{width=8.5cm}
foldr : A -> seq T -> A
\end{coqout}
\coqrun{name=before_section_run}{ssr,sec,about_fold_sec,enditer}

We hence postulate a term of type \C{A} and two of type \C{T}
in order to apply \C{foldr} to a two-element list,
and we ask \Coq{} to compute this
expression.

\begin{coq}{name=vars}{width=7cm}
Variable init : A.
Variables x1 x2 : T.
Eval compute in foldr init [:: x1; x2].
\end{coq}
\begin{coqout}{run=symbcomp}{width=5cm}
$~$
$~$
 = f x1 (f x2 init) : A
\end{coqout}
\coqrun{name=symbcomp}{ssr,sec,vars,enditer}

The symbols \C{f}, \C{x1}, \C{x2} and \C{init} are inert:
They represent unknown values, hence computation cannot
proceed any further.  Still
\Coq{} has developed the expression symbolically.
To convince
ourselves that such expression is meaningful
we can try to substitute \C{f}, \C{x1}, \C{x2} and \C{init} with the
values we used at the end of the last section to
play with \C{foldr}, namely \C{addn}, \C{1}, \C{2} and \C{0}:

\begin{coq}{name=hyp_subst}{width=7cm}
Eval compute in addn 1 (addn 2 0).
\end{coq}
\begin{coqout}{run=hyp_subst_run}{width=5cm}
 = 3 : nat
\end{coqout}
\coqrun{name=hyp_subst_run}{ssr,hyp_subst}

The expression, which now contains no inert symbols, computes to the numeral 3,
the very same result we obtained by computing \C{(foldr addn 0 [:: 1; 2])}
directly.

% In later chapters we are going to prove properties about \C{foldr}.
% In such cases the local context has to be understood as containing
% names (and type annotations) of fixed, but unknown, objects.
% Hence proving a property of \C{foldr} when the iterated function
% \C{f} is unknown means proving that such a property is true for any
% possible value of \C{f}.

The way functions are described as programs has an impact on the way
symbolic computations unfold. For example, recall from
section~\ref{ssec:recnat} the way we defined an addition operation on
elements of type \C{nat}. It was defined using the \C{if .. is
  .. then .. else ..} syntax: % presented in section~\ref{}:

\begin{coq}{name=addn_redef}{}
Fixpoint addn n m := if n is p.+1 then (addn p m).+1 else m.
\end{coq}
\index[coq]{\C{addn}}

Now let us consider the following alternative definition:

\begin{coq}{name=add_def}{}
Fixpoint add n m := if n is p.+1 then add p m.+1 else m.
\end{coq}
\coqrun{name=adds}{ssr,addn_redef,add_def}
\index[coq]{\C{add}}

Both are sensible definitions, and we can show that the two addition
functions compute the same results when applied to numerals.  Still,
their computational behavior may differ when computing on arbitrary
symbolic values. In order to highlight this, we will use another
normalization strategy to perform computation, the \C{simpl}
evaluation strategy.  One difference between the \C{simpl}
and \C{compute} strategies is that the \C{simpl} one usually leaves
expressions in nicer forms whenever they contain variables. Here again
we point the interested reader to \cite[section 8.7.1]{Coq:manual} for
\marginnote{predn has a notation attached to it}
more details.

\begin{coq}{name=symb_add}{width=7cm}
Variable n : nat.
Eval simpl in (add  n.+1 7).-1.
Eval simpl in (addn n.+1 7).-1.
\end{coq}
\begin{coqout}{run=symb_add_run}{width=5cm}
= (add n 8).-1 : nat
= addn n 7 : nat
\end{coqout}
\coqrun{name=symb_add_run}{ssr,addn_redef,add_def,symb_add}

Here we see the impact of the difference in the definitions of
\C{addn} and \C{add}: the \C{add} variant transfers the
number of pebbles (represented by the successor \C{S} symbol)
given as first argument to its second argument
before resorting to its base case, whereas in the \C{addn} variant,
the resulting pile of pebbles is constructed top down. An intermediate
expression in the computation of \C{(addn n m)} exposes as many
successors as recursive calls have been performed so far. Since bits
of the final result are exposed early, the \C{predn} function can
eventually compute, and it cancels the \C{.+1} coming out of the sum.
On the other hand,
\C{add} does not expose a successor when a recursive call is
performed; hence symbolic computation in \C{predn} is stuck.

As chapter~\ref{ch:proofs} illustrates, symbolic computation plays an
important role in formal proofs, and this kind of difference
matters. For instance the \C{addn} variant helps
showing that \C{(addn n.+1 7)} is different from \C{0} because by
computation \Coq{} would automatically expose  a \C{S} symbol
and no natural number of the form \C{(S  ..)} is equal to 0.
For a worked out example, see also the proof of \C{muln_eq0} in
section~\ref{proof:mulneq0}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iterators and mathematical notations}
\index[concept]{general term|seealso {higher-order}}
\label{sec:bigopnat}

Numbers and sequences of objects are so pervasive in the mathematical
discourse that we could hardly omit to present them in such an
introductory chapter. On the other hand, the reader may wonder what role
programs like \C{foldr} may play in mathematical sentences.

Actually, in order to formalize the left hand side of the two
following formulas:
$$
\sum_{i=1}^n (i * 2 - 1) = n ^ 2 \qquad
\sum_{i=1}^n i = \frac{n * (n + 1)}{2}
$$
and, more generally, in order to make explicit the meaning of the capital
notations like $\bigcap_{i=1}^nA_i,
\prod_{i=1}^nu_i, \dots$, we need to decribe an iteration procedure
akin to the \C{foldr} program. We illustrate this on the example of
the summation symbol (for a finite sum):

\begin{coq}{name=iotasum}{}
Fixpoint iota m n := if n is u.+1 then m :: iota m.+1 u else [::].
Notation "\sum_ ( m <= i < n ) F" :=
  (foldr (fun i a => F + a) 0 (iota m (n-m))).
\end{coq}
\index[coq]{\C{iota}}
\index[coq]{\C{\\sum}}

The \C{iota} function generates the list
\C{[:: m; m+1; ...; m+n-1]}
of natural numbers
corresponding to the range of the summation. Then the notation defines
expressions with shape \L+\sum_ (m <= i < n) F+, with \C{F} a
sub-expression featuring variable \C{i}, the one used for the
index. For instance, once the above notation is granted and for any
natural number \C{(n : nat)}, one may write
the \Coq{} expression \L+(\sum_(1 <= i < n) i)+ to represent the
sum $\sum\limits_{i=1}^{n-1} i$. The name \C{i} is really used as a
\emph{binder name} here and we may substitute \C{i} with any other
name we may find more convenient, as in \L+(\sum_(1 <= j < n) j)+,
without actually changing the expression\footnote{Although this change
results in two syntactically different expressions, they have the same
meaning for \Coq{}}.

The notation represents an instance of the \C{foldr} program, iterating
a function of type \C{nat -> nat -> nat}: the two type parameters of
\C{foldr} are set to \C{nat} in this case. The first explicit
argument given to \C{foldr} is hence a function of
type \C{nat -> nat -> nat}, which is created by \emph{abstracting} the
variable \C{i} in the expression \C{F}, as mentionned in
section~\ref{ssec:deffun}. The name of the second argument of the
function, called \C{a} here, should not appear in expression \C{F} in
order for the notation to be meaningful.
% [DG] Is this true? I cannot use the variable "a" ever when I use this
% notation? I hope the compiler is smarter than that! (My experiments
% exhibit no problems: e.g., "Eval compute in \sum_ (2 <= a < 6) a."
% returns 14, as it should).
Crucially, the \C{foldr}
iterator takes as
input a \emph{functional argument that is able to represent faithfully
  any general term}. As a second explicit argument to \C{foldr}, we
also provide the neutral element \C{0} for the addition: this is the
initial value of the iteration, corresponding to an empty index range.

Let us perform a few examples of computations with these iterated sums.
\begin{coq}{name=evalsum}{width=8.5cm,title=Query}
Eval compute in \sum_( 1 <= i < 5 ) (i * 2 - 1).
Eval compute in \sum_( 1 <= i < 5 ) i.
\end{coq}
\begin{coqout}{run=evalsum_run}{width=3.5cm,title=Response}
= 16 : nat
= 10 : nat
\end{coqout}{}{}
\coqrun{name=evalsum_run}{ssr,iotasum,evalsum}

Behind the scenes, iteration happens following the order of the list,
as we observed in section~\ref{sec:symcomp}.
In the present case the operation we iterate, addition, is
commutative, so this order does not impact the final result. But it
may not be the case, for example if the iterated operation
is the product of matrices.

Defining the meaning of this family of notations using a generic
program \C{foldr}, which manipulates functions, is not only useful for
providing notations, but it also facilitates the design of the
corpus of properties of these expressions. This corpus comprises
lemmas derived from the generic properties of \C{foldr}, which do not
depend on the function iterated. By assuming further properties
linking the iterated operation to the initial value, like forming a
monoid, we will be able to provide a generic theory of iterated
operations in section~\ref{sec:bigop}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notations, abbreviations}\label{sec:notabrev}
\index[concept]{notation}
\index[concept]{abbreviation}

Throughout this chapter, we have used \emph{notations} to display
formal terms in a more readable form, closer to the usual conventions
adopted on paper. Without notations, formal terms soon get unreadable for
humans for they often expose too low level details in mathematical
expressions. For this purpose, the \Coq{} system provides a
\C{Notation} command, and we have mentioned it several times already,
relying on the reader's intuition to understand roughly how it
works. Its actual behavior is quite complex. With this command, it is
possible to declare various kind of notations and to specify the way
associativity and their precedence to the parsing engine of \Coq{}. It
is also possible to provide some hints for printing, like good
breaking points. {\em Scopes} are groups of notation that go together
well, and can be activated or deactivated simultaneously. They are
usually associated with a {\em scope delimiter}, which allows the
activation of a scope locally in a sub-expression.

For instance the infix notation that we have used so far for the
constant \C{addn} can be declared as follows:

\begin{coq}{name=notation_addn}{}
Notation "m + n" := (addn m n) (at level 50, left associativity).
\end{coq}
\coqrun{name=notation}{ssr,notation_addn}
\index[vernac]{\C{Notation}}

For infix notations, which are meant to be printed between two arguments
of the operator (like addition in \C{2 + 3}), we advise to always include
space around the infix operator, so that notations don't get mixed up with
potential notations occurring in the arguments.


Similarly, the comparison relation \C{leq} on type \C{nat} comes with
an infix notation \C{<=} which can be defined as:

\begin{coq}{name=notation_leq}{}
Notation "m <= n" := (leq m n) (at level 70, no associativity).
\end{coq}
\coqrun{name=notation2}{ssr,notation_leq}

\index[coq]{\C{leq}}
where the rightmost annotations, between parentheses, indicate a
precedence level and an associativity rule so as to avoid parsing
ambiguities. A lower level binds more than a higher level. A comprehensive
description of the \C{Notation} command goes behind the scope of this
book; the interested reader shall refer to~\cite[chapter 12]{Coq:manual}.

A notation can denote an arbitrary expression, and not only to a
single constant. Here is for instance the definition of the infix
notation \C{<}, for the strict comparison of two natural numbers: it
denotes the composition of the comparison \C{_ <= _}
(which refers to the constant \C{leq}) with the successor \C{_.+1}
(which refers to the constructor \C{S}) on its first argument:

\begin{coq}{name=notation_lt}{}
Notation "m < n"  := (m.+1 <= n).
\end{coq}
\coqrun{name=notation3}{ssr,notation_lt}

\gotcha{There is no function testing if a natural number is strictly
smaller than another one.  \C{(a < b)} is just an alternative syntax
for \C{(a.+1 <= b)}}

The converse relation \C{(n > m)} is defined as a notation for
\C{(m < n)}. However, it is only accepted in input,
and is always printed as  \C{(m < n)}, thanks to the following declaration:

\begin{coq}{name=notation_gt}{}
Notation "n > m"  := (m.+1 <= n) (only parsing).
\end{coq}
\coqrun{name=notation4}{ssr,notation_gt}

Another frequently used form of notation is called syntactic abbreviation.
It simply lets one specify a different name for the same object.
For example the \C{S} constructor of natural numbers can also be accessed
by writing \C{succn}.  This is useful if \C{S} is used in the current context
to, say, denote a ring.

\begin{coq}{name=notation_succn}{}
Notation succn := S.
\end{coq}
\coqrun{name=notation5}{ssr,notation_succn}

The notation \C{_.+1} we have been using so far is defined on top of
this abbreviation, as:

\begin{coq}{name=notation_p1}{}
Notation "n .+1" := (succn n) (at level 2, left associativity): nat_scope.
\end{coq}
\coqrun{name=notation6}{ssr,notation_p1}


The \C{Locate} command can be used to reveal the actual term
represented by a notation.  In order to understand the meaning of an unknown notation like for instance \C{(a <= b <= c)}, one can use the \C{Locate} command to uncover the symbols it involves.

\begin{coq}{name=locate}{width=2.9cm}
Locate "<=".
$~$
$~$
$~$
\end{coq}
\begin{coqout}{run=locate_run}{width=9.5cm}
Notation                                       Scope
"m <= n <= p" := andb (leq m n) (leq n p)    : nat_scope
"m <= n < p" := andb (leq m n) (leq (S n) p) : nat_scope
"m <= n" := leq m n                          : nat_scope
\end{coqout}
\coqrun{name=locate_run}{ssr,locate}

The only difficulty in using \C{Locate} comes from the fact
that one has to provide a complete \emph{symbol}.  A symbol
is composed of one or more non-blank characters and its first
character is necessarily a non-alphanumerical one.
The converse is not true: a sequence of characters is recognized as
a symbol only if it is used in a previously declared notation.
For example \C{3.+1.+1 } is parsed as a number followed by two
occurrences of the \C{.+1} symbol, even if \C{.+1.+1} could, in
principle, be a single symbol.

Moreover substrings of a symbol are not necessarily symbols.  As a consequence
\C{Locate "="} does not find notations like the ones above, since \C{<=} is a
different symbol even if it contains \C{=} as a substring.  For the same reason
\C{Locate ".+"} returns an empty answer since \C{.+} is not a (complete)
symbol.

We mention here some notational conventions
% either imposed by \Coq{}'s parsing engine or
adopted throughout the \mcbMC{} library.


\begin{itemize}
\item Concepts that are typically denoted with a letter, like $N(G)$ for the
	normalizer of the group $G$, are represented by symbols beginning
	with \C{'} as in \C{'N(G)}, where \C{'N} is a symbol.
\item At the time of writing, notations for numerical constants are specially
	handled by the system.  The algebraic part of the library overrides
	specific cases, like binding \C{1} and \C{0} to ring elements.
\item Postfix notations begin with \C{.}, as in \C{.+1} and \C{.-group}
	to let one write \C{(p.-group G)}. There is one exception for
        the postfix notation of the factorial, which starts with
        \D{`}, as in \D{m`!}.
\item Taking inspiration from \LaTeX{} some symbols begin with \C{\\},
	like \C{\\in}, \C{\\matrix}, \C{\\sum}, \ldots
\item Arguments typically written as subscripts appear after a symbol
	which ends with an underscore like \C{'N\_} in \C{'N\_G(H)}.
\item N-ary notations begin with \C{[} followed by the symbol of the
	operation being repeated, as in \C{[&& true, false & false]}.
\item Bracket notations are also used  for operations building data, as in
	\C{[seq .. | .. ]}.
\item Curly braces notations like \C{\{poly R\}} are used for data types
	with parameters.
\item Curly braces are also used to write localized statements
	such as \C{\{in A, injective f\}},
	which means that the restriction of \C{f} to \C{A} is injective.
\end{itemize}

Each file in the \mcbMC{} library comes with a header documenting
all concepts and associated notations it provides.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Exercises}

%%%%%%%%
\begin{Exercise}[label=ex:triple,difficulty=0,title={The triple data type}]
Define the triple data type such that the following notation
applies.  Also define the projections.

\begin{coq}{name=triple}{width=8cm}
Notation "( a , b , c )" := (mk_triple a b c).
Notation "p .1" := (fst p) (at level 2).
Notation "p .2" := (snd p) (at level 2).
Notation "p .3" := (thrd p) (at level 2).
Eval compute in (4, 5, 8).1.
Eval compute in (true, false, 1).2.
Eval compute in (2, true, false).3.
\end{coq}
\begin{coqout}{run=triple_run}{width=4cm}
$~$
     = 4 : nat
     = false : bool
     = false : bool
\end{coqout}
\coqrun{name=triple_run}{ssr,triple_solution,triple}

Remark that the triple data type has to be polymorphic in order to
be applicable to each of these combinations of natural numbers and
booleans.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:iteradd,difficulty=0,title={Addition with iteration}]
Define a program computing the sum of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:itermul,difficulty=0,title={Multiplication with iteration}]
Define a program computing the product of two natural numbers
using \C{iter}.
\end{Exercise}

%%%%%%%%
\begin{Exercise}[label=ex:nth,difficulty=0,title={Find the n-th element}]
Define a program taking a default value, a list and  a natural number \(n\).
The program should return the \(n\)-th element of the list (counting
from \(0\)) if \(n\)
is smaller than the size of the list.  It should return
the default value otherwise.

\begin{coq}{name=nth}{width=7cm}
Eval compute in
  nth 99 [:: 3; 7; 11; 22] 2.
Eval compute in
  nth 99 [:: 3; 7; 11; 22] 7.
\end{coq}
\begin{coqout}{run=nth_run}{width=5cm}
     = 11
     : nat
     = 99
     : nat
\end{coqout}
\coqrun{name=nth_run}{ssr,nth}
\end{Exercise}

%%%%%%%%%
\begin{Exercise}[label=ex:rev,difficulty=0,title={List reversal}]
Define the program \C{rev} that reverses the order of the elements
of a list.

\begin{coq}{name=revtest}{width=5cm}
Eval compute in
  rev [:: 1; 2; 3].
\end{coq}
\begin{coqout}{run=rev_run}{width=7cm}
 = [:: 3; 2; 1]
 : seq nat
\end{coqout}
\coqrun{name=rev_run}{ssr,revsolution,revtest}
\end{Exercise}

%%%%%%%%%%%%%
\begin{Exercise}[label=ex:flatten,difficulty=1,title={List flattening}]
Define the program \C{flatten} that takes a list of lists and returns
their concatenation.  Don't write a recursive function; just reuse
the concatenation function and one of the higher-order iterators
seen so far.

\begin{coq}{name=flatten}{width=7.3cm}
Eval compute in
  flatten [:: [:: 1; 2; 3]; [:: 4; 5] ].
\end{coq}
\begin{coqout}{run=flatten_run}{width=5cm}
 = [:: 1; 2; 3; 4; 5]
 : seq nat
\end{coqout}
\coqrun{name=flatten_run}{ssr,flatten_solution,flatten}
\end{Exercise}


%%%%%%%%%
\begin{Exercise}[label=ex:allwords,difficulty=2,title={All words of size n}]
Define the \C{all\_words} program that takes in input a
length \C{n} and a sequence of symbols \C{alphabet}.
The program has to generate a list of all words (i.e., lists
of symbols) of size \C{n} using the symbols from \C{alphabet}.

\begin{coq}{name=allwords}{width=5.5cm}
Eval compute in
  all_words 2 [:: 1; 2; 3].
$~$
$~$
\end{coq}
\begin{coqout}{run=allwords_run}{width=7cm}
 = [:: [:: 1; 1]; [:: 1; 2]; [:: 1; 3];
       [:: 2; 1]; [:: 2; 2]; [:: 2; 3];
       [:: 3; 1]; [:: 3; 2]; [:: 3; 3]]
 : seq (seq nat)
\end{coqout}
\coqrun{name=allwords_run}{ssr,allwords_solution,allwords}
\end{Exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solutions}

%%%%%%%%%%

\begin{Answer}[ref=ex:triple]

\begin{coq}{name=triple_solution}{}
Inductive triple (A B C : Type) := mk_triple (a : A) (b : B) (c : C).
Notation "( a , b , c )" := (mk_triple a b c).
Definition fst  A B C (p : triple A B C) := let: (a, _, _) := p in a.
Definition snd  A B C (p : triple A B C) := let: (_, b, _) := p in b.
Definition thrd A B C (p : triple A B C) := let: (_, _, c) := p in c.
\end{coq}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:iteradd]

\begin{coq}{name=addniter}{}
Definition addn n1 n2 := iter n1 S n2.
\end{coq}
\coqrun{name=addniter_run}{ssr,addniter}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:itermul]

\begin{coq}{name=muln_solution}{}
Definition muln n1 n2 := iter n1 (addn n2) 0.
\end{coq}
\coqrun{name=mulnsol_run}{ssr,muln_solution}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:nth]

\begin{coq}{name=nth_solution}{}
Fixpoint nth T (def : T) (s : seq T) n :=
  if s is x :: tl then if n is u.+1 then nth def tl u else x else def.
\end{coq}
\coqrun{name=nthex_run}{ssr,nth_solution}

\end{Answer}

%%%%%%%%%%
\begin{Answer}[ref=ex:rev]

\begin{coq}{name=revsolution}{}
Fixpoint catrev T (s1 s2 : seq T) :=
  if s1 is x :: xs then catrev xs (x :: s2) else s2.

Definition rev T (s : seq T) := catrev s [::].
\end{coq}

\end{Answer}

%%%%%%%%%%%%%

\begin{Answer}[ref=ex:flatten]

\begin{coq}{name=flatten_solution}{}
Definition flatten T (s : seq (seq T)) := foldr cat [::] s.
\end{coq}

\end{Answer}

%%%%%%%%
\begin{Answer}[ref=ex:allwords]

\begin{coq}{name=allwords_solution}{}
Definition all_words n T (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w <- wl] in
  let extend wl := flatten [seq prepend x wl | x <- alphabet] in
  iter n extend [:: [::] ].
\end{coq}

Another possible solution~\footnote{suggested by Dairj Grinberg.}:

\begin{coq}{name=allwords_solution_dg}{}
Fixpoint all_words_alt (T : Type) (n : nat) (xs : seq T) :=
  if n is m.+1 then
    flatten [seq [seq x :: w | w <- (all_words_alt m xs)] | x <- xs]
  else nil :: nil.
\end{coq}

\end{Answer}



%%%%%%%%%%%%%%%%%%%%%%%%%% End of written part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theoretical content:
% \begin{itemize}
% \item Functions with simple types ($\lambda$, $\rightarrow$): functions are the primitive concept
% \item Inductive {\bf datas}
% \item Programs by case analysis and recursion
% \item Compute (beta, delta, iota) example of beta (that helps later on to explain a predicate for elim principles)
% \item Polymorphic data types (introduce $\Pi$, and its \Coq{} notation
%   \C{forall}, for quantification over data types only)
% \item Everyone has a type : \C{0 : nat : Type : Type}, types avoid confusion
% \end{itemize}
% This is more or less a standard introduction to (a flavor of)
% functional programming, with two possible difficulties:
% \begin{itemize}
% \item Be precise but not too technical (e.g. on inductive types)
% \item Find a line of speech which does not bore/discourage
%   mathematicians.
% \item Somehow the syntax of (this fragment of the) terms should made
%   be clear and precise.
% \item types depending on terms (matrix x m)
% \end{itemize}


% \begin{itemize}
% \item Use monomorphic instances/compatible versions of the notations
%   that will later be generalized using canonical structures;
% \item For instance the infix \C{==} is the comparison on \C{nat}
% \item Further examples: \verb+\sum_(i <- l) F i+, \verb+\sum_(a <= b <) F i+
% in order to illustrate \C{foldr}.
% \end{itemize}
% \Coq{} commands and features:
% \begin{itemize}
% \item Implicit arguments (only to go from system F to ML), \C{@}
% \item Sections and its discharging, implicit types
% \end{itemize}
%
%
% \Coq{} types introduced:
% \begin{itemize}
% \item \C{bool, nat, seq, option, prod}
% \end{itemize}
%
% Programs presented in detailed examples/exercises:
% \begin{itemize}
% \item Elementary programs on \C{option}: \C{odflt, obind,}\dots
% \item Elementary programs on \C{seq} (without the \C{eqType}):
%   \C{size, map, iota,...}
% \item Comparison functions on \C{bool, nat}
% \item Comparison functions on containers, taking the comparison
%   function on the type of stored elements in argument (mind the
%   higher-order)
% \item Boolean connectives, arithmetic operations on \C{nat}
% \item Do not forget to mention \C{if .. then .. else}
% \item Euclidean division, computation of prime factors, examples from
%   elementary number theory
% \item Examples of G{\"o}del-style encoding from the {\tt choice.v} library.
% \item Examples/exercises about extended gcd (egcdn), which mix lists
%   and arithmetic.
% \end{itemize}
% If possible give a few context to the exercises, in order not to bore
% the reader not familiar with programming. For instance do not say that
% you encode sequences of nats in nats but give a few hints about the
% use of G{\"o}del encoding.
%
% Examples and exercises can be executed in an empty context, or
% libraries can be required for the purpose of (re)using and combine existing
% programs (non-proofs here).
%
% The current contents are organized like the tutorial at ITP15 I gave (Enrico).
% It was on standard \Coq{} and was intended not to be difficult class ;-)
% It is a possible plan, no strong opinions.
%
% \section*{Things needed by chapter 2}
% \begin{itemize}
% \item type annotations on arguments of lemmas/definitions can be omitted
% \item if then else
% \item all boolean connectives: \C{orb andb negb implb xorb}
% \item recursive programs: \C{addn muln subn leq eqn expn dvdn}
% \item notations with associativity: \C{+ * - == != .+1 < <= \%| \~\~}
% \end{itemize}
%
%
% \section{Functional programming in a nutshell}
% Only intuitions here.
%
% For a mathematician this is perfectly natural, the main problem is the syntax.  E.g.
% $$f(x) = x * 2\qquad\qquad f(7)$$
% here we define a function named f that doubles its input.  Then we denote f(7) the value of f
% when the input is 7. The novelty is that:
% \begin{enumerate}
% \item functions are anonymous, and the names. \verb+(fun x => x * 2)+ is the function that
% 	doubles.  We can name it: \verb+Definition f := fun x => x * 2.+.  We don't need to
% 	name a function in order to use it in an expression. (there is something like
% 	\verb+x |-> x * 2+, but this is always attached to a name somehow).
% \item function application is \verb+(f 7)+.
% \end{enumerate}
%
% For a computer scientist used to imperative languages, these are the main weird points:
% \begin{enumerate}
% \item there is no return statement, AKA expressions are already programs.  e.g.
% 	4 is a program, and 2+2 as well.  Programs then evaluate like a mathematical expression
% 	can be simplified
% \begin{verbatim}
%         if (false || true) then 2 + 2 else 7
%         if true then 2 + 2 else 7
%         2 + 2
%         4
% \end{verbatim}
% also
% \begin{verbatim}
%         2 + (if 7 == 2 then 4 else 2)
%         2 + (if false then 4 else 2)
%         2 + 2
%         4
% \end{verbatim}
% \item programs are really first-class data (HO programming, not reasonably popular even outside
% 	the functional world). E.g.
%     This program takes in input a function f and uses it twice
% \begin{verbatim}
%       (fun f => f 3 + f 4)
% \end{verbatim}
% hence this is a valid program computing 14
% \begin{verbatim}
%       (fun f => f 3 + f 4) (fun x => x + x)
% \end{verbatim}
% \end{enumerate}
%
%
% \subsection{Build and destruct simple data}
% Simplest data is bool.
%
% \begin{coq}{name=bool}{}
% Inductive bool : Type := true | false.
% Check bool : Type.
% Check true : bool.
% Check false.
% Check 3 : bool. (* boom *)
% \end{coq}
%
% This tells you that one can construct a boolean using true or false but not a number.
% Types tells you how your values are (in normal form, since (true || false) is also of type bool, recall the example before).
% Hence it makes sense to consider only true and false when one inspects a bool.
%
% \begin{coq}{name=negb}{}
% Definition negb (b : bool) : bool :=
%   match b with
%   | true => false
%   | false => true
%   end.
%
% Check negb.
% Check negb true.
% Check negb (negb true).
% Check negb 3. (* boom *)
%
% Eval compute in negb true.
% Eval compute in negb false.
% \end{coq}
% We see the function type (arrow) and how typing works in this simple case.
% Also that functions compute in \Coq{}.
% Sugar:
%
% \begin{coq}{name=negb}{}
% Definition another_negb (b : bool) : bool :=
%   if b then false else true.
% Definition yet_another_negb :=
%   (fun b : bool =>
%       if b then false else true).
% Definition andb (b1 : bool) (b2 : bool) :=
%   if b1 then b2 else false.
% Notation "x && y" := (andb x y).
% Eval compute in true && false.
% Eval compute in true && true.
% \end{coq}
%
% \subsection{Polymorphic containers and binding in match}
%
% This is not the syntax used in ssr I guess.
%
% \begin{coq}{name=option}{}
%  Inductive option (A : Type) : Type :=
%  | None
%  | Some (a : A).
% Check option.
% Check option bool : Type.
% Check Some true. (* Implicit argument *)
% \end{coq}
%
% Talk about implicit arguments here.
%
% \begin{coq}{name=implicits}{}
% About Some.
% (* The @ locally disables the implicit arguments *)
% Check @Some bool true.
% Check @Some _ true.
% \end{coq}
%
% Inspecting a container
%
% \begin{coq}{name=matchopt}{}
% Definition is_empty A (box : option A) : bool :=
%   match box with
%   | None => true
%   | Some _ => false  (* Here _ means discard the little a *)
%   end.
% Eval compute in is_empty None.
% Eval compute in is_empty (Some true).
% (* Note: the function is polymorphic! *)
% Eval compute in is_empty (Some 4).
% \end{coq}
%
% Two words about polymorphism.
%
% Now binding in a match.
%
% \begin{coq}{name=matchopt2}{}
% Definition get_default A (box: option A) (a : A) : A :=
%   match box with
%   | None => a
%   | Some x => x  (* this x is a name on the left bound to the contents *)
%   end.
%
% Eval compute in get_default None 3.
% Eval compute in get_default (Some 4) 3.
% \end{coq}
%
% More containers
%
% \begin{coq}{name=pair}{}
%  Inductive prod (A B : Type) : Type :=
%  | pair (a : A) (b : B).
%
%  Notation "A * B" := (prod A B).
%  Notation "( a , b )" := (pair a b).
%
% Check (true, Some false).
%
% Definition fst A B (p : A * B) :=
%   match p with
%   | ( x , _ ) => x
%   end.
%
% Eval compute in fst (true, None).
%
% Definition snd A B (p : A * B) :=
%   match p with (_, y) => y end.
% \end{coq}
%
% \subsection{Recursive data}
%
% Nat, with a special syntactic sugar
%
% \begin{coq}{name=nat}{}
%    Inductive nat : Type :=
%    | O
%    | S (n : nat).
%
% Check S (S O).
% Check 2.
% Check 1.
% \end{coq}
%
% Recursive functions
%
% \begin{coq}{name=plus}{}
% Fixpoint plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => S (plus w m)
%   end.
% Infix "+" := plus.
%
% Check 2 + 3.
% Eval compute in 2 + 3.
% \end{coq}
%
% execution step by step
%
% \begin{coq}{name=execplus}{}
%    S (S 0) + 3
%    S ((S O) + 3)
%    S (S (O + 3))
%    S (S 3)
%    5
% \end{coq}
%
% Here I was also showing
%
% \begin{coq}{name=plusrec}{}
% Fixpoint fast_plus (n : nat) (m : nat) : nat :=
%   match n with
%   | O => m
%   | S w => fast_plus w (S m)
%   end.
%
%     S (S O) + 3
%     S O + 4
%     O + 5
%     5
% \end{coq}
%
% and making the point that reasoning about these two plus is not equally easy (short parenthesis on symbolic computation).
%
% \begin{coq}{name=plusrec}{}
% Eval simpl in
%   (fun n => fast_plus (S n) 3).  (* no progress *)
% Eval simpl in
%   (fun n => plus (S n) 3).  (* some output already, we can prove that it is not 0 *)
% \end{coq}
%
% Lists
%
% \begin{coq}{name=list}{}
% Inductive list (A : Type) : Type :=
% | nil
% | cons (x : A) (xs : list A).
%
% Infix "::" := cons.
% Arguments nil {A}.
% Arguments cons {A} x xs.
%
% (* The type of lists imposes all the elements to
%     be in the same type! *)
% Check true :: false :: nil.
% Fail Check 1 :: false :: nil.
%
% (* A non-recursive function on lists *)
% Definition tl A (l : list A) : list A :=
%   match l with
%   | nil => nil
%   | _ :: xs => xs
%   end.
%
% Eval compute in tl (6 :: 99 :: nil).
%
% (* The most popular function on lists *)
% Fixpoint len A (l : list A) : nat :=
%   match l with
%   | nil => O
%   | x :: xs => 1 + (len xs)
%   end.
%
% Eval compute in len (1 :: 2 :: 3 :: nil).
% Fixpoint split A B (l : list (A * B)) : list A * list B :=
%   match l with
%   | nil => (nil, nil)
%   | (x,y) :: rest =>
%       let xs_ys := split rest in
%       (x :: fst xs_ys, y :: snd xs_ys)
%   end.
%
% Eval compute in
%   split ((1,2) :: (3,4) :: nil).
%
% Fixpoint zip A B (la : list A) (lb : list B) : list (A * B) :=
%   match la, lb with
%   | nil, nil => nil
%   | x::xs, y::ys => (x,y) :: zip xs ys
%   | _, _ => nil
%   end.
%
% Eval compute in
%   zip (1 :: 2 :: nil) (true :: false :: nil).
%
% Eval compute in
%   let xs_ys := split ((1,2) :: (3,4) :: nil) in
%   zip (fst xs_ys) (snd xs_ys).
% \end{coq}
%
% \subsection{termination}
%
% Here we say how termination is checked, which are the alternative when the
% heuristic fails (not very relevant for mathcomp I guess) and relate that to
% logical inconsistency (maybe too early here, needs curry howard).
%
% \begin{coq}{name=paradoxes}{}
% Fail
% Fixpoint wrong A (l : list A) {struct l} :=
%   match l with
%   | nil => 0
%   | x :: xs => 1 + wrong (x :: nil)
%   end.
%
% Fixpoint loop (n : nat) : False := loop n.
%
% Check loop 3.
% Fail Timeout 2 Eval compute in loop 3.
% \end{coq}
%
% Also data must be checked.
%
% \begin{coq}{name=paradoxes2}{}
% Inductive non_positive : Type :=
% | Call (f : non_positive -> False)
%
% Definition self (t : non_positive) : False :=
%   match t with
%   | Call f => f t
%   end.
%
% Definition loop2 : False := self (Call self).
%
% Fail Timeout 2 Eval compute in loop2.
% \end{coq}
%
% \subsection{HO programming}
%
% A function can be abstracted over another
%    function.  It is a useful mechanism to write
%    code that can be reused, especially in the context
%    of polymorphic containers.
%
% \begin{coq}{name=map}{}
% Fixpoint map A B (f : A -> B) (l : list A) : list B :=
%   match l with
%   | nil => nil
%   | x :: xs => f x :: map f xs
%   end.
%
% Eval compute in
%   map (fun x => x + 2) (3 :: 4 :: 7 :: nil).
% Eval compute in
%   map negb (true :: false :: nil).
%
% (* fold f (x1 :: x2 :: .. xn :: nil) a
%      =
%             (f xn (.. (f x2 (f x1 a))))
% *)
% Fixpoint fold A B (f : B -> A -> A) (l : list B) (a : A) : A :=
%   match l with
%   | nil => a
%   | x :: xs => fold f xs (f x a)
%   end.
%
% (* what does this do? *)
% Eval compute in fold cons (1 :: 2 :: 3 :: nil) nil.
% \end{coq}
%
% Here one could use a section for A B and talk about all that.

% \section{old contents (before Enrico's tutorial)}
%
% Do use \C{About} for informations (not \C{Check}).
% \begin{coq}{name=beta}{}
% Eval beta in (fun x => x + x) 3. (* 3 + 3 : nat *)
% Definition f := fun x : nat => x + x.
% Definition f (x : nat) := x + x.
% About f : nat -> nat.
% \end{coq}
%
% TODO: "beta" alone is not a reduction tactic, but we could add it.
%
% maybe also talk about delta here and make example of f.
%
% \subsection{Inductive data, case analysis and recursion}
% bool, nat.
%
% \begin{coq}{name=ind-data}{}
% Inductive bool : Type := true | false.
% Inductive nat :Type := O | S of nat.
% Check true : bool : Type. (* on a side note .. : Type : Type *)
% Check (S (S O)). (* 2 : nat *)
% \end{coq}
%
%
%
%
% match, fix, termination.
%
% \begin{coq}{name=bool-conn}{}
% Definition andb := ...
% Fixpoint addn := ..
% Fixpoint eq_nat
% Fixpoint leq
% \end{coq}
%
% discuss example of a real computation, not just beta.
%
% \begin{coq}{name=compute}{}
% Compute (addn 3 4)
% \end{coq}
%
% now simple notation come in to play
%
% \begin{coq}{name=notation-infix}{}
% Infix "+" := addn.
% \end{coq}
%
% \subsection{Polymorphism and HO programming}
% option, seq, pairs.
%
% \begin{coq}{name=option}{}
% Inductive option A := None | Some of A.
% Check option. (* Type -> Type *)
% Check Some. (* : forall A : Type, A -> option A *)
% Fixpoint map A B (f : A -> B) := ...
% Fixpoint eq_seq A (eq_A : A -> A -> bool) l := ...
% \end{coq}
%
% polymorphism as in F
%
% may be also examples of polymorphism that can be defined in pure
% $\lambda$-calculus (identity, argument swapping).
%
% \section{programming in \Coq{}}
% this contains real programs, and is the excuse to talk about:
%
% \subsection{Sections}
% and Implicit Type, to factor the type parameter of containers like
% sequences.  Write more stupid programs on seq.
%
% \begin{coq}{name=seq}{}
% Section Seq.
% Variable A : Type.
% Variable x0 : A.
% Implicit Type l : seq A.
% ...
% Fixpoint fold f l := ...
% Fixpoint rev l := ...
% \end{coq}
%
%
% \subsection{Implicit arguments}
% to imitate polymorphism a-la ML, simplest example of type inference
% like \C{Some _ 3}.  Set implicit for inductive types/constructors too,
% and functions on them like the ones on seq we have seen before.
%
% \begin{coq}{name=Arguments}{}
% Arguments seq {T}.
% Arguments nil {T}
% Arguments cons {T} x xs.
% About seq.
% Check cons 3 nil.
% (* we have notataions *)
% Check [:: 3, 4 ].
% Fixpoint size A l := ...
% \end{coq}
%
% About is bad because it mention names that are not necessarily displayed.
% Maybe we should tell people to open the document and/or talk about Locate,
% Print.  Or else use Search (that does all that) but in an empty
% file, where no theorems pop up.
%
% \subsection{Exercises (explained): arithmetic}
% by now we should have the infrastructure to write program on arithmetic
%
% \begin{coq}{name=stuff}{}
% divn
% prime  (* an simpler version *)
% \end{coq}
%
% from choice.v
%
% \begin{coq}{name=smart}{}
% encode
% decode
% \end{coq}
