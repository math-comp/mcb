% vim:set tw=70:
% vim:set spell:
% vim:set errorformat="":
\begin{coqdef}{name=ssr}
Require Import Ssreflect.ssreflect.
From Ssreflect Require Import ssrfun ssrbool ssrnat eqtype fintype seq div prime.
Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Set Asymmetric Patterns.
\end{coqdef}
\begin{coqdef}{name=abort}
Abort.
\end{coqdef}
\begin{coqdef}{name=show1}
Redirect "g1" Show.
\end{coqdef}
\begin{coqdef}{name=require-tuple}
Require Import tuple.
\end{coqdef}

\chapter{Sub-types}{}\label{ch:sigmabool}

Inductive data types have been used to both code data, like lists, and
logical connectives, like the existential quantifier.
Properties were always expressed with
boolean programs.  The questions addressed in this chapter are the
following ones.  What
status do we want to give to, say, lists of size 5,  or integers
smaller than 7?  Which relation to put between integers and
integers smaller than 7?  How to benefit from extra properties
integers smaller than 7 have, like being a finite collection?

In standard mathematics one would simply say that the integers are an
infinite set (called \C{nat}), and that the integers smaller than 7
form a finite subset of the integers (called \C{'I_7}).  Integers and
integers smaller than 7 are interchangeable data: if \C{(n : nat)} and
\C{(i : 'I_7)} one can clearly add \C{n} to \C{i}, and possibly show
that the sum is still smaller than 7.  Also, an informed reader
knows which operations are compatible with a subset. E.g. \C{(i-1)}
stays in \C{'I_7}, as well as \C{(i+n \%| 7)}.  So in a sense, subsets
also provide a linguistic construct to ask the reader to track an
easy invariant and releaving the proof text of boring details.

The closest notion provided by the \mcbCIC{} is the one of $\Sigma-$types,
that we have already seen in the previous chapter in their general
form of records.
For example, one can define the type \C{'I_7} as the $\Sigma$-type $\Sigma_{(n:nat)} n
< 7$, which pairs a natural number $n$ and a proof that it is smaller than $7$.  Since proofs are terms, one can
pack together objects and proofs of some properties to
represent the objects that have those properties.  For example $3$,
when seen as an inhabitant of \C{'I_7}, is represented by a dependent
pair \C{(3, p)} where \C{(p : 3 < 7)}.  Note that, by forgetting the
proof \C{p}, one recovers a \C{nat} that can be passed to, say, the
program computing the addition of natural numbers, or to theorems
quantified on any \C{nat}.  Also, an inhabitant of \C{'I_7} can always
be proved smaller than 7, since such evidence is part of the
object itself.
We call this construction a \emph{sub-type}.

Such representation can be expensive in the sense that it imposes
extra work (proofs!) to create a sub-type object, so it must be used
with care.  The \mcbMC{} library provides several facilities that
support the creation of record-based sub-types, and of their
inhabitants.  We shall in particular see how both type inference and
dynamic tests can be used to supply the property proofs, modelling
once again the eye of a trained reader.

Finally, let us point out that we have already encountered proof-carrying
records in the previous chapter, with \C{eqType}.
The \C{eqType} record played the role of an interface,
expressing a relation between a type and a function (the comparison operation),
and giving access to a whole theory of results through type inference.
Many such interfaces can be extended to sub-types, and we shall see that
the \mcbMC{} library provides facilities to automate this.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbREQUIRE{eqtype, fintype, CS}
%\mcbPROVIDE{tuple}
%\mcbNOTES{}
\section{$n$-tuples, lists with an invariant on the length}
\label{sec:tupleinvariant}

We begin by defining the type of $n$-tuples: sequences of length $n$.
In this section we focus on how tuples are defined, used as regular
sequences and how to program type inference to track for us the
invariant on tuples' length.  Next section will complete the
definition of the tuple sub-type by making the abstract theory
attached to the \C{eqType} interface available on tuples whenever it is
available on sequences.

A tuple is a sequence of values (of the same type) whose length is
made explicit in the type.

\begin{coq}{name=tupx}{width=\textwidth,title=Tuple sub-type of seq}
Structure tuple_of n T :=  Tuple { tval :> seq T; _ : size tval == n }.
Notation "n .-tuple T" := (tuple_of n T).
\end{coq}
\coqrun{name=r1}{ssr,tupx}

% Recall that the statement \lstinline/(size tval == n)/
% is the argument of a hidden \lstinline/is_true/ coercion.
% If we unfold its definition we clearly see that the statement
% is an equality on \lstinline/bool/.

The key property of this type is that it tells us the length of its
elements when seen as sequences:

\begin{coq}{name=sizetup}{}
Lemma size_tuple T n (t : n.-tuple T) : size t = n.
Proof. by case: t => s /= /eqP. Qed.
\end{coq}
\coqrun{name=r2}{ssr,tup,sizetup}

In other words each inhabitant of the tuple type carries,
in the form of an equality proof, its length.  As test bench
we pick this simple example: a tuple is processed using
functions defined on sequences, namely \lstinline/rev/ and
\lstinline/map/.  These operations do preserve the invariant of
tuples, i.e., they don't alter the length of the subjacent sequence.

\begin{coq}{name=p1}{}
Example seq_on_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
\end{coq}

There are two ways to prove that lemma.  The first one is
to ignore the fact that \lstinline/t/ is a tuple; consider it
as a regular sequence, and use only the theory of sequences.

\begin{coq}{name=p2}{}
Proof. by rewrite map_rev revK size_map. Qed.
\end{coq}
\coqrun{name=r3}{ssr,tup,sizetup,p1,p2}

Mapping a function over the reverse of a list is equivalent to
first mapping the function over the list and then reversing the result
(\lstinline/map_rev/).  Then, reversing twice a list is a no-op, since
\lstinline/rev/ is an involution
(\lstinline/revK/).  Finally, mapping a function over a list does not
change its size (\lstinline/size_map/).  The sequence of rewritings
makes the left hand side of the conjecture identical to the right hand
side, and we can conclude.

This simple example shows that the theory of sequences is usable
on terms of type tuple.  Still we didn't take any advantage from
the fact that  \lstinline/t/ is a tuple.

The second way to prove this theorem is to rely on the rich type
of \lstinline/t/ to actually compute the length of the underlying
sequence.

\begin{coq}{name=p3}{}
Example just_tuple_attempt n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. rewrite size_tuple.
\end{coq}
\coqrun{name=r4;fail}{ssr,tup,sizetup,p3,show1}
\begin{coqout}{run=r4;out=g1}{}
1 subgoal

 n : nat
 t : n .-tuple nat
 ============================
 size (rev [seq 2 * x | x <- rev t]) = n
\end{coqout}

The rewriting replaces the right hand side with \lstinline/n/ as
expected, but we can't go any further: the lemma does not
apply (yet) to the left hand side, even if we are working
with a tuple \lstinline/t/.  Why is that?  In the left hand side
\lstinline/t/ is processed using functions on sequences.
The type of \lstinline/rev/ for example is
\lstinline/(forall T, seq T -> seq T)/.  The coercion \lstinline/tval/
from \lstinline/tuple_of/ to \lstinline/seq/ makes the
expression \lstinline/(rev (tval t))/ well typed, but the output
is of type \lstinline/(seq nat)/.
We would like the functions on sequences to return
data as rich as the one taken in input, i.e., preserve the invariant
expressed by the tuple type.  Or, in alternative, we would like the
system to recover such information.

Let us examine what happens if we try to unify the left hand side of the
\lstinline/size_tuple/ equation with the redex
\lstinline/(size (rev t))/, using the following toolkit:

\begin{coq}{name=infrastructure}{title= Unification debugging toolkit}
Notation "X (*...*)" :=
  (let x := X in let y := _ in x)   (at level 100, format "X  (*...*)").
Notation "[LHS 'of' equation ]" :=
  (let LHS := _ in
   let _infer_LHS := equation : LHS = _ in LHS)   (at level 4).
Notation "[unify X 'with' Y ]" :=
  (let unification := erefl _ : X = Y in True).
\end{coq}

We can now simulate the unification problem
encountered by \lstinline/rewrite size_tuple/

\begin{coq}{name=showunif}{}
Check forall T n (t : n.-tuple T),
 let LHS := [LHS of size_tuple _] in
 let RDX := size (rev t) in
 [unify LHS with RDX].
\end{coq}

The corresponding error message is the following one:

\coqrun{name=r5;fail}{ssr,tup,sizetup,infrastructure,showunif}
\begin{coqout}{run=r5}{title=Response}
Error:
In environment
T : Type
n : nat
t : n .-tuple T
LHS := size (tval ?94 ?92 ?96) (*...*) : nat
RDX := size (rev (tval n T t))           : nat
The term "erefl ?95" has type "?95 = ?95" while
it is expected to have type "LHS = RDX".
\end{coqout}

Unifying \lstinline/(size (tval ?$_n$ ?$_T$ ?$_t$))/
with \lstinline/(size (rev (tval n T t)))/ is hard.
Both terms' head symbol is \lstinline/size/, but then
the projection \lstinline/tval/ applied to unification
variables has to be unified with \lstinline/(rev ...)/,
and both terms are in normal form.

Such problem is nontrivial because to solve it one has to infer a
record for \lstinline/?$_t$/ that contains a proof: a
tuple whose \lstinline/tval/ field
is \lstinline/rev t/ (and whose other field contains a
proof that such sequence has length \lstinline/?$_n$/).

We have seen in the previous chapter that this is exactly the class of
problems that is addressed by canonical structure instances.
We can thus use \C{Canonical} declarations to teach \Coq{}
the effect of list operations on the length of their input.

\begin{coq}{name=t1}{width=12cm}
Section CanonicalTuples.
Variables (n : nat) (A B : Type).

Lemma rev_tupleP (t : n.-tuple A) : size (rev t) == n.
Proof. by rewrite size_rev size_tuple. Qed.
Canonical rev_tuple (t : n.-tuple A) := Tuple (rev_tupleP t).

Lemma map_tupleP (f: A -> B) (t: n.-tuple A) : size (map f t) == n.
Proof. by rewrite size_map size_tuple. Qed.
Canonical map_tuple (f: A -> B) (t: n.-tuple A) := Tuple (map_tupleP f t).
\end{coq}

Even if it is not needed for the lemma we took as our test bench,
we add another example where the length is not preserved, but
rather modified in a statically known way.

\begin{coq}{name=t2}{}
Lemma cons_tupleP (t : n.-tuple A) x : size (x :: t) == n.+1.
Proof. by rewrite /= size_tuple. Qed.
Canonical cons_tuple x (t : n.-tuple A) : n.+1 .-tuple A :=
  Tuple (cons_tupleP t x).
\end{coq}

The global table of canonical solutions is extended as follows.

\vspace{1ex}
\noindent
\begin{tcolorbox}[colframe=orange!60!white,before=\hfill,after=\hfill,center title,tabularx={ll|l|l},fonttitle=\sffamily\bfseries,title=Canonical Structures Index]
projection & value & solution & combines solutions for \\ \hline
\lstinline/tval N A/ & \lstinline/rev A S/ & \lstinline/rev_tuple N A T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N B/ & \lstinline/map A B F S/ & \lstinline/map_tuple N A B F T/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\lstinline/tval N.+1 A/ & \lstinline/X :: S/ & \lstinline/cons_tuple N A T X/
	& \lstinline/T/ $\leftarrow$ (\lstinline/tval N A/, \lstinline/S/) \\
\end{tcolorbox}

Thanks to the now extended capability of type inference,
we can prove our lemma by just reasoning about tuples.

\begin{coq}{name=t3}{}
Example just_tuple n (t : n.-tuple nat) :
  size (rev [seq 2 * x | x <- rev t]) = size t.
Proof. by rewrite !size_tuple. Qed.
\end{coq}
\coqrun{name=r6}{ssr,tup,sizetup,t1,t2,t3}

The iterated rewriting acts now twice replacing both the left hand
and the right hand side with \lstinline/n/.  It is worth observing
that the size of this proof (two rewrite steps) does not depend on the
complexity of the formula involved, while the one using only the
theory of lists requires roughly one step per list-manipulating function.
What depends on the size of the formula is the number of canonical
structure resolution steps type inference performs.  Another advantage
of this last approach is that one
is not required to know the names of the lemmas:
it is the new concept of tuple that takes care of the size related
reasoning steps.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbREQUIRE{proof language}
%\mcbPROVIDE{an example of sub-type of eqType}
%\mcbLEARN{it is a schematic process}
\section{$n$-tuples, a sub-type of sequences}
\label{sec:subtypekit}

We have seen that \lstinline/(seq T)/ is an \lstinline/eqType/
whenever \C{T} is.  We now want to transport such \C{eqType} structure
on tuples.  We first do it manually, then we provide a toolkit
to ease the declaration of sub-types.

The first step is to define a comparison function for tuples.

\begin{coq}{name=tupcmp}{}
Definition tcmp n (T : eqType) (t1 t2 : n.-tuple T) := tval t1 == tval t2.
\end{coq}
\coqrun{name=tupcmp}{ssr,require-tuple,tupcmp}

Here we simply reuse the one on sequences, and we ignore the
proof part of tuples.  What we need now to prove

\begin{coqdef}{name=eqtupP}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
Redirect "g1" Show.
  by move=> ->.
case: x; case: y => s1 p1 s2 p2 /= E. Redirect "g2" Show.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coqdef}
\begin{coq}{def=eqtupP}{}
Lemma eqtupleP n (T : eqType) : Equality.axiom (@tcmp n T).
Proof.
move=> x y; apply: (iffP eqP); last first.
  by move=> ->.
case: x; case: y => s1 p1 s2 p2 /= E.
rewrite E in p2 *.
by rewrite (eq_irrelevance p1 p2).
Qed.
\end{coq}
\coqrun{name=tupcmpP}{ssr,tup,tupcmp,eqtupP}
\index[concept]{proof irrelevance}

The first direction is trivial by rewriting.
The converse direction makes an essential use of
the \lstinline/eq_irrelevance/ lemma, which is briefly discussed
in section~\ref{hedberg}.

\begin{coqout}{run=tupcmpP;out=g1}{title=Response after line 3,width=6cm}
2 subgoals

n : nat
T : eqType
x, y : n .-tuple T
============================
x = y -> tval x = tval y

subgoal 2 is:
  tval x = tval y -> x = y
$~$
\end{coqout}
\begin{coqout}{run=tupcmpP;out=g2}{title=Response after line 5,width=6cm}
1 subgoal

n : nat
T : eqType
s1 : seq T
p1 : size s1 = n
s2 : seq T
p2 : size s2 = n
E : s2 = s1
============================
Tuple p2 = Tuple p1
\end{coqout}

We can then declare the canonical \C{eqType} instance for tuples.

\begin{coq}{name=canontup}{}
Canonical tuple_eqType n T : eqType :=
  Equality.Pack (Equality.Mixin (@eqtupleP n T)).
\end{coq}

As a simple test we check that the notations and the theory
that equips \C{eqType} is available on tuples.

\begin{coq}{name=testtup}{}
Check forall t : 3.-tuple nat, [:: t] == [::].
Check forall t : 3.-tuple bool, uniq [:: t; t].
Check forall t : 3.-tuple (7.-tuple nat), undup_uniq [:: t; t].
\end{coq}
\coqrun{name=tupc}{ssr,require-tuple,testtup}

Although all these proofs and definitions are specific to \C{tuple},
we are following a general schema here, involving
three parameters: the original type \C{(seq T)}, the sub-type
\C{(n.-tuple T)} and the projection \C{tval}.
The \mcbMC{} library provides a \emph{sub-type kit} to let one
write just the following text:

\begin{coq}{name=subt}{}
Canonical tuple_subType := [subType for tval].
Definition tuple_eqMixin := [eqMixin of n.-tuple T by <:].
Canonical tuple_eqType := EqType (n.-tuple T) tuple_eqMixin.
\end{coq}

Line 1 registers \C{tval} as a canonical projection to obtain a known
type out of the newly defined type of tuples.  Once the projection
is registered the equality axiom can be proved automatically by
\C{[eqMixin of n.-tuple T by <:]}, where \C{<:} is just a symbol
that is reminiscent of sub-typing in functional languages like OCaml.
Note that \C{hnf} is an evaluation strategy that focuses on the head
symbol of the expression and that ignores its subterms, see \cite[section
5.3.7, ``Performing computations'']{Coq:manual}.
The following section details the implementation of the sub-type kit.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{Declare a new subtype and derive eqType}
%\mcbPROVIDE{usage of \lstinline/[subType for ...]/}
%\mcbREQUIRE{}
\subsection{The sub-type kit}

%\warntechnical{}

When one has a base type T and a sub-type ST defined as a boolean
sigma type, the \mcbMC{} library provides facilities to
build all the applicable canonical instances from just
the name of the projection going from ST to T.

To register \C{tval} as the projection from tuples to sequences one
writes:

\begin{coq}{name=subt}{}
Canonical tuple_subType := Eval hnf in [subType for tval].
\end{coq}

As we will see in the next section, the \C{subType} structure provides
a generic notation \C{val} for the projector of a sub-type (i.e.,
\C{tval} for \C{tuple}), with an overloaded injectivity lemma
\lstinline/val_inj/ saying that two objects equal in T are also equal
in ST.

In addition to the generic projection, we get a generic static
constructor \C{Sub}, which takes a value in the type \C{T} and a proof.

More interestingly, the sub-type kit provides the dynamic constructors
\C{insub} and \C{insubd} that do not need a proof as they dynamically
test the property, and offer
an attractive encapsulation of the difficult \emph{convoy
pattern}~\cite[section 8.4]{CPDT}.
The \C{insubd} constructor takes a default
sub-type value which it returns if the tests fails, while \C{insub}
takes only a base type value and returns an \C{option}; both are
\emph{locked} and will not evaluate the test, even for a ground base
type value.\footnote{The equations describing the computation
of \C{insub} are called \C{insubT} and \C{insubF}.}

Both \C{Sub} and \C{insub} expect the typing context to
specify the sub-type.

Here are a few example uses, using \C{tuple}:

\begin{coq}{name=insub}{}
Variables (s : seq nat) (t : 3.-tuple nat).
Hypothesis size3s : size s == 3.
Let t1 : 3.-tuple nat := Sub s size3s.
Let t2 := if insub s is Some t then val (t : 3.-tuple nat) else nil.
Let t3 := insubd t s. (* : 3.-tuple nat *)
\end{coq}

We put \C{insub} to good use in section~\ref{sec:ordfintype} when
an enumeration for sub-types is to be defined.

The \C{subType} structure describes a \emph{boolean sigma-type} (a
dependent pair whose second component is the proof of a boolean
formula) in terms of
its projector, constructor, and elimination rule:

\begin{coq}{name=subtdef}{}
Section SubTypeKit.
Variables (T : Type) (P : pred T).

Structure subType : Type := SubType {
  sub_sort :> Type;
  val : sub_sort -> T;
  Sub : forall x, P x -> sub_sort;
  (* elimination rule for sub_sort *)
  _ : forall K (_ : forall x Px, K (@Sub x Px)) u, K u;
  _ : forall x Px, val (@Sub x Px) = x
}.
\end{coq}

Instances can provide unification hints for any of the three named fields,
not just for \lstinline/sub_sort/. Hence, \lstinline/val $?_u$/
unifies with \lstinline/tval t/, and \lstinline/Sub $?_x$ $?_{xP}$/
unifies with \lstinline/Tuple s sP/, including in \C{rewrite} patterns.

The \C{subType} constructor notation assumes the sub-type is isomorphic
to a sigma-type, so that its elimination rule can be derived using \Coq{}'s
generic destructing \C{let}, and the projector-constructor
identity can be proved by reflexivity.

\begin{coq}{name=subtdecl}{}
Notation "[ 'subType' 'for' v ]" := (SubType _ v _
  (fun K K_S u => let (x, Px) as u return K u := u in K_S x Px)
  (fun x px => erefl x)).
\end{coq}

Note how the value of \C{Sub} is determined by unifying the type
of the first function with the type expected by \C{SubType}, with the
help of the ``\C{as u return K u}'' annotation, see~\cite[section
1.2.13]{Coq:manual}.

A useful variant of \C{[subType for tval]} is \C{[newType for Sval]}.
Such specialized constructors force the predicate defining the
sub-type to be the trivial one: the sub-type ST adds no property to
the type T, but the resulting type ST is different from T and
inhabitants of ST cannot be mistaken for inhabitants of T.  Of course
all the theory that equips T is also available on ST.  Aliasing a
type is useful to attach to it different notations or coercions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A note on boolean $\Sigma$-types\label{hedberg}}
\index[concept]{proof irrelevance}

The \C{eq_irrelevance} theorem used to prove that tuples form an
\C{eqType} is a delicate matter in the \mcbCIC{}.  In particular it
is not valid in general: two proofs of the same predicate may not be
provably equal.

To the rescue comes the result of Hedberg~\cite{Hedberg}
that proves such property for a wide class of predicates.
In particular it shows that any type with decidable identity
has unique identity proofs. This result can be proved in its full generality
in the \mcbMC{} library, using to the \C{eqType} interface.

\begin{coq}{name=hedberg}{title=Hedberg}
Theorem eq_irrelevance (T : eqType) (x y : T) : forall e1 e2 : x = y, e1 = e2.
\end{coq}
\coqrun{name=hedberg}{ssr,hedberg,abort}

If we pick the concrete example of \lstinline/bool/,
then all proofs that \lstinline/(b = true)/
for a fixed \lstinline/b/ are identical.

Here we can see another crucial advantage of boolean reflection.
Forming sub-types poses no complication from a logic perspective since
proofs of boolean identities are very simple, canonical, objects.

In the \mcbMC{} library, where \emph{all predicates that can} be
expressed as a boolean function \emph{are expressed as a boolean
function}, forming sub-types is extremely easy.

\mantra{It is convenient to define new types as sub-types of existing
ones, since they inherit all the theory.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbREQUIRE{eqtype,CS}
%\mcbPROVIDE{fintype}
%\mcbNOTES{}
\section{Finite types and their theory}

Before describing other sub-types, we introduce the interface of
types equipped with a finite enumeration.

\begin{coq}{name=fintype}{title=Interface for finite types}
Notation count_mem x := (count [pred y | y == x]).
Module Finite.
Definition axiom (T : eqType) (e : seq T) :=
  forall x : T, count_mem x e = 1.

Record mixin_of (T : eqType) := Mixin {
  enum : seq T;
  _ : axiom enum;
}
End Finite.
\end{coq}

The axiom asserts that any inhabitant of \C{T} occurs exactly once
in the enumeration \C{e}.  We omit here the full definition of the
interface, as it will be discussed in detail in the next chapter.
What is relevant for the current section is that \C{finType} is the
structure of types equipped with such enumeration, that any \C{finType}
is also an \C{eqType} (see the parameter of the mixin), and that,
to declare a \C{finType} instance, one can write:

\begin{coq}{name=fintype}{title=Declare a finType}
Definition mytype_finMixin := Finite.Mixin mytype_enum mytype_enumP.
Canonical mytype_finType := @Finite.Pack mytype mytype_finMixin.
\end{coq}

Given that the most recurrent way of showing that an enumeration
validates \C{Finite.axiom} is by proving that it is both duplicate-free
and exhaustive, a convenience mixin constructor is provided.

\begin{coq}{name=fintype}{title=Declare a finType}
Lemma myenum_uniq : uniq myenum.
Lemma mem_myenum : forall x : T, x \in myenum.
Definition mytype_finMixin := Finite.UniqFinMixin myenum_uniq mem_myenum.
\end{coq}

The interface of \C{finType} comes equipped with a theory that, among
other things, provides a cardinality operator \C{#|T|} and bounded
boolean quantifications like \C{[forall x, P]}.

\begin{coq}{name=fintype-th}{title=Some theory for finType}
Lemma cardT (T : finType) : #|T| = size (enum T).
Lemma forallP (T : finType) (P : pred T) : reflect (forall x, P x) [forall x, P x].
\end{coq}

Given that \C{[forall x, P x]} is a boolean expression,
it enables reasoning by excluded middle and also combines well with
other boolean connectives.

What makes this formulation of finite types handy is the explicit
enumeration.  It is hence trivial to iterate over the inhabitants of the
finite type.  This makes finite type easy to integrate in the
library of iterated operations.  In particular notations like
\C{(\\sum_(i : T) F)} are used to express the iteration over the
inhabitants of the finite type \C{T}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \mcbLEARN{}
% \mcbREQUIRE{eqtype,CS}
% \mcbPROVIDE{fintype}
% \mcbNOTES{}
\section{The ordinal subtype}\label{sec:ordfintype}

Apart from the aforementioned theory, finite types can serve as a
powerful notational device for ranges.  For example one may want
to state that a matrix of size $m \times n$ is only accessed inside
its bounds, i.e., that one cannot get the $m+1$ row.  The way this will
be formulated in the \mcbMC{} library is by saying that its row
accessors accept only inhabitants of a finite type of size $m$.
Accessing a matrix out of its bounds becomes a type error.
Of course one wants to access a matrix using integer coordinates, but
integers are infinite.  Hence the first step is to define the sub-type
of bounded integers:

\begin{coq}{name=ordinals}{title=Ordinals}
Inductive ordinal (n : nat) : Type := Ordinal m of m < n.
Notation "''I_' n" := (ordinal n)

Coercion nat_of_ord i := let: @Ordinal m _ := i in m.

Canonical ordinal_subType := [subType for nat_of_ord].
Definition ordinal_eqMixin := Eval hnf in [eqMixin of ordinal by <:].
Canonical ordinal_eqType := Eval hnf in EqType ordinal ordinal_eqMixin.
\end{coq}
The constructor \C{Ordinal} has two arguments: a natural number \C{m}
and a proof that this number is smaller than the parameter \C{n}. We
use the \C{of} notation for arguments of constructors that do not need
to be named; thus \C{Ordinal m of m < n} stands for
\C{Ordinal m (_ : m < n)}
\index[coq]{\C{of}}


We start by making ordinals a subtype of natural numbers, and hence
inherit the theory of \C{eqType}.  To show they form a \C{finType},
we need to provide a good enumeration.

\begin{coq}{name=ordinals}{}
Definition ord_enum n : seq (ordinal n) := pmap insub (iota 0 n).
\end{coq}

The \C{iota} function produces the sequence \C{[:: 0; 1; ...; n.-1]}.
Such a sequence is mapped via \C{insub} that tests if an element \C{x}
is smaller than \C{n}.  If it is the case it produces \C{(Some x)},
where \C{x} is an ordinal, else \C{None}.  \C{pmap} drops all \C{None}
items, and removes the \C{Some} constructor from the others.

What \C{ord\_enum} produces is hence a sequence of ordinals, i.e.,
a sequence of terms like \C{(@Ordinal m p)} where \C{m} is a natural
number (as produced by \C{iota}) and \C{p} is a proof that \C{(m <=
n)}.  What we are left to show is that such an enumeration is complete
and non-redundant.

\begin{coq}{}{}
Lemma val_ord_enum : map val ord_enum = iota 0 n.
Proof.
rewrite pmap_filter; last exact: insubK.
by apply/all_filterP; apply/allP=> i; rewrite mem_iota isSome_insub.
Qed.

Lemma ord_enum_uniq : uniq ord_enum.
Proof. by rewrite pmap_sub_uniq ?iota_uniq. Qed.

Lemma mem_ord_enum i : i \in ord_enum.
Proof. by rewrite -(mem_map ord_inj) val_ord_enum mem_iota ltn_ord. Qed.
\end{coq}

It is worth pointing out how the \C{val\_ord\_enum} lemma
shows that the ordinals in \C{ord\_enum} are exactly the
natural numbers generated by \C{(iota 0 n)}.  In particular,
the \C{insub} construction completely removes the need for
complex dependent case analysis.

\begin{coqout}{}{}
2 subgoals
n : nat
============================
[seq x <- iota 0 n | isSome (insub x)] = iota 0 n

subgoal 2 is:
  ocancel insub val
\end{coqout}

The view \C{all\_filterP} shows that
\C{reflect ([seq x <- s | a x] = s) (all a s)} for any
sequence \C{s} and predicate \C{a}.  After applying
that view, one has to prove that if \C{(i \\in iota 0 n)} then \C{(i <
n)}, that is trivialized by \C{mem\_iota}.

We can now declare the type of ordinals as a instance of \C{finType}.

\begin{coq}{}{}
Definition ordinal_finMixin n :=
  Eval hnf in UniqFinMixin (ord_enum_uniq n) (mem_ord_enum n).
Canonical ordinal_finType n :=
  Eval hnf in FinType (ordinal n) (ordinal_finMixin n).
\end{coq}

An example of ordinals at work is the \C{tnth} function.
It extracts the $n$-th element of a tuple exactly as
\C{nth} for a sequence but without requiring a default element.
As a matter of fact, one can use ordinals to type the index, making
\Coq{} statically checks that the index is smaller than the size of
the tuple.


\begin{coq}{name=subtdecl}{}
Lemma tnth_default T n (t : n.-tuple T) : 'I_n -> T.
Proof. by rewrite -(size_tuple t); case: (tval t) => [|//] []. Qed.

Definition tnth T n (t : n.-tuple T) (i : 'I_n) : T :=
  nth (tnth_default t i) t i.
\end{coq}

Another use of ordinals is to express the position of an
inhabitant of a \C{finType} in its enumeration.

\begin{coq}{name=subtdecl}{}
Definition enum_rank (T : finType) : T -> 'I_#|T|.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbPROVIDE{}
%\mcbREQUIRE{}
\section{Finite functions}

In standard mathematics, functions that are pointwise equal are
considered as equal.  This principle, that we call \emph{functional
extensionality}, is compatible with the \mcbCIC{} but is not built-in.
At the time of writing, only very recent variations of CIC,
like Cubical Type Theory~\cite{cubicaltt}, include such a principle.
\index[concept]{functional extensionality}

Still, this principle is provable in \Coq{} for functions with a
finite domain, provided that they are described with a suitable
representation. Indeed, the graph of a function with a finite domain
is just a finite set of points, which can be represented by a finite
sequence of values. The length of this sequence is the size of the
domain. Pointwise equal finite functions have the same sequence of
values, hence their representations are equal.
The actual definition\footnote{Since \mcbMC{} version 1.9 the definition
of finite functions changed.
The new implementation is based on a specific list-like data type indexed over
the list of the elements of the domain. Thanks to this more sophisticated
encoding, the current Coq type checker accepts, for example, the following
declaration of a 3-branch tree:
\C{Inductive tree3 := Leaf of nat | Node of \{ffun 'I_3 -> tree3\}.}
At the time of writing Coq rejects the declaration above with the definition
of finite functions given in this section since the so called
``positivity checker'' is too incomplete.}
of the type of finite functions in the \mcbMC{}
library uses this remark, plus the tricks explained in
section~\ref{sec:phantom}

\begin{coq}{name=subtdecl2}{}
Section FinFunDef.
Variable (aT : finType). (* domain type *)
Variable (rT : Type). (* codomain type *)

Inductive finfun_type : Type := Finfun of #|aT|.-tuple rT.
Definition finfun_of of phant (aT -> rT) := finfun_type.
Definition fgraph f := let: Finfun t := f in t.

Canonical finfun_subType := Eval hnf in [newType for fgraph].

End FinFunDef.

Notation "{ 'ffun' fT }" := (finfun_of (Phant fT)).
\end{coq}
As a result, the final notation provides a way to describe an instance of
the type of finite function by giving the mere type of the domain and
co-domain, without mentioning the name of the instance of \C{finType}
for the domain. One can thus write the term \C{\{ffun 'I_7 -> nat\}}
but the term \C{\{ffun nat -> nat\}} would raise an error message, and
there cannot be a registered instance of finite type for \C{nat}.

Other utilities let one apply a finite function as a regular function
or build a finite function from a regular function.

\begin{coq}{name=subtdecl}{}
Definition fun_of_fin aT rT f x := tnth (@fgraph aT rT f) (enum_rank x).
Coercion fun_of_fin : finfun >-> Funclass.
Definition finfun aT rT f := @Finfun aT rT (codom_tuple f).
Notation "[ 'ffun' x : aT => F ]" := (finfun (fun x : aT => F))
\end{coq}

What \C{codom\_tuple} builds is a list of values \C{f} takes
when applied to the values in the enumeration of its domain.

\begin{coq}{name=subtdecl}{}
Check [ffun i : 'I_4 => i + 2].  (* : {ffun 'I_4 -> nat} *)
\end{coq}

Finite functions inherit from tuples the \C{eqType} structure
whenever the codomain is an \C{eqType}.

\begin{coq}{}{}
Definition finfun_eqMixin aT (rT : eqType) :=
  Eval hnf in [eqMixin of finfun aT rT by <:].
Canonical finfun_eqType :=
  Eval hnf in EqType (finfun aT rT) finfun_eqMixin.
\end{coq}

When the codomain is finite, the type of finite functions is itself
finite.  This property is again inherited from tuples.  
The \C{all\_words} program takes in input a
length \C{n} and an alphabet (a sequence of symbols \C{(enum T)}) and
generates a list of all words of size \C{n} using the symbols from the
alphabet.

\begin{coq}{}{}
Definition tuple_enum (T : finType) n : seq (n.-tuple T) :=
  pmap insub (all_words n (enum T)).
Lemma enumP T n : Finite.axiom (tuple_enum T n).

Definition tuple_finMixin := Eval hnf in FinMixin (@FinTuple.enumP n T).
Canonical tuple_finType:= Eval hnf in FinType (n.-tuple T) tuple_finMixin.

Definition finfun_finMixin (aT rT : finType) :=
  [finMixin of (finfun aT rT) by <:].
Canonical finfun_finType  aT rT :=
  Eval hnf in FinType (finfun aT rT) (finfun_finMixin aT rT).
\end{coq}

A relevant property of the \C{finType} of finite functions is its
cardinality, being equal to \C{#|rT| ^ #|aT|}.

\begin{coq}{}{}
Lemma card_ffun (aT rT : finType) : #| {ffun aT -> rT} | = #|rT| ^ #|aT|.
\end{coq}

Also, as expected, finite functions validate extensionality.

\begin{coq}{}{}
Definition eqfun (f g : B -> A) : Prop := forall x, f x = g x.
Notation "f1 =1 f2" := (eqfun f1 f2).

Lemma ffunP aT rT (f1 f2 : {ffun aT -> rT}) : f1 =1 f2 <-> f1 = f2.
\end{coq}
\index[coq]{\C{(_ =1 _)}}

A first application of the type of finite functions is the following
lemma.

\begin{coq}{}{}
Lemma bigA_distr_bigA (I J : finType) F :
  \big[*%M/1]_(i : I) \big[+%M/0]_(j : J) F i j
    = \big[+%M/0]_(f : {ffun I -> J}) \big[*%M/1]_i F i (f i).
\end{coq}

Such lemma, rephrased in mathematical notation down below,
states that the indices \C{i} and \C{j} are chosen independently.

$$
\prod_{i \in I} \sum_{j \in J} F i j = \sum_{f \in I \to J} \prod_{i \in I} F i (f i)
$$

Remark how the finite type of
functions from \C{I} to \C{J} is systematically formed in order to
provide its enumeration as the range of the summation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbPROVIDE{}
%\mcbREQUIRE{}
\section{Finite sets}

We have seen how sub-types let one easily define a new type by, typically,
enriching an existing one with some properties.  While this is very
convenient for defining new types, it does not work well when the
subject of study are sets and subsets of the type's inhabitants.
In such case, it is rather inconvenient to define a new type for
each subset, because one typically combines elements of
two distinct subsets with homogeneous operations, like equality.

The \mcbMC{} library provides an extensive library of finite sets and
subsets that constitutes the pillar of finite groups.

\begin{coq}{}{}
Section finSetDef.
Variable T : finType.
Inductive set_type : Type := FinSet of {ffun pred T}.
Definition finfun_of_set A := let: FinSet f := A in f.
\end{coq}

Recall that \C{(pred T)} is the type of functions from \C{T} to
\C{bool}.


Using the sub-type kit we can easily transport the
\C{eqType} and \C{finType} structure over finite sets.

\begin{coq}{}{}
Canonical set_subType := Eval hnf in [newType for finfun_of_set].
Definition set_eqMixin := Eval hnf in [eqMixin of set_type by <:].
Canonical set_eqType := Eval hnf in EqType set_type set_eqMixin.
Definition set_finMixin := [finMixin of set_type by <:].
Canonical set_finType := Eval hnf in FinType set_type set_finMixin.
End finSetDef.
Notation "{ 'set' T }" := (set_type T).
\end{coq}

We omit again the trick to statically enforce that \C{T} is
a finite type whenever we write \C{\{set T\}}, exactly as we did for
finite functions.  Finite sets do validate extensionality and
are equipped with subset-wise and point-wise operations:

\begin{coq}{}{}
Lemma setP A B : A =i B <-> A = B.

Lemma example (T : finType) (x : T) (A : {set T}) :
  (A \subset x |: A) && (A :==: A :&: A) && (x \in [set y | y == x])
\end{coq}

It is worth noticing that many ``set'' operations are actually defined
on simpler structures we did not detail for conciseness.  In
particular membership and subset are also applicable to
predicates, i.e. terms that can be seen as functions from a type to
\C{bool}.

Since \C{T} is finite, values of type \C{\{set T\}} admit a
complement and \C{\{set T\}} is closed under power-set construction.

\begin{coq}{}{}
Lemma setCP x A : reflect (~ x \in A) (x \in ~: A).
Lemma subsets_disjoint A B : (A \subset B) = [disjoint A & ~: B].
Definition powerset D : {set {set T}} := [set A : {set T} | A \subset D].
Lemma card_powerset (A : {set T}) : #|powerset A| = 2 ^ #|A|.
\end{coq}

We have seen how tuples can be used to carry an invariant over
sequences. In particular type inference was programmed to
automatically infer the effect of sequence operations over the
size of the input tuple.  In a similar way finite groups can naturally
be seen as sets and some set-wise operations, like intersection,
do preserve the group structure and type inference can be programmed
to infer so automatically.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbPROVIDE{}
%\mcbREQUIRE{}
\section{Permutations}

Another application of finite functions is the definition of
the type of permutations.

\begin{coq}{}{}
Inductive perm_of (T : finType) : Type :=
  Perm (pval : {ffun T -> T}) & injectiveb pval.
Definition pval p := let: Perm f _ := p in f.
Notation "{ 'perm' T }" := (perm_of T).
\end{coq}

This time we add the property of being injective, that in conjunction
with finiteness characterizes permutations as bijections.

Similarly to finite functions we can declare a coercion to let
one write \C{(s x)} for \C{(s : \{perm T\})} to denote
the result of applying the permutation \C{s} to \C{x}.

Thanks to the sub-type kit it is easy to transport to the type
\C{\{perm T\}} the \C{eqType} and \C{finType} structures of \C{ffun T
-> T}.

\begin{coq}{}{}
Canonical perm_subType := Eval hnf in [subType for pval].
Definition perm_eqMixin := Eval hnf in [eqMixin of perm_type by <:].
Canonical perm_eqType := Eval hnf in EqType perm_type perm_eqMixin.
Definition perm_finMixin := [finMixin of perm_type by <:].
Canonical perm_finType := Eval hnf in FinType perm_type perm_finMixin.
\end{coq}

A special class of permutations that comes in handy to express the
calculation of a matrix determinant is the permutation of
\C{'I_n}.

\begin{coq}{}{}
Notation "''S_' n" := {perm 'I_n}.
\end{coq}

A relevant result of the theory of permutations is about
counting their number.  It is expressed on a subset \C{S} and
counts only non-identity permutations.

\begin{coq}{}{}
Definition perm_on T (S : {set T}) : pred {perm T} :=
  fun s => [set x | s x != x] \subset S.
Lemma card_perm A : #|perm_on A| = #|A| `!.
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mcbLEARN{}
%\mcbPROVIDE{}
%\mcbREQUIRE{}
\section{Matrix}
\label{sec:matrix}

We finally have all the bricks to define the type of matrices
and provide compact formulations for their most common operations.

\begin{coq}{}{}
Inductive matrix R m n : Type := Matrix of {ffun 'I_m * 'I_n -> R}.
Definition mx_val A := let: Matrix g := A in g.
Notation "''M[' R ]_ ( m , n )" := (matrix R m n).
Notation "''M_' ( m , n )" := (matrix _ m n).
Notation "''M[' R ]_ n" := (matrix R n n).
\end{coq}

As for permutations and finite functions we declare a coercion
to let one denote \C{(A i j)} the coefficient in column j of
row i.  Note that type inference will play an important role
here.  If \C{A} has type \C{'M[R]_(m,n)}, then \Coq{}
will infer that \C{(i : 'I_m)} and \C{(j : 'I_n)} from
the expression \C{(A i j)}. In combination
with the notations for iterated operations, this lets one
define, for example, the trace of a square matrix as follows.

\begin{coq}{}{}
Definition mxtrace R n (A : 'M[R]_n) := \sum_i A i i.
Local Notation "'\tr' A" := (mxtrace R n A).
\end{coq}

Note that, for the \C{\\sum} notation to work, \C{R} needs to be
a type equipped with an addition, for example a \C{ringType}.
We will describe such type only in the next chapter.  From now
on the reader shall interpret the \C{+} and \C{*} symbols on
the matrix coefficients as (overloaded) ring operations, exactly
as \C{==} is the overloaded comparison operation of \C{eqType}.

Via the sub-type kit we can transport \C{eqType} and \C{finType}
from \C{\{ffun 'I_m * 'I_n -> R\}} to \C{'M[R]_(m,n)}.  We omit
the \Coq{} code for brevity.

A useful accessory is the notation to define matrices in
their extension.  We provide a variant in which the matrix size
is given and one in which it has to be inferred from the context.

\begin{coq}{}{}
Definition matrix_of_fun R m n F :=
  Matrix [ffun ij : 'I_m * 'I_n => F ij.1 ij.2].
Notation "\matrix_ ( i < m , j < n ) E" :=
  (matrix_of_fun (fun (i : 'I_m) (j : 'I_n) => E))
Notation "\matrix_ ( i , j ) E" := (matrix_of_fun (fun i j => E)).

Example diagonal := \matrix_(i < 3, j < 7) if i == j then 1 else 0.
\end{coq}

An interesting definition is the one of
determinant.  We base it on Leibniz's formula:
$\sum_{\sigma \in S_n} \mbox{sgn}(\sigma) \prod_{i = 1}^n A_{i,
\sigma(i)}$.

\begin{coq}{}{}
Definition determinant n (A : 'M_n) : R :=
  \sum_(s : 'S_n) (-1) ^+ s * \prod_i A i (s i).
\end{coq}

The \C{(-1) ^+ s} denotes the signature of a permutation \C{s}:
\C{s} can be used, thanks to a coercion, as a natural number
that is \C{0} if \C{s} is an even permutation, \C{1} otherwise,
and \C{^+} is ring exponentiation.  In other words the \C{(-1)}
factor is annihilated when \C{s} is even.

What makes this definition remarkable is the resemblance to the
same formula typeset in \LaTeX:
{\small
\begin{verbatim}
  \sum_{\sigma \in S_n} \sgn(\sigma) \prod_{i = 1}^n A_{i, \sigma(i)}
\end{verbatim}
}

Matrix multiplication deserves a few comments too.

\begin{coq}{}{}
Definition mulmx m n p (A : 'M_(m, n)) (B : 'M_(n, p)) : 'M[R]_(m, p) :=
  \matrix_(i, k) \sum_j (A i j * B j k).
Notation "A *m B" := (mulmx A B) : ring_scope.
\end{coq}

First, the type of the inputs makes such operation total, i.e., \Coq{}
rejects terms which would represent the product of two matrices whose
sizes are incompatible.

This has to be compared with what was done for integer division, that
was made total by returning a default value, namely \C{0}, outside
its domain.  In the case of matrices a size annotation is enough to make
the operation total, while for division a proof would be necessary.
Working with rich types is not always easy, for example the type
checker does not understand automatically that a square matrix of
size \C{(m + n)} can be multiplied with a matrix of size \C{(n + m)}.
In such case the user has to introduce explicit size casts,
see section~\ref{sec:castmx}.  At the same time type inference lets one omit
size information most of the time, playing once again the role of a
trained reader.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Example: matrix product commutes under trace}

As an example let's take the following simple property of the trace.
Note that we can omit the dimensions of \C{B} since it
is multiplied by \C{A} to the left and to the right.

\begin{coq}{}{}
Lemma mxtrace_mulC m n (A : 'M[R]_(m, n)) B :
   \tr (A *m B) = \tr (B *m A).
Proof.
have -> : \tr (A *m B) = \sum_i \sum_j A i j * B j i.
  by apply: eq_bigr => i _; rewrite mxE.
\end{coq}

The idea of the proof is to lift the commutativity property
of the multiplication in the coefficient's ring.
The first step is to prove an equation that expands the trace of
matrix product.  The plan is to expand it on both sides, then
exchange the summations and compare the coefficients
pairwise.

\begin{coqout}{}{}
1 subgoal
R : comRingType
m, n : nat
A : 'M_(m, n)
B : 'M_(n, m)
============================
\sum_i \sum_j A i j * B j i = \tr (B *m A)
\end{coqout}

It is worth noticing that the equation we used to expand the left-hand
side and the one we need to expand the right-hand side are very
similar.  Actually the sub proof following \C{have}
can be generalized to any pair of matrices \C{A} and \C{B}.  The
\mcbSSR{} proof language provides the \C{gen} modifier in order to tell \C{have}
to abstract the given formula over a list of context entries, here \C{m
n A B}.

\begin{coq}{}{}
Lemma mxtrace_mulC m n (A : 'M[R]_(m, n)) B :
   \tr (A *m B) = \tr (B *m A).
Proof.
gen have trE, trAB: m n A B / \tr (A *m B) = \sum_i \sum_j A i j * B j i.
  by apply: eq_bigr => i _; rewrite mxE.
rewrite trAB trE.
\end{coq}
\index[ssr]{\C{gen have name : name / type}}

The \C{gen have} step now generates two equations, a general one
called \C{trE}, and its instance to \C{A} and \C{B} called \C{trAB}.

\begin{coqout}{}{}
1 subgoal
R : comRingType
m, n : nat
A : 'M_(m, n)
B : 'M_(n, m)
trE : forall m n (A : 'M_(m, n)) B, \tr (A *m B) = \sum_i \sum_j A i j * B j i
trAB : \tr (A *m B) = \sum_i \sum_j A i j * B j i
============================
\sum_i \sum_j A i j * B j i = \sum_i \sum_j B i j * A j i
\end{coqout}

The proof is then concluded by exchanging the summations, i.e.,
summing
on both sides first on \C{i} then on \C{j}, and then proving their
equality by showing the identity on the summands.

\begin{coq}{}{}
rewrite exchange_big /=.
by do 2!apply: eq_bigr => ? _; apply: mulrC.
Qed.
\end{coq}

Note that the final identity is true only if the multiplication
of the matrix coefficients is commutative.  Here \C{R}
was assumed to be a \C{comRingType}, the structure of commutative
rings and \C{mulrC} is the name of the commutative property (\C{C}) of
ring (\C{r}) multiplication (\C{mul}).
A more detailed description of the hierarchy of structures is the
subject of the next chapter.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block operations}

The size information stored in the type of a matrix is
also used to drive the decomposition of a matrix into sub-matrices,
called blocks.  For example when the size expression of a square
matrix is like \C{(n1 + n2)}, then the upper left block
is a square matrix of size \C{n1}.

\begin{coq}{}{title=Block destructors}
Definition lsubmx (A : 'M_(m, n1 + n2)) : 'M_(m, n1)
Definition usubmx (A : 'M_(m1 + m2, n)) : 'M_(m1, n)
Definition ulsubmx (A : 'M_(m1 + m2, n1 + n2)) : 'M_(m1, n1)
\end{coq}
Conversely blocks can be glued together.  This time, it is the
size of the resulting matrix that shows a trace of the way
it was built.
\index[coq]{\C{lsubmx}}
\index[coq]{\C{usubmx}}
\index[coq]{\C{ulsubmx}}

\begin{coq}{}{title=Block constructors}
Definition row_mx (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) : 'M_(m, n1 + n2)
Definition col_mx (A1 : 'M_(m1, n)) (A2 : 'M_(m2, n)) : 'M_(m1 + m2, n)
Definition block_mx Aul Aur Adl Adr : 'M_(m1 + m2, n1 + n2)
\end{coq}
\index[coq]{\C{block_mx}}
\index[coq]{\C{row_mx}}
\index[coq]{\C{col_mx}}

The interested reader can find in~\cite{packedclasses}
a description of Cormen's LUP decomposition, an algorithm
making use of these constructions.  In particular, recursion
on the size of a square matrix of size $n$ naturally identifies
an upper left square block of size 1, a row and a column of length $n-1$,
and a square block of size $n-1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Size casts}\label{sec:castmx}

%%\warntechnical{}

Types containing values are a double edged sword.  While we have seen that
they make the writing of matrix expressions extremely succinct, in
some cases
they require extra care.  In particular the equality predicate accepts
arguments of the very same type.  Hence a statement like this one
requires a size cast:

\begin{coq}{}{}
Section SizeCast.
Variables (n n1 n2 n3 m m1 m2 m3 : nat).

Lemma row_mxA (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) (A3 : 'M_(m, n3)) :
  row_mx A1 (row_mx A2 A3) = row_mx (row_mx A1 A2) A3.
\end{coq}

Observe that the left hand side has type \C{'M_(m, n1 + (n2 + n3))} while
the right hand side has type \C{'M_(m, (n1 + n2) + n3)}.  The
\C{castmx} operator, and all its companion lemmas, let one deal with
this inconvenience.

\begin{coq}{}{}
Lemma row_mxA (A1 : 'M_(m, n1)) (A2 : 'M_(m, n2)) (A3 : 'M_(m, n3)) :
  let cast := (erefl m, esym (addnA n1 n2 n3)) in
  row_mx A1 (row_mx A2 A3) = castmx cast (row_mx (row_mx A1 A2) A3).
\end{coq}
\index[coq]{\C{castmx}}
The \C{cast} object provides the proof evidence that \C{(m = m)}, not
strictly needed, and that \C{(n1 + (n2 + n3) = (n1 + n2) + n3)}.

Lemmas like the following two let one insert or remove additional
casts.

\begin{coq}{}{}
Lemma castmxKV (eq_m : m1 = m2) (eq_n : n1 = n2) :
  cancel (castmx (esym eq_m, esym eq_n)) (castmx (eq_m, eq_n)).
Lemma castmx_id m n erefl_mn (A : 'M_(m, n)) : castmx erefl_mn A = A.
\end{coq}
\index[coq]{\C{castmx_id}}
\index[coq]{\C{castmxKV}}
Remark that \C{erefl_mn} must have type \C{((m = m) * (n = n))}, i.e.,
it is a useless cast.

Another useful tool is \C{conform_mx} that takes a default matrix of
the right dimension and a second one that is returned only if its
dimensions match.

\begin{coq}{}{}
Definition conform_mx (B : 'M_(m1, n1)) (A : 'M_(m, n)) :=
  match m =P m1, n =P n1 with
  | ReflectT eq_m, ReflectT eq_n => castmx (eq_m, eq_n) A
  | _, _ => B
  end.
\end{coq}
Remember that the notation \C{(m =P m1)} stands for
\C{(@eqP nat_eqType m m1)}, a proof of the \C{reflect} inductive spec.
Remember also that the \C{ReflectT} constructor carries a proof of the
equality.

The following helper lemmas describe the behavior of \C{conform_mx}
and how it interacts with casts.

\begin{coq}{}{}
Lemma conform_mx_id (B A : 'M_(m, n)) : conform_mx B A = A.
Lemma nonconform_mx (B : 'M_(m1, n1)) (A : 'M_(m, n)) :
  (m != m1) || (n != n1) -> conform_mx B A = B.

Lemma conform_castmx (e_mn : (m2 = m3) * (n2 = n3))
  (B : 'M_(m1, n1)) (A : 'M_(m2, n2)) :
    conform_mx B (castmx e_mn A) = conform_mx B A.
\end{coq}
\index[coq]{\C{conform_mx}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sorts and \C{reflect}}

%\warnverytechnical{}

The curious reader may have spotted that the declaration of the
\C{reflect} inductive predicate of section~\ref{ssec:specs} differs
from the one that is part of the \mcbMC{} library in a tiny detail.
The real declaration indeed puts \C{reflect} in \C{Type} and not in
\C{Prop}.

Recall that \C{reflect} is typically used to state properties about
decidable predicates. It is quite frequent to reason on such
a class of predicates by excluded middle in \emph{both} proofs and programs.
As soon as one needs proofs to cast terms, the proof evidence carried by
the reflection lemma becomes doubly useful.  Placing the declaration of
\C{reflect} in \C{Type} is enough to make such a proof
accessible within programs.

However the precise difference between \C{Prop} and \C{Type} in the
\mcbCIC{} is off topic for this text, so we will not detail further.
